
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Classe
 * 
 */
export type Classe = $Result.DefaultSelection<Prisma.$ClassePayload>
/**
 * Model Matiere
 * 
 */
export type Matiere = $Result.DefaultSelection<Prisma.$MatierePayload>
/**
 * Model Rang
 * 
 */
export type Rang = $Result.DefaultSelection<Prisma.$RangPayload>
/**
 * Model Coefficient
 * 
 */
export type Coefficient = $Result.DefaultSelection<Prisma.$CoefficientPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model Enseignant
 * 
 */
export type Enseignant = $Result.DefaultSelection<Prisma.$EnseignantPayload>
/**
 * Model Eleve
 * 
 */
export type Eleve = $Result.DefaultSelection<Prisma.$ElevePayload>
/**
 * Model Commentaire
 * 
 */
export type Commentaire = $Result.DefaultSelection<Prisma.$CommentairePayload>
/**
 * Model PieceJointe
 * 
 */
export type PieceJointe = $Result.DefaultSelection<Prisma.$PieceJointePayload>
/**
 * Model Enseignant_Classe
 * 
 */
export type Enseignant_Classe = $Result.DefaultSelection<Prisma.$Enseignant_ClassePayload>
/**
 * Model Trimestre
 * 
 */
export type Trimestre = $Result.DefaultSelection<Prisma.$TrimestrePayload>
/**
 * Model Note_inter
 * 
 */
export type Note_inter = $Result.DefaultSelection<Prisma.$Note_interPayload>
/**
 * Model Note_devoir
 * 
 */
export type Note_devoir = $Result.DefaultSelection<Prisma.$Note_devoirPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Directeur
 * 
 */
export type Directeur = $Result.DefaultSelection<Prisma.$DirecteurPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Classes
 * const classes = await prisma.classe.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Classes
   * const classes = await prisma.classe.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.classe`: Exposes CRUD operations for the **Classe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classe.findMany()
    * ```
    */
  get classe(): Prisma.ClasseDelegate<ExtArgs>;

  /**
   * `prisma.matiere`: Exposes CRUD operations for the **Matiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matieres
    * const matieres = await prisma.matiere.findMany()
    * ```
    */
  get matiere(): Prisma.MatiereDelegate<ExtArgs>;

  /**
   * `prisma.rang`: Exposes CRUD operations for the **Rang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rangs
    * const rangs = await prisma.rang.findMany()
    * ```
    */
  get rang(): Prisma.RangDelegate<ExtArgs>;

  /**
   * `prisma.coefficient`: Exposes CRUD operations for the **Coefficient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coefficients
    * const coefficients = await prisma.coefficient.findMany()
    * ```
    */
  get coefficient(): Prisma.CoefficientDelegate<ExtArgs>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs>;

  /**
   * `prisma.enseignant`: Exposes CRUD operations for the **Enseignant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enseignants
    * const enseignants = await prisma.enseignant.findMany()
    * ```
    */
  get enseignant(): Prisma.EnseignantDelegate<ExtArgs>;

  /**
   * `prisma.eleve`: Exposes CRUD operations for the **Eleve** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eleves
    * const eleves = await prisma.eleve.findMany()
    * ```
    */
  get eleve(): Prisma.EleveDelegate<ExtArgs>;

  /**
   * `prisma.commentaire`: Exposes CRUD operations for the **Commentaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commentaires
    * const commentaires = await prisma.commentaire.findMany()
    * ```
    */
  get commentaire(): Prisma.CommentaireDelegate<ExtArgs>;

  /**
   * `prisma.pieceJointe`: Exposes CRUD operations for the **PieceJointe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PieceJointes
    * const pieceJointes = await prisma.pieceJointe.findMany()
    * ```
    */
  get pieceJointe(): Prisma.PieceJointeDelegate<ExtArgs>;

  /**
   * `prisma.enseignant_Classe`: Exposes CRUD operations for the **Enseignant_Classe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enseignant_Classes
    * const enseignant_Classes = await prisma.enseignant_Classe.findMany()
    * ```
    */
  get enseignant_Classe(): Prisma.Enseignant_ClasseDelegate<ExtArgs>;

  /**
   * `prisma.trimestre`: Exposes CRUD operations for the **Trimestre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trimestres
    * const trimestres = await prisma.trimestre.findMany()
    * ```
    */
  get trimestre(): Prisma.TrimestreDelegate<ExtArgs>;

  /**
   * `prisma.note_inter`: Exposes CRUD operations for the **Note_inter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Note_inters
    * const note_inters = await prisma.note_inter.findMany()
    * ```
    */
  get note_inter(): Prisma.Note_interDelegate<ExtArgs>;

  /**
   * `prisma.note_devoir`: Exposes CRUD operations for the **Note_devoir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Note_devoirs
    * const note_devoirs = await prisma.note_devoir.findMany()
    * ```
    */
  get note_devoir(): Prisma.Note_devoirDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.directeur`: Exposes CRUD operations for the **Directeur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Directeurs
    * const directeurs = await prisma.directeur.findMany()
    * ```
    */
  get directeur(): Prisma.DirecteurDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.1
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Classe: 'Classe',
    Matiere: 'Matiere',
    Rang: 'Rang',
    Coefficient: 'Coefficient',
    Parent: 'Parent',
    Enseignant: 'Enseignant',
    Eleve: 'Eleve',
    Commentaire: 'Commentaire',
    PieceJointe: 'PieceJointe',
    Enseignant_Classe: 'Enseignant_Classe',
    Trimestre: 'Trimestre',
    Note_inter: 'Note_inter',
    Note_devoir: 'Note_devoir',
    Admin: 'Admin',
    Directeur: 'Directeur'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "classe" | "matiere" | "rang" | "coefficient" | "parent" | "enseignant" | "eleve" | "commentaire" | "pieceJointe" | "enseignant_Classe" | "trimestre" | "note_inter" | "note_devoir" | "admin" | "directeur"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Classe: {
        payload: Prisma.$ClassePayload<ExtArgs>
        fields: Prisma.ClasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findFirst: {
            args: Prisma.ClasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          findMany: {
            args: Prisma.ClasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>[]
          }
          create: {
            args: Prisma.ClasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          createMany: {
            args: Prisma.ClasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          update: {
            args: Prisma.ClasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          deleteMany: {
            args: Prisma.ClasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassePayload>
          }
          aggregate: {
            args: Prisma.ClasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasse>
          }
          groupBy: {
            args: Prisma.ClasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClasseCountArgs<ExtArgs>
            result: $Utils.Optional<ClasseCountAggregateOutputType> | number
          }
        }
      }
      Matiere: {
        payload: Prisma.$MatierePayload<ExtArgs>
        fields: Prisma.MatiereFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatiereFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatiereFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          findFirst: {
            args: Prisma.MatiereFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatiereFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          findMany: {
            args: Prisma.MatiereFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>[]
          }
          create: {
            args: Prisma.MatiereCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          createMany: {
            args: Prisma.MatiereCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MatiereDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          update: {
            args: Prisma.MatiereUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          deleteMany: {
            args: Prisma.MatiereDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatiereUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatiereUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatierePayload>
          }
          aggregate: {
            args: Prisma.MatiereAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatiere>
          }
          groupBy: {
            args: Prisma.MatiereGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatiereCountArgs<ExtArgs>
            result: $Utils.Optional<MatiereCountAggregateOutputType> | number
          }
        }
      }
      Rang: {
        payload: Prisma.$RangPayload<ExtArgs>
        fields: Prisma.RangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          findFirst: {
            args: Prisma.RangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          findMany: {
            args: Prisma.RangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>[]
          }
          create: {
            args: Prisma.RangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          createMany: {
            args: Prisma.RangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          update: {
            args: Prisma.RangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          deleteMany: {
            args: Prisma.RangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangPayload>
          }
          aggregate: {
            args: Prisma.RangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRang>
          }
          groupBy: {
            args: Prisma.RangGroupByArgs<ExtArgs>
            result: $Utils.Optional<RangGroupByOutputType>[]
          }
          count: {
            args: Prisma.RangCountArgs<ExtArgs>
            result: $Utils.Optional<RangCountAggregateOutputType> | number
          }
        }
      }
      Coefficient: {
        payload: Prisma.$CoefficientPayload<ExtArgs>
        fields: Prisma.CoefficientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoefficientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoefficientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          findFirst: {
            args: Prisma.CoefficientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoefficientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          findMany: {
            args: Prisma.CoefficientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>[]
          }
          create: {
            args: Prisma.CoefficientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          createMany: {
            args: Prisma.CoefficientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CoefficientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          update: {
            args: Prisma.CoefficientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          deleteMany: {
            args: Prisma.CoefficientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoefficientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoefficientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoefficientPayload>
          }
          aggregate: {
            args: Prisma.CoefficientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoefficient>
          }
          groupBy: {
            args: Prisma.CoefficientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoefficientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoefficientCountArgs<ExtArgs>
            result: $Utils.Optional<CoefficientCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      Enseignant: {
        payload: Prisma.$EnseignantPayload<ExtArgs>
        fields: Prisma.EnseignantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnseignantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnseignantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          findFirst: {
            args: Prisma.EnseignantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnseignantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          findMany: {
            args: Prisma.EnseignantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>[]
          }
          create: {
            args: Prisma.EnseignantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          createMany: {
            args: Prisma.EnseignantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnseignantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          update: {
            args: Prisma.EnseignantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          deleteMany: {
            args: Prisma.EnseignantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnseignantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnseignantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnseignantPayload>
          }
          aggregate: {
            args: Prisma.EnseignantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnseignant>
          }
          groupBy: {
            args: Prisma.EnseignantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnseignantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnseignantCountArgs<ExtArgs>
            result: $Utils.Optional<EnseignantCountAggregateOutputType> | number
          }
        }
      }
      Eleve: {
        payload: Prisma.$ElevePayload<ExtArgs>
        fields: Prisma.EleveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EleveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EleveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          findFirst: {
            args: Prisma.EleveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EleveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          findMany: {
            args: Prisma.EleveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>[]
          }
          create: {
            args: Prisma.EleveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          createMany: {
            args: Prisma.EleveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EleveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          update: {
            args: Prisma.EleveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          deleteMany: {
            args: Prisma.EleveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EleveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EleveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElevePayload>
          }
          aggregate: {
            args: Prisma.EleveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEleve>
          }
          groupBy: {
            args: Prisma.EleveGroupByArgs<ExtArgs>
            result: $Utils.Optional<EleveGroupByOutputType>[]
          }
          count: {
            args: Prisma.EleveCountArgs<ExtArgs>
            result: $Utils.Optional<EleveCountAggregateOutputType> | number
          }
        }
      }
      Commentaire: {
        payload: Prisma.$CommentairePayload<ExtArgs>
        fields: Prisma.CommentaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          findFirst: {
            args: Prisma.CommentaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          findMany: {
            args: Prisma.CommentaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>[]
          }
          create: {
            args: Prisma.CommentaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          createMany: {
            args: Prisma.CommentaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          update: {
            args: Prisma.CommentaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          deleteMany: {
            args: Prisma.CommentaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentairePayload>
          }
          aggregate: {
            args: Prisma.CommentaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentaire>
          }
          groupBy: {
            args: Prisma.CommentaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentaireCountArgs<ExtArgs>
            result: $Utils.Optional<CommentaireCountAggregateOutputType> | number
          }
        }
      }
      PieceJointe: {
        payload: Prisma.$PieceJointePayload<ExtArgs>
        fields: Prisma.PieceJointeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PieceJointeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PieceJointeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          findFirst: {
            args: Prisma.PieceJointeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PieceJointeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          findMany: {
            args: Prisma.PieceJointeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>[]
          }
          create: {
            args: Prisma.PieceJointeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          createMany: {
            args: Prisma.PieceJointeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PieceJointeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          update: {
            args: Prisma.PieceJointeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          deleteMany: {
            args: Prisma.PieceJointeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PieceJointeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PieceJointeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PieceJointePayload>
          }
          aggregate: {
            args: Prisma.PieceJointeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePieceJointe>
          }
          groupBy: {
            args: Prisma.PieceJointeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PieceJointeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PieceJointeCountArgs<ExtArgs>
            result: $Utils.Optional<PieceJointeCountAggregateOutputType> | number
          }
        }
      }
      Enseignant_Classe: {
        payload: Prisma.$Enseignant_ClassePayload<ExtArgs>
        fields: Prisma.Enseignant_ClasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Enseignant_ClasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Enseignant_ClasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          findFirst: {
            args: Prisma.Enseignant_ClasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Enseignant_ClasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          findMany: {
            args: Prisma.Enseignant_ClasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>[]
          }
          create: {
            args: Prisma.Enseignant_ClasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          createMany: {
            args: Prisma.Enseignant_ClasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Enseignant_ClasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          update: {
            args: Prisma.Enseignant_ClasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          deleteMany: {
            args: Prisma.Enseignant_ClasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Enseignant_ClasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Enseignant_ClasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Enseignant_ClassePayload>
          }
          aggregate: {
            args: Prisma.Enseignant_ClasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnseignant_Classe>
          }
          groupBy: {
            args: Prisma.Enseignant_ClasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<Enseignant_ClasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.Enseignant_ClasseCountArgs<ExtArgs>
            result: $Utils.Optional<Enseignant_ClasseCountAggregateOutputType> | number
          }
        }
      }
      Trimestre: {
        payload: Prisma.$TrimestrePayload<ExtArgs>
        fields: Prisma.TrimestreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrimestreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrimestreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          findFirst: {
            args: Prisma.TrimestreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrimestreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          findMany: {
            args: Prisma.TrimestreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>[]
          }
          create: {
            args: Prisma.TrimestreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          createMany: {
            args: Prisma.TrimestreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrimestreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          update: {
            args: Prisma.TrimestreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          deleteMany: {
            args: Prisma.TrimestreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrimestreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrimestreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrimestrePayload>
          }
          aggregate: {
            args: Prisma.TrimestreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrimestre>
          }
          groupBy: {
            args: Prisma.TrimestreGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrimestreGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrimestreCountArgs<ExtArgs>
            result: $Utils.Optional<TrimestreCountAggregateOutputType> | number
          }
        }
      }
      Note_inter: {
        payload: Prisma.$Note_interPayload<ExtArgs>
        fields: Prisma.Note_interFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Note_interFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Note_interFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          findFirst: {
            args: Prisma.Note_interFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Note_interFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          findMany: {
            args: Prisma.Note_interFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>[]
          }
          create: {
            args: Prisma.Note_interCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          createMany: {
            args: Prisma.Note_interCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Note_interDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          update: {
            args: Prisma.Note_interUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          deleteMany: {
            args: Prisma.Note_interDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Note_interUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Note_interUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_interPayload>
          }
          aggregate: {
            args: Prisma.Note_interAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote_inter>
          }
          groupBy: {
            args: Prisma.Note_interGroupByArgs<ExtArgs>
            result: $Utils.Optional<Note_interGroupByOutputType>[]
          }
          count: {
            args: Prisma.Note_interCountArgs<ExtArgs>
            result: $Utils.Optional<Note_interCountAggregateOutputType> | number
          }
        }
      }
      Note_devoir: {
        payload: Prisma.$Note_devoirPayload<ExtArgs>
        fields: Prisma.Note_devoirFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Note_devoirFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Note_devoirFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          findFirst: {
            args: Prisma.Note_devoirFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Note_devoirFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          findMany: {
            args: Prisma.Note_devoirFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>[]
          }
          create: {
            args: Prisma.Note_devoirCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          createMany: {
            args: Prisma.Note_devoirCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Note_devoirDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          update: {
            args: Prisma.Note_devoirUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          deleteMany: {
            args: Prisma.Note_devoirDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Note_devoirUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Note_devoirUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Note_devoirPayload>
          }
          aggregate: {
            args: Prisma.Note_devoirAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote_devoir>
          }
          groupBy: {
            args: Prisma.Note_devoirGroupByArgs<ExtArgs>
            result: $Utils.Optional<Note_devoirGroupByOutputType>[]
          }
          count: {
            args: Prisma.Note_devoirCountArgs<ExtArgs>
            result: $Utils.Optional<Note_devoirCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Directeur: {
        payload: Prisma.$DirecteurPayload<ExtArgs>
        fields: Prisma.DirecteurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirecteurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirecteurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          findFirst: {
            args: Prisma.DirecteurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirecteurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          findMany: {
            args: Prisma.DirecteurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>[]
          }
          create: {
            args: Prisma.DirecteurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          createMany: {
            args: Prisma.DirecteurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DirecteurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          update: {
            args: Prisma.DirecteurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          deleteMany: {
            args: Prisma.DirecteurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirecteurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DirecteurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirecteurPayload>
          }
          aggregate: {
            args: Prisma.DirecteurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirecteur>
          }
          groupBy: {
            args: Prisma.DirecteurGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirecteurGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirecteurCountArgs<ExtArgs>
            result: $Utils.Optional<DirecteurCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClasseCountOutputType
   */

  export type ClasseCountOutputType = {
    eleves: number
    enseignant_classe: number
    piecejointe: number
  }

  export type ClasseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eleves?: boolean | ClasseCountOutputTypeCountElevesArgs
    enseignant_classe?: boolean | ClasseCountOutputTypeCountEnseignant_classeArgs
    piecejointe?: boolean | ClasseCountOutputTypeCountPiecejointeArgs
  }

  // Custom InputTypes
  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClasseCountOutputType
     */
    select?: ClasseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountElevesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EleveWhereInput
  }

  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountEnseignant_classeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Enseignant_ClasseWhereInput
  }

  /**
   * ClasseCountOutputType without action
   */
  export type ClasseCountOutputTypeCountPiecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceJointeWhereInput
  }


  /**
   * Count Type MatiereCountOutputType
   */

  export type MatiereCountOutputType = {
    note_inter: number
    note_devoir: number
    rang: number
    enseignant_matiere: number
    commentaire: number
    piecejointe: number
  }

  export type MatiereCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note_inter?: boolean | MatiereCountOutputTypeCountNote_interArgs
    note_devoir?: boolean | MatiereCountOutputTypeCountNote_devoirArgs
    rang?: boolean | MatiereCountOutputTypeCountRangArgs
    enseignant_matiere?: boolean | MatiereCountOutputTypeCountEnseignant_matiereArgs
    commentaire?: boolean | MatiereCountOutputTypeCountCommentaireArgs
    piecejointe?: boolean | MatiereCountOutputTypeCountPiecejointeArgs
  }

  // Custom InputTypes
  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatiereCountOutputType
     */
    select?: MatiereCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountNote_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_interWhereInput
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountNote_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_devoirWhereInput
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountRangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RangWhereInput
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountEnseignant_matiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Enseignant_ClasseWhereInput
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountCommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountPiecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceJointeWhereInput
  }


  /**
   * Count Type CoefficientCountOutputType
   */

  export type CoefficientCountOutputType = {
    matiere: number
  }

  export type CoefficientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matiere?: boolean | CoefficientCountOutputTypeCountMatiereArgs
  }

  // Custom InputTypes
  /**
   * CoefficientCountOutputType without action
   */
  export type CoefficientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoefficientCountOutputType
     */
    select?: CoefficientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoefficientCountOutputType without action
   */
  export type CoefficientCountOutputTypeCountMatiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    enfants: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enfants?: boolean | ParentCountOutputTypeCountEnfantsArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountEnfantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EleveWhereInput
  }


  /**
   * Count Type EnseignantCountOutputType
   */

  export type EnseignantCountOutputType = {
    enseignant_classe: number
    note_inter: number
    note_devoir: number
    commentaire: number
    piecejointe: number
  }

  export type EnseignantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enseignant_classe?: boolean | EnseignantCountOutputTypeCountEnseignant_classeArgs
    note_inter?: boolean | EnseignantCountOutputTypeCountNote_interArgs
    note_devoir?: boolean | EnseignantCountOutputTypeCountNote_devoirArgs
    commentaire?: boolean | EnseignantCountOutputTypeCountCommentaireArgs
    piecejointe?: boolean | EnseignantCountOutputTypeCountPiecejointeArgs
  }

  // Custom InputTypes
  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnseignantCountOutputType
     */
    select?: EnseignantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeCountEnseignant_classeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Enseignant_ClasseWhereInput
  }

  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeCountNote_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_interWhereInput
  }

  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeCountNote_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_devoirWhereInput
  }

  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeCountCommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }

  /**
   * EnseignantCountOutputType without action
   */
  export type EnseignantCountOutputTypeCountPiecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceJointeWhereInput
  }


  /**
   * Count Type EleveCountOutputType
   */

  export type EleveCountOutputType = {
    note_inter: number
    note_devoir: number
    rang: number
    commentaire: number
  }

  export type EleveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note_inter?: boolean | EleveCountOutputTypeCountNote_interArgs
    note_devoir?: boolean | EleveCountOutputTypeCountNote_devoirArgs
    rang?: boolean | EleveCountOutputTypeCountRangArgs
    commentaire?: boolean | EleveCountOutputTypeCountCommentaireArgs
  }

  // Custom InputTypes
  /**
   * EleveCountOutputType without action
   */
  export type EleveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EleveCountOutputType
     */
    select?: EleveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EleveCountOutputType without action
   */
  export type EleveCountOutputTypeCountNote_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_interWhereInput
  }

  /**
   * EleveCountOutputType without action
   */
  export type EleveCountOutputTypeCountNote_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_devoirWhereInput
  }

  /**
   * EleveCountOutputType without action
   */
  export type EleveCountOutputTypeCountRangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RangWhereInput
  }

  /**
   * EleveCountOutputType without action
   */
  export type EleveCountOutputTypeCountCommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }


  /**
   * Count Type TrimestreCountOutputType
   */

  export type TrimestreCountOutputType = {
    note_inter: number
    note_devoir: number
    rang: number
    commenstaire: number
  }

  export type TrimestreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note_inter?: boolean | TrimestreCountOutputTypeCountNote_interArgs
    note_devoir?: boolean | TrimestreCountOutputTypeCountNote_devoirArgs
    rang?: boolean | TrimestreCountOutputTypeCountRangArgs
    commenstaire?: boolean | TrimestreCountOutputTypeCountCommenstaireArgs
  }

  // Custom InputTypes
  /**
   * TrimestreCountOutputType without action
   */
  export type TrimestreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrimestreCountOutputType
     */
    select?: TrimestreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrimestreCountOutputType without action
   */
  export type TrimestreCountOutputTypeCountNote_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_interWhereInput
  }

  /**
   * TrimestreCountOutputType without action
   */
  export type TrimestreCountOutputTypeCountNote_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_devoirWhereInput
  }

  /**
   * TrimestreCountOutputType without action
   */
  export type TrimestreCountOutputTypeCountRangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RangWhereInput
  }

  /**
   * TrimestreCountOutputType without action
   */
  export type TrimestreCountOutputTypeCountCommenstaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Classe
   */

  export type AggregateClasse = {
    _count: ClasseCountAggregateOutputType | null
    _avg: ClasseAvgAggregateOutputType | null
    _sum: ClasseSumAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  export type ClasseAvgAggregateOutputType = {
    id: number | null
  }

  export type ClasseSumAggregateOutputType = {
    id: number | null
  }

  export type ClasseMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
  }

  export type ClasseMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
  }

  export type ClasseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    _all: number
  }


  export type ClasseAvgAggregateInputType = {
    id?: true
  }

  export type ClasseSumAggregateInputType = {
    id?: true
  }

  export type ClasseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
  }

  export type ClasseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
  }

  export type ClasseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    _all?: true
  }

  export type ClasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classe to aggregate.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClasseMaxAggregateInputType
  }

  export type GetClasseAggregateType<T extends ClasseAggregateArgs> = {
        [P in keyof T & keyof AggregateClasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasse[P]>
      : GetScalarType<T[P], AggregateClasse[P]>
  }




  export type ClasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClasseWhereInput
    orderBy?: ClasseOrderByWithAggregationInput | ClasseOrderByWithAggregationInput[]
    by: ClasseScalarFieldEnum[] | ClasseScalarFieldEnum
    having?: ClasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClasseCountAggregateInputType | true
    _avg?: ClasseAvgAggregateInputType
    _sum?: ClasseSumAggregateInputType
    _min?: ClasseMinAggregateInputType
    _max?: ClasseMaxAggregateInputType
  }

  export type ClasseGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    _count: ClasseCountAggregateOutputType | null
    _avg: ClasseAvgAggregateOutputType | null
    _sum: ClasseSumAggregateOutputType | null
    _min: ClasseMinAggregateOutputType | null
    _max: ClasseMaxAggregateOutputType | null
  }

  type GetClasseGroupByPayload<T extends ClasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClasseGroupByOutputType[P]>
            : GetScalarType<T[P], ClasseGroupByOutputType[P]>
        }
      >
    >


  export type ClasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    eleves?: boolean | Classe$elevesArgs<ExtArgs>
    enseignant_classe?: boolean | Classe$enseignant_classeArgs<ExtArgs>
    piecejointe?: boolean | Classe$piecejointeArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classe"]>


  export type ClasseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
  }

  export type ClasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eleves?: boolean | Classe$elevesArgs<ExtArgs>
    enseignant_classe?: boolean | Classe$enseignant_classeArgs<ExtArgs>
    piecejointe?: boolean | Classe$piecejointeArgs<ExtArgs>
    _count?: boolean | ClasseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classe"
    objects: {
      eleves: Prisma.$ElevePayload<ExtArgs>[]
      enseignant_classe: Prisma.$Enseignant_ClassePayload<ExtArgs>[]
      piecejointe: Prisma.$PieceJointePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
    }, ExtArgs["result"]["classe"]>
    composites: {}
  }

  type ClasseGetPayload<S extends boolean | null | undefined | ClasseDefaultArgs> = $Result.GetResult<Prisma.$ClassePayload, S>

  type ClasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClasseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClasseCountAggregateInputType | true
    }

  export interface ClasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classe'], meta: { name: 'Classe' } }
    /**
     * Find zero or one Classe that matches the filter.
     * @param {ClasseFindUniqueArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClasseFindUniqueArgs>(args: SelectSubset<T, ClasseFindUniqueArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Classe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClasseFindUniqueOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClasseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Classe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClasseFindFirstArgs>(args?: SelectSubset<T, ClasseFindFirstArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Classe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindFirstOrThrowArgs} args - Arguments to find a Classe
     * @example
     * // Get one Classe
     * const classe = await prisma.classe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClasseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classe.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classeWithIdOnly = await prisma.classe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClasseFindManyArgs>(args?: SelectSubset<T, ClasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Classe.
     * @param {ClasseCreateArgs} args - Arguments to create a Classe.
     * @example
     * // Create one Classe
     * const Classe = await prisma.classe.create({
     *   data: {
     *     // ... data to create a Classe
     *   }
     * })
     * 
     */
    create<T extends ClasseCreateArgs>(args: SelectSubset<T, ClasseCreateArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClasseCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classe = await prisma.classe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClasseCreateManyArgs>(args?: SelectSubset<T, ClasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Classe.
     * @param {ClasseDeleteArgs} args - Arguments to delete one Classe.
     * @example
     * // Delete one Classe
     * const Classe = await prisma.classe.delete({
     *   where: {
     *     // ... filter to delete one Classe
     *   }
     * })
     * 
     */
    delete<T extends ClasseDeleteArgs>(args: SelectSubset<T, ClasseDeleteArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Classe.
     * @param {ClasseUpdateArgs} args - Arguments to update one Classe.
     * @example
     * // Update one Classe
     * const classe = await prisma.classe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClasseUpdateArgs>(args: SelectSubset<T, ClasseUpdateArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClasseDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClasseDeleteManyArgs>(args?: SelectSubset<T, ClasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classe = await prisma.classe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClasseUpdateManyArgs>(args: SelectSubset<T, ClasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classe.
     * @param {ClasseUpsertArgs} args - Arguments to update or create a Classe.
     * @example
     * // Update or create a Classe
     * const classe = await prisma.classe.upsert({
     *   create: {
     *     // ... data to create a Classe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classe we want to update
     *   }
     * })
     */
    upsert<T extends ClasseUpsertArgs>(args: SelectSubset<T, ClasseUpsertArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classe.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClasseCountArgs>(
      args?: Subset<T, ClasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClasseAggregateArgs>(args: Subset<T, ClasseAggregateArgs>): Prisma.PrismaPromise<GetClasseAggregateType<T>>

    /**
     * Group by Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClasseGroupByArgs['orderBy'] }
        : { orderBy?: ClasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classe model
   */
  readonly fields: ClasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eleves<T extends Classe$elevesArgs<ExtArgs> = {}>(args?: Subset<T, Classe$elevesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findMany"> | Null>
    enseignant_classe<T extends Classe$enseignant_classeArgs<ExtArgs> = {}>(args?: Subset<T, Classe$enseignant_classeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findMany"> | Null>
    piecejointe<T extends Classe$piecejointeArgs<ExtArgs> = {}>(args?: Subset<T, Classe$piecejointeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classe model
   */ 
  interface ClasseFieldRefs {
    readonly id: FieldRef<"Classe", 'Int'>
    readonly createdAt: FieldRef<"Classe", 'DateTime'>
    readonly updatedAt: FieldRef<"Classe", 'DateTime'>
    readonly nom: FieldRef<"Classe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Classe findUnique
   */
  export type ClasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe findUniqueOrThrow
   */
  export type ClasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe findFirst
   */
  export type ClasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe findFirstOrThrow
   */
  export type ClasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classe to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe findMany
   */
  export type ClasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClasseOrderByWithRelationInput | ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClasseScalarFieldEnum | ClasseScalarFieldEnum[]
  }

  /**
   * Classe create
   */
  export type ClasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Classe.
     */
    data: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
  }

  /**
   * Classe createMany
   */
  export type ClasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClasseCreateManyInput | ClasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classe update
   */
  export type ClasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Classe.
     */
    data: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
    /**
     * Choose, which Classe to update.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe updateMany
   */
  export type ClasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClasseUpdateManyMutationInput, ClasseUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClasseWhereInput
  }

  /**
   * Classe upsert
   */
  export type ClasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Classe to update in case it exists.
     */
    where: ClasseWhereUniqueInput
    /**
     * In case the Classe found by the `where` argument doesn't exist, create a new Classe with this data.
     */
    create: XOR<ClasseCreateInput, ClasseUncheckedCreateInput>
    /**
     * In case the Classe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClasseUpdateInput, ClasseUncheckedUpdateInput>
  }

  /**
   * Classe delete
   */
  export type ClasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
    /**
     * Filter which Classe to delete.
     */
    where: ClasseWhereUniqueInput
  }

  /**
   * Classe deleteMany
   */
  export type ClasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClasseWhereInput
  }

  /**
   * Classe.eleves
   */
  export type Classe$elevesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    where?: EleveWhereInput
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    cursor?: EleveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EleveScalarFieldEnum | EleveScalarFieldEnum[]
  }

  /**
   * Classe.enseignant_classe
   */
  export type Classe$enseignant_classeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    where?: Enseignant_ClasseWhereInput
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    cursor?: Enseignant_ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Classe.piecejointe
   */
  export type Classe$piecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    where?: PieceJointeWhereInput
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    cursor?: PieceJointeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * Classe without action
   */
  export type ClasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classe
     */
    select?: ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClasseInclude<ExtArgs> | null
  }


  /**
   * Model Matiere
   */

  export type AggregateMatiere = {
    _count: MatiereCountAggregateOutputType | null
    _avg: MatiereAvgAggregateOutputType | null
    _sum: MatiereSumAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  export type MatiereAvgAggregateOutputType = {
    id: number | null
    id_coefficient: number | null
  }

  export type MatiereSumAggregateOutputType = {
    id: number | null
    id_coefficient: number | null
  }

  export type MatiereMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matiere: string | null
    id_coefficient: number | null
  }

  export type MatiereMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    matiere: string | null
    id_coefficient: number | null
  }

  export type MatiereCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    matiere: number
    id_coefficient: number
    _all: number
  }


  export type MatiereAvgAggregateInputType = {
    id?: true
    id_coefficient?: true
  }

  export type MatiereSumAggregateInputType = {
    id?: true
    id_coefficient?: true
  }

  export type MatiereMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    matiere?: true
    id_coefficient?: true
  }

  export type MatiereMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    matiere?: true
    id_coefficient?: true
  }

  export type MatiereCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    matiere?: true
    id_coefficient?: true
    _all?: true
  }

  export type MatiereAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matiere to aggregate.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matieres
    **/
    _count?: true | MatiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatiereAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatiereSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatiereMaxAggregateInputType
  }

  export type GetMatiereAggregateType<T extends MatiereAggregateArgs> = {
        [P in keyof T & keyof AggregateMatiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatiere[P]>
      : GetScalarType<T[P], AggregateMatiere[P]>
  }




  export type MatiereGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
    orderBy?: MatiereOrderByWithAggregationInput | MatiereOrderByWithAggregationInput[]
    by: MatiereScalarFieldEnum[] | MatiereScalarFieldEnum
    having?: MatiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatiereCountAggregateInputType | true
    _avg?: MatiereAvgAggregateInputType
    _sum?: MatiereSumAggregateInputType
    _min?: MatiereMinAggregateInputType
    _max?: MatiereMaxAggregateInputType
  }

  export type MatiereGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    matiere: string
    id_coefficient: number
    _count: MatiereCountAggregateOutputType | null
    _avg: MatiereAvgAggregateOutputType | null
    _sum: MatiereSumAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  type GetMatiereGroupByPayload<T extends MatiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatiereGroupByOutputType[P]>
            : GetScalarType<T[P], MatiereGroupByOutputType[P]>
        }
      >
    >


  export type MatiereSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matiere?: boolean
    id_coefficient?: boolean
    note_inter?: boolean | Matiere$note_interArgs<ExtArgs>
    note_devoir?: boolean | Matiere$note_devoirArgs<ExtArgs>
    rang?: boolean | Matiere$rangArgs<ExtArgs>
    coeffient?: boolean | CoefficientDefaultArgs<ExtArgs>
    enseignant_matiere?: boolean | Matiere$enseignant_matiereArgs<ExtArgs>
    commentaire?: boolean | Matiere$commentaireArgs<ExtArgs>
    piecejointe?: boolean | Matiere$piecejointeArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matiere"]>


  export type MatiereSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matiere?: boolean
    id_coefficient?: boolean
  }

  export type MatiereInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note_inter?: boolean | Matiere$note_interArgs<ExtArgs>
    note_devoir?: boolean | Matiere$note_devoirArgs<ExtArgs>
    rang?: boolean | Matiere$rangArgs<ExtArgs>
    coeffient?: boolean | CoefficientDefaultArgs<ExtArgs>
    enseignant_matiere?: boolean | Matiere$enseignant_matiereArgs<ExtArgs>
    commentaire?: boolean | Matiere$commentaireArgs<ExtArgs>
    piecejointe?: boolean | Matiere$piecejointeArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MatierePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matiere"
    objects: {
      note_inter: Prisma.$Note_interPayload<ExtArgs>[]
      note_devoir: Prisma.$Note_devoirPayload<ExtArgs>[]
      rang: Prisma.$RangPayload<ExtArgs>[]
      coeffient: Prisma.$CoefficientPayload<ExtArgs>
      enseignant_matiere: Prisma.$Enseignant_ClassePayload<ExtArgs>[]
      commentaire: Prisma.$CommentairePayload<ExtArgs>[]
      piecejointe: Prisma.$PieceJointePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      matiere: string
      id_coefficient: number
    }, ExtArgs["result"]["matiere"]>
    composites: {}
  }

  type MatiereGetPayload<S extends boolean | null | undefined | MatiereDefaultArgs> = $Result.GetResult<Prisma.$MatierePayload, S>

  type MatiereCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatiereFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatiereCountAggregateInputType | true
    }

  export interface MatiereDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matiere'], meta: { name: 'Matiere' } }
    /**
     * Find zero or one Matiere that matches the filter.
     * @param {MatiereFindUniqueArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatiereFindUniqueArgs>(args: SelectSubset<T, MatiereFindUniqueArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Matiere that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatiereFindUniqueOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatiereFindUniqueOrThrowArgs>(args: SelectSubset<T, MatiereFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Matiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatiereFindFirstArgs>(args?: SelectSubset<T, MatiereFindFirstArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Matiere that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatiereFindFirstOrThrowArgs>(args?: SelectSubset<T, MatiereFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matieres
     * const matieres = await prisma.matiere.findMany()
     * 
     * // Get first 10 Matieres
     * const matieres = await prisma.matiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matiereWithIdOnly = await prisma.matiere.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatiereFindManyArgs>(args?: SelectSubset<T, MatiereFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Matiere.
     * @param {MatiereCreateArgs} args - Arguments to create a Matiere.
     * @example
     * // Create one Matiere
     * const Matiere = await prisma.matiere.create({
     *   data: {
     *     // ... data to create a Matiere
     *   }
     * })
     * 
     */
    create<T extends MatiereCreateArgs>(args: SelectSubset<T, MatiereCreateArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matieres.
     * @param {MatiereCreateManyArgs} args - Arguments to create many Matieres.
     * @example
     * // Create many Matieres
     * const matiere = await prisma.matiere.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatiereCreateManyArgs>(args?: SelectSubset<T, MatiereCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matiere.
     * @param {MatiereDeleteArgs} args - Arguments to delete one Matiere.
     * @example
     * // Delete one Matiere
     * const Matiere = await prisma.matiere.delete({
     *   where: {
     *     // ... filter to delete one Matiere
     *   }
     * })
     * 
     */
    delete<T extends MatiereDeleteArgs>(args: SelectSubset<T, MatiereDeleteArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Matiere.
     * @param {MatiereUpdateArgs} args - Arguments to update one Matiere.
     * @example
     * // Update one Matiere
     * const matiere = await prisma.matiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatiereUpdateArgs>(args: SelectSubset<T, MatiereUpdateArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matieres.
     * @param {MatiereDeleteManyArgs} args - Arguments to filter Matieres to delete.
     * @example
     * // Delete a few Matieres
     * const { count } = await prisma.matiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatiereDeleteManyArgs>(args?: SelectSubset<T, MatiereDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matieres
     * const matiere = await prisma.matiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatiereUpdateManyArgs>(args: SelectSubset<T, MatiereUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matiere.
     * @param {MatiereUpsertArgs} args - Arguments to update or create a Matiere.
     * @example
     * // Update or create a Matiere
     * const matiere = await prisma.matiere.upsert({
     *   create: {
     *     // ... data to create a Matiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matiere we want to update
     *   }
     * })
     */
    upsert<T extends MatiereUpsertArgs>(args: SelectSubset<T, MatiereUpsertArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereCountArgs} args - Arguments to filter Matieres to count.
     * @example
     * // Count the number of Matieres
     * const count = await prisma.matiere.count({
     *   where: {
     *     // ... the filter for the Matieres we want to count
     *   }
     * })
    **/
    count<T extends MatiereCountArgs>(
      args?: Subset<T, MatiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatiereAggregateArgs>(args: Subset<T, MatiereAggregateArgs>): Prisma.PrismaPromise<GetMatiereAggregateType<T>>

    /**
     * Group by Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatiereGroupByArgs['orderBy'] }
        : { orderBy?: MatiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matiere model
   */
  readonly fields: MatiereFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatiereClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note_inter<T extends Matiere$note_interArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$note_interArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findMany"> | Null>
    note_devoir<T extends Matiere$note_devoirArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$note_devoirArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findMany"> | Null>
    rang<T extends Matiere$rangArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$rangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findMany"> | Null>
    coeffient<T extends CoefficientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoefficientDefaultArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enseignant_matiere<T extends Matiere$enseignant_matiereArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$enseignant_matiereArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findMany"> | Null>
    commentaire<T extends Matiere$commentaireArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$commentaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findMany"> | Null>
    piecejointe<T extends Matiere$piecejointeArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$piecejointeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Matiere model
   */ 
  interface MatiereFieldRefs {
    readonly id: FieldRef<"Matiere", 'Int'>
    readonly createdAt: FieldRef<"Matiere", 'DateTime'>
    readonly updatedAt: FieldRef<"Matiere", 'DateTime'>
    readonly matiere: FieldRef<"Matiere", 'String'>
    readonly id_coefficient: FieldRef<"Matiere", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Matiere findUnique
   */
  export type MatiereFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }

  /**
   * Matiere findUniqueOrThrow
   */
  export type MatiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }

  /**
   * Matiere findFirst
   */
  export type MatiereFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }

  /**
   * Matiere findFirstOrThrow
   */
  export type MatiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }

  /**
   * Matiere findMany
   */
  export type MatiereFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matieres to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }

  /**
   * Matiere create
   */
  export type MatiereCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to create a Matiere.
     */
    data: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
  }

  /**
   * Matiere createMany
   */
  export type MatiereCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matieres.
     */
    data: MatiereCreateManyInput | MatiereCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Matiere update
   */
  export type MatiereUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to update a Matiere.
     */
    data: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
    /**
     * Choose, which Matiere to update.
     */
    where: MatiereWhereUniqueInput
  }

  /**
   * Matiere updateMany
   */
  export type MatiereUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matieres.
     */
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyInput>
    /**
     * Filter which Matieres to update
     */
    where?: MatiereWhereInput
  }

  /**
   * Matiere upsert
   */
  export type MatiereUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The filter to search for the Matiere to update in case it exists.
     */
    where: MatiereWhereUniqueInput
    /**
     * In case the Matiere found by the `where` argument doesn't exist, create a new Matiere with this data.
     */
    create: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
    /**
     * In case the Matiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
  }

  /**
   * Matiere delete
   */
  export type MatiereDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter which Matiere to delete.
     */
    where: MatiereWhereUniqueInput
  }

  /**
   * Matiere deleteMany
   */
  export type MatiereDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matieres to delete
     */
    where?: MatiereWhereInput
  }

  /**
   * Matiere.note_inter
   */
  export type Matiere$note_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    where?: Note_interWhereInput
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    cursor?: Note_interWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Matiere.note_devoir
   */
  export type Matiere$note_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    where?: Note_devoirWhereInput
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    cursor?: Note_devoirWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Matiere.rang
   */
  export type Matiere$rangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    where?: RangWhereInput
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    cursor?: RangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Matiere.enseignant_matiere
   */
  export type Matiere$enseignant_matiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    where?: Enseignant_ClasseWhereInput
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    cursor?: Enseignant_ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Matiere.commentaire
   */
  export type Matiere$commentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Matiere.piecejointe
   */
  export type Matiere$piecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    where?: PieceJointeWhereInput
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    cursor?: PieceJointeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * Matiere without action
   */
  export type MatiereDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
  }


  /**
   * Model Rang
   */

  export type AggregateRang = {
    _count: RangCountAggregateOutputType | null
    _avg: RangAvgAggregateOutputType | null
    _sum: RangSumAggregateOutputType | null
    _min: RangMinAggregateOutputType | null
    _max: RangMaxAggregateOutputType | null
  }

  export type RangAvgAggregateOutputType = {
    id: number | null
    rang: number | null
    id_matiere: number | null
    id_eleve: number | null
    id_trimestre: number | null
  }

  export type RangSumAggregateOutputType = {
    id: number | null
    rang: number | null
    id_matiere: number | null
    id_eleve: number | null
    id_trimestre: number | null
  }

  export type RangMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    rang: number | null
    id_matiere: number | null
    id_eleve: number | null
    id_trimestre: number | null
  }

  export type RangMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    rang: number | null
    id_matiere: number | null
    id_eleve: number | null
    id_trimestre: number | null
  }

  export type RangCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    rang: number
    id_matiere: number
    id_eleve: number
    id_trimestre: number
    _all: number
  }


  export type RangAvgAggregateInputType = {
    id?: true
    rang?: true
    id_matiere?: true
    id_eleve?: true
    id_trimestre?: true
  }

  export type RangSumAggregateInputType = {
    id?: true
    rang?: true
    id_matiere?: true
    id_eleve?: true
    id_trimestre?: true
  }

  export type RangMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    rang?: true
    id_matiere?: true
    id_eleve?: true
    id_trimestre?: true
  }

  export type RangMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    rang?: true
    id_matiere?: true
    id_eleve?: true
    id_trimestre?: true
  }

  export type RangCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    rang?: true
    id_matiere?: true
    id_eleve?: true
    id_trimestre?: true
    _all?: true
  }

  export type RangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rang to aggregate.
     */
    where?: RangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rangs to fetch.
     */
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rangs
    **/
    _count?: true | RangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RangMaxAggregateInputType
  }

  export type GetRangAggregateType<T extends RangAggregateArgs> = {
        [P in keyof T & keyof AggregateRang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRang[P]>
      : GetScalarType<T[P], AggregateRang[P]>
  }




  export type RangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RangWhereInput
    orderBy?: RangOrderByWithAggregationInput | RangOrderByWithAggregationInput[]
    by: RangScalarFieldEnum[] | RangScalarFieldEnum
    having?: RangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RangCountAggregateInputType | true
    _avg?: RangAvgAggregateInputType
    _sum?: RangSumAggregateInputType
    _min?: RangMinAggregateInputType
    _max?: RangMaxAggregateInputType
  }

  export type RangGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    rang: number
    id_matiere: number
    id_eleve: number
    id_trimestre: number
    _count: RangCountAggregateOutputType | null
    _avg: RangAvgAggregateOutputType | null
    _sum: RangSumAggregateOutputType | null
    _min: RangMinAggregateOutputType | null
    _max: RangMaxAggregateOutputType | null
  }

  type GetRangGroupByPayload<T extends RangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RangGroupByOutputType[P]>
            : GetScalarType<T[P], RangGroupByOutputType[P]>
        }
      >
    >


  export type RangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rang?: boolean
    id_matiere?: boolean
    id_eleve?: boolean
    id_trimestre?: boolean
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rang"]>


  export type RangSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rang?: boolean
    id_matiere?: boolean
    id_eleve?: boolean
    id_trimestre?: boolean
  }

  export type RangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }

  export type $RangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rang"
    objects: {
      matiere: Prisma.$MatierePayload<ExtArgs>
      eleve: Prisma.$ElevePayload<ExtArgs>
      trimestre: Prisma.$TrimestrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      rang: number
      id_matiere: number
      id_eleve: number
      id_trimestre: number
    }, ExtArgs["result"]["rang"]>
    composites: {}
  }

  type RangGetPayload<S extends boolean | null | undefined | RangDefaultArgs> = $Result.GetResult<Prisma.$RangPayload, S>

  type RangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RangCountAggregateInputType | true
    }

  export interface RangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rang'], meta: { name: 'Rang' } }
    /**
     * Find zero or one Rang that matches the filter.
     * @param {RangFindUniqueArgs} args - Arguments to find a Rang
     * @example
     * // Get one Rang
     * const rang = await prisma.rang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RangFindUniqueArgs>(args: SelectSubset<T, RangFindUniqueArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RangFindUniqueOrThrowArgs} args - Arguments to find a Rang
     * @example
     * // Get one Rang
     * const rang = await prisma.rang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RangFindUniqueOrThrowArgs>(args: SelectSubset<T, RangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangFindFirstArgs} args - Arguments to find a Rang
     * @example
     * // Get one Rang
     * const rang = await prisma.rang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RangFindFirstArgs>(args?: SelectSubset<T, RangFindFirstArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangFindFirstOrThrowArgs} args - Arguments to find a Rang
     * @example
     * // Get one Rang
     * const rang = await prisma.rang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RangFindFirstOrThrowArgs>(args?: SelectSubset<T, RangFindFirstOrThrowArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rangs
     * const rangs = await prisma.rang.findMany()
     * 
     * // Get first 10 Rangs
     * const rangs = await prisma.rang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rangWithIdOnly = await prisma.rang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RangFindManyArgs>(args?: SelectSubset<T, RangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rang.
     * @param {RangCreateArgs} args - Arguments to create a Rang.
     * @example
     * // Create one Rang
     * const Rang = await prisma.rang.create({
     *   data: {
     *     // ... data to create a Rang
     *   }
     * })
     * 
     */
    create<T extends RangCreateArgs>(args: SelectSubset<T, RangCreateArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rangs.
     * @param {RangCreateManyArgs} args - Arguments to create many Rangs.
     * @example
     * // Create many Rangs
     * const rang = await prisma.rang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RangCreateManyArgs>(args?: SelectSubset<T, RangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rang.
     * @param {RangDeleteArgs} args - Arguments to delete one Rang.
     * @example
     * // Delete one Rang
     * const Rang = await prisma.rang.delete({
     *   where: {
     *     // ... filter to delete one Rang
     *   }
     * })
     * 
     */
    delete<T extends RangDeleteArgs>(args: SelectSubset<T, RangDeleteArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rang.
     * @param {RangUpdateArgs} args - Arguments to update one Rang.
     * @example
     * // Update one Rang
     * const rang = await prisma.rang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RangUpdateArgs>(args: SelectSubset<T, RangUpdateArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rangs.
     * @param {RangDeleteManyArgs} args - Arguments to filter Rangs to delete.
     * @example
     * // Delete a few Rangs
     * const { count } = await prisma.rang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RangDeleteManyArgs>(args?: SelectSubset<T, RangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rangs
     * const rang = await prisma.rang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RangUpdateManyArgs>(args: SelectSubset<T, RangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rang.
     * @param {RangUpsertArgs} args - Arguments to update or create a Rang.
     * @example
     * // Update or create a Rang
     * const rang = await prisma.rang.upsert({
     *   create: {
     *     // ... data to create a Rang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rang we want to update
     *   }
     * })
     */
    upsert<T extends RangUpsertArgs>(args: SelectSubset<T, RangUpsertArgs<ExtArgs>>): Prisma__RangClient<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangCountArgs} args - Arguments to filter Rangs to count.
     * @example
     * // Count the number of Rangs
     * const count = await prisma.rang.count({
     *   where: {
     *     // ... the filter for the Rangs we want to count
     *   }
     * })
    **/
    count<T extends RangCountArgs>(
      args?: Subset<T, RangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RangAggregateArgs>(args: Subset<T, RangAggregateArgs>): Prisma.PrismaPromise<GetRangAggregateType<T>>

    /**
     * Group by Rang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RangGroupByArgs['orderBy'] }
        : { orderBy?: RangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rang model
   */
  readonly fields: RangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    eleve<T extends EleveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EleveDefaultArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trimestre<T extends TrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrimestreDefaultArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rang model
   */ 
  interface RangFieldRefs {
    readonly id: FieldRef<"Rang", 'Int'>
    readonly createdAt: FieldRef<"Rang", 'DateTime'>
    readonly updatedAt: FieldRef<"Rang", 'DateTime'>
    readonly rang: FieldRef<"Rang", 'Int'>
    readonly id_matiere: FieldRef<"Rang", 'Int'>
    readonly id_eleve: FieldRef<"Rang", 'Int'>
    readonly id_trimestre: FieldRef<"Rang", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rang findUnique
   */
  export type RangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter, which Rang to fetch.
     */
    where: RangWhereUniqueInput
  }

  /**
   * Rang findUniqueOrThrow
   */
  export type RangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter, which Rang to fetch.
     */
    where: RangWhereUniqueInput
  }

  /**
   * Rang findFirst
   */
  export type RangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter, which Rang to fetch.
     */
    where?: RangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rangs to fetch.
     */
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rangs.
     */
    cursor?: RangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rangs.
     */
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Rang findFirstOrThrow
   */
  export type RangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter, which Rang to fetch.
     */
    where?: RangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rangs to fetch.
     */
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rangs.
     */
    cursor?: RangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rangs.
     */
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Rang findMany
   */
  export type RangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter, which Rangs to fetch.
     */
    where?: RangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rangs to fetch.
     */
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rangs.
     */
    cursor?: RangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rangs.
     */
    skip?: number
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Rang create
   */
  export type RangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * The data needed to create a Rang.
     */
    data: XOR<RangCreateInput, RangUncheckedCreateInput>
  }

  /**
   * Rang createMany
   */
  export type RangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rangs.
     */
    data: RangCreateManyInput | RangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rang update
   */
  export type RangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * The data needed to update a Rang.
     */
    data: XOR<RangUpdateInput, RangUncheckedUpdateInput>
    /**
     * Choose, which Rang to update.
     */
    where: RangWhereUniqueInput
  }

  /**
   * Rang updateMany
   */
  export type RangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rangs.
     */
    data: XOR<RangUpdateManyMutationInput, RangUncheckedUpdateManyInput>
    /**
     * Filter which Rangs to update
     */
    where?: RangWhereInput
  }

  /**
   * Rang upsert
   */
  export type RangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * The filter to search for the Rang to update in case it exists.
     */
    where: RangWhereUniqueInput
    /**
     * In case the Rang found by the `where` argument doesn't exist, create a new Rang with this data.
     */
    create: XOR<RangCreateInput, RangUncheckedCreateInput>
    /**
     * In case the Rang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RangUpdateInput, RangUncheckedUpdateInput>
  }

  /**
   * Rang delete
   */
  export type RangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    /**
     * Filter which Rang to delete.
     */
    where: RangWhereUniqueInput
  }

  /**
   * Rang deleteMany
   */
  export type RangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rangs to delete
     */
    where?: RangWhereInput
  }

  /**
   * Rang without action
   */
  export type RangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
  }


  /**
   * Model Coefficient
   */

  export type AggregateCoefficient = {
    _count: CoefficientCountAggregateOutputType | null
    _avg: CoefficientAvgAggregateOutputType | null
    _sum: CoefficientSumAggregateOutputType | null
    _min: CoefficientMinAggregateOutputType | null
    _max: CoefficientMaxAggregateOutputType | null
  }

  export type CoefficientAvgAggregateOutputType = {
    id: number | null
    coefficient: number | null
  }

  export type CoefficientSumAggregateOutputType = {
    id: number | null
    coefficient: number | null
  }

  export type CoefficientMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    coefficient: number | null
  }

  export type CoefficientMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    coefficient: number | null
  }

  export type CoefficientCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    coefficient: number
    _all: number
  }


  export type CoefficientAvgAggregateInputType = {
    id?: true
    coefficient?: true
  }

  export type CoefficientSumAggregateInputType = {
    id?: true
    coefficient?: true
  }

  export type CoefficientMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    coefficient?: true
  }

  export type CoefficientMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    coefficient?: true
  }

  export type CoefficientCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    coefficient?: true
    _all?: true
  }

  export type CoefficientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coefficient to aggregate.
     */
    where?: CoefficientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coefficients to fetch.
     */
    orderBy?: CoefficientOrderByWithRelationInput | CoefficientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoefficientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coefficients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coefficients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coefficients
    **/
    _count?: true | CoefficientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoefficientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoefficientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoefficientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoefficientMaxAggregateInputType
  }

  export type GetCoefficientAggregateType<T extends CoefficientAggregateArgs> = {
        [P in keyof T & keyof AggregateCoefficient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoefficient[P]>
      : GetScalarType<T[P], AggregateCoefficient[P]>
  }




  export type CoefficientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoefficientWhereInput
    orderBy?: CoefficientOrderByWithAggregationInput | CoefficientOrderByWithAggregationInput[]
    by: CoefficientScalarFieldEnum[] | CoefficientScalarFieldEnum
    having?: CoefficientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoefficientCountAggregateInputType | true
    _avg?: CoefficientAvgAggregateInputType
    _sum?: CoefficientSumAggregateInputType
    _min?: CoefficientMinAggregateInputType
    _max?: CoefficientMaxAggregateInputType
  }

  export type CoefficientGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    coefficient: number
    _count: CoefficientCountAggregateOutputType | null
    _avg: CoefficientAvgAggregateOutputType | null
    _sum: CoefficientSumAggregateOutputType | null
    _min: CoefficientMinAggregateOutputType | null
    _max: CoefficientMaxAggregateOutputType | null
  }

  type GetCoefficientGroupByPayload<T extends CoefficientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoefficientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoefficientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoefficientGroupByOutputType[P]>
            : GetScalarType<T[P], CoefficientGroupByOutputType[P]>
        }
      >
    >


  export type CoefficientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coefficient?: boolean
    matiere?: boolean | Coefficient$matiereArgs<ExtArgs>
    _count?: boolean | CoefficientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coefficient"]>


  export type CoefficientSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coefficient?: boolean
  }

  export type CoefficientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matiere?: boolean | Coefficient$matiereArgs<ExtArgs>
    _count?: boolean | CoefficientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoefficientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coefficient"
    objects: {
      matiere: Prisma.$MatierePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      coefficient: number
    }, ExtArgs["result"]["coefficient"]>
    composites: {}
  }

  type CoefficientGetPayload<S extends boolean | null | undefined | CoefficientDefaultArgs> = $Result.GetResult<Prisma.$CoefficientPayload, S>

  type CoefficientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoefficientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoefficientCountAggregateInputType | true
    }

  export interface CoefficientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coefficient'], meta: { name: 'Coefficient' } }
    /**
     * Find zero or one Coefficient that matches the filter.
     * @param {CoefficientFindUniqueArgs} args - Arguments to find a Coefficient
     * @example
     * // Get one Coefficient
     * const coefficient = await prisma.coefficient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoefficientFindUniqueArgs>(args: SelectSubset<T, CoefficientFindUniqueArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coefficient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoefficientFindUniqueOrThrowArgs} args - Arguments to find a Coefficient
     * @example
     * // Get one Coefficient
     * const coefficient = await prisma.coefficient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoefficientFindUniqueOrThrowArgs>(args: SelectSubset<T, CoefficientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coefficient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientFindFirstArgs} args - Arguments to find a Coefficient
     * @example
     * // Get one Coefficient
     * const coefficient = await prisma.coefficient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoefficientFindFirstArgs>(args?: SelectSubset<T, CoefficientFindFirstArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coefficient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientFindFirstOrThrowArgs} args - Arguments to find a Coefficient
     * @example
     * // Get one Coefficient
     * const coefficient = await prisma.coefficient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoefficientFindFirstOrThrowArgs>(args?: SelectSubset<T, CoefficientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coefficients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coefficients
     * const coefficients = await prisma.coefficient.findMany()
     * 
     * // Get first 10 Coefficients
     * const coefficients = await prisma.coefficient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coefficientWithIdOnly = await prisma.coefficient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoefficientFindManyArgs>(args?: SelectSubset<T, CoefficientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coefficient.
     * @param {CoefficientCreateArgs} args - Arguments to create a Coefficient.
     * @example
     * // Create one Coefficient
     * const Coefficient = await prisma.coefficient.create({
     *   data: {
     *     // ... data to create a Coefficient
     *   }
     * })
     * 
     */
    create<T extends CoefficientCreateArgs>(args: SelectSubset<T, CoefficientCreateArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coefficients.
     * @param {CoefficientCreateManyArgs} args - Arguments to create many Coefficients.
     * @example
     * // Create many Coefficients
     * const coefficient = await prisma.coefficient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoefficientCreateManyArgs>(args?: SelectSubset<T, CoefficientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coefficient.
     * @param {CoefficientDeleteArgs} args - Arguments to delete one Coefficient.
     * @example
     * // Delete one Coefficient
     * const Coefficient = await prisma.coefficient.delete({
     *   where: {
     *     // ... filter to delete one Coefficient
     *   }
     * })
     * 
     */
    delete<T extends CoefficientDeleteArgs>(args: SelectSubset<T, CoefficientDeleteArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coefficient.
     * @param {CoefficientUpdateArgs} args - Arguments to update one Coefficient.
     * @example
     * // Update one Coefficient
     * const coefficient = await prisma.coefficient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoefficientUpdateArgs>(args: SelectSubset<T, CoefficientUpdateArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coefficients.
     * @param {CoefficientDeleteManyArgs} args - Arguments to filter Coefficients to delete.
     * @example
     * // Delete a few Coefficients
     * const { count } = await prisma.coefficient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoefficientDeleteManyArgs>(args?: SelectSubset<T, CoefficientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coefficients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coefficients
     * const coefficient = await prisma.coefficient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoefficientUpdateManyArgs>(args: SelectSubset<T, CoefficientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coefficient.
     * @param {CoefficientUpsertArgs} args - Arguments to update or create a Coefficient.
     * @example
     * // Update or create a Coefficient
     * const coefficient = await prisma.coefficient.upsert({
     *   create: {
     *     // ... data to create a Coefficient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coefficient we want to update
     *   }
     * })
     */
    upsert<T extends CoefficientUpsertArgs>(args: SelectSubset<T, CoefficientUpsertArgs<ExtArgs>>): Prisma__CoefficientClient<$Result.GetResult<Prisma.$CoefficientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coefficients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientCountArgs} args - Arguments to filter Coefficients to count.
     * @example
     * // Count the number of Coefficients
     * const count = await prisma.coefficient.count({
     *   where: {
     *     // ... the filter for the Coefficients we want to count
     *   }
     * })
    **/
    count<T extends CoefficientCountArgs>(
      args?: Subset<T, CoefficientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoefficientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coefficient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoefficientAggregateArgs>(args: Subset<T, CoefficientAggregateArgs>): Prisma.PrismaPromise<GetCoefficientAggregateType<T>>

    /**
     * Group by Coefficient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoefficientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoefficientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoefficientGroupByArgs['orderBy'] }
        : { orderBy?: CoefficientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoefficientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoefficientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coefficient model
   */
  readonly fields: CoefficientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coefficient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoefficientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    matiere<T extends Coefficient$matiereArgs<ExtArgs> = {}>(args?: Subset<T, Coefficient$matiereArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coefficient model
   */ 
  interface CoefficientFieldRefs {
    readonly id: FieldRef<"Coefficient", 'Int'>
    readonly createdAt: FieldRef<"Coefficient", 'DateTime'>
    readonly updatedAt: FieldRef<"Coefficient", 'DateTime'>
    readonly coefficient: FieldRef<"Coefficient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Coefficient findUnique
   */
  export type CoefficientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter, which Coefficient to fetch.
     */
    where: CoefficientWhereUniqueInput
  }

  /**
   * Coefficient findUniqueOrThrow
   */
  export type CoefficientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter, which Coefficient to fetch.
     */
    where: CoefficientWhereUniqueInput
  }

  /**
   * Coefficient findFirst
   */
  export type CoefficientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter, which Coefficient to fetch.
     */
    where?: CoefficientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coefficients to fetch.
     */
    orderBy?: CoefficientOrderByWithRelationInput | CoefficientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coefficients.
     */
    cursor?: CoefficientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coefficients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coefficients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coefficients.
     */
    distinct?: CoefficientScalarFieldEnum | CoefficientScalarFieldEnum[]
  }

  /**
   * Coefficient findFirstOrThrow
   */
  export type CoefficientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter, which Coefficient to fetch.
     */
    where?: CoefficientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coefficients to fetch.
     */
    orderBy?: CoefficientOrderByWithRelationInput | CoefficientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coefficients.
     */
    cursor?: CoefficientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coefficients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coefficients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coefficients.
     */
    distinct?: CoefficientScalarFieldEnum | CoefficientScalarFieldEnum[]
  }

  /**
   * Coefficient findMany
   */
  export type CoefficientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter, which Coefficients to fetch.
     */
    where?: CoefficientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coefficients to fetch.
     */
    orderBy?: CoefficientOrderByWithRelationInput | CoefficientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coefficients.
     */
    cursor?: CoefficientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coefficients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coefficients.
     */
    skip?: number
    distinct?: CoefficientScalarFieldEnum | CoefficientScalarFieldEnum[]
  }

  /**
   * Coefficient create
   */
  export type CoefficientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * The data needed to create a Coefficient.
     */
    data: XOR<CoefficientCreateInput, CoefficientUncheckedCreateInput>
  }

  /**
   * Coefficient createMany
   */
  export type CoefficientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coefficients.
     */
    data: CoefficientCreateManyInput | CoefficientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coefficient update
   */
  export type CoefficientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * The data needed to update a Coefficient.
     */
    data: XOR<CoefficientUpdateInput, CoefficientUncheckedUpdateInput>
    /**
     * Choose, which Coefficient to update.
     */
    where: CoefficientWhereUniqueInput
  }

  /**
   * Coefficient updateMany
   */
  export type CoefficientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coefficients.
     */
    data: XOR<CoefficientUpdateManyMutationInput, CoefficientUncheckedUpdateManyInput>
    /**
     * Filter which Coefficients to update
     */
    where?: CoefficientWhereInput
  }

  /**
   * Coefficient upsert
   */
  export type CoefficientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * The filter to search for the Coefficient to update in case it exists.
     */
    where: CoefficientWhereUniqueInput
    /**
     * In case the Coefficient found by the `where` argument doesn't exist, create a new Coefficient with this data.
     */
    create: XOR<CoefficientCreateInput, CoefficientUncheckedCreateInput>
    /**
     * In case the Coefficient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoefficientUpdateInput, CoefficientUncheckedUpdateInput>
  }

  /**
   * Coefficient delete
   */
  export type CoefficientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
    /**
     * Filter which Coefficient to delete.
     */
    where: CoefficientWhereUniqueInput
  }

  /**
   * Coefficient deleteMany
   */
  export type CoefficientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coefficients to delete
     */
    where?: CoefficientWhereInput
  }

  /**
   * Coefficient.matiere
   */
  export type Coefficient$matiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatiereInclude<ExtArgs> | null
    where?: MatiereWhereInput
    orderBy?: MatiereOrderByWithRelationInput | MatiereOrderByWithRelationInput[]
    cursor?: MatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatiereScalarFieldEnum | MatiereScalarFieldEnum[]
  }

  /**
   * Coefficient without action
   */
  export type CoefficientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coefficient
     */
    select?: CoefficientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoefficientInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentAvgAggregateOutputType = {
    id: number | null
  }

  export type ParentSumAggregateOutputType = {
    id: number | null
  }

  export type ParentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    contact: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type ParentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    contact: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    prenom: number
    contact: number
    email: number
    photo: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type ParentAvgAggregateInputType = {
    id?: true
  }

  export type ParentSumAggregateInputType = {
    id?: true
  }

  export type ParentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _avg?: ParentAvgAggregateInputType
    _sum?: ParentSumAggregateInputType
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    prenom: string
    contact: string
    email: string | null
    photo: Buffer | null
    username: string
    password: string
    role: string
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    enfants?: boolean | Parent$enfantsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>


  export type ParentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }

  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enfants?: boolean | Parent$enfantsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      enfants: Prisma.$ElevePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      prenom: string
      contact: string
      email: string | null
      photo: Buffer | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enfants<T extends Parent$enfantsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$enfantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */ 
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'Int'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
    readonly nom: FieldRef<"Parent", 'String'>
    readonly prenom: FieldRef<"Parent", 'String'>
    readonly contact: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly photo: FieldRef<"Parent", 'Bytes'>
    readonly username: FieldRef<"Parent", 'String'>
    readonly password: FieldRef<"Parent", 'String'>
    readonly role: FieldRef<"Parent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
  }

  /**
   * Parent.enfants
   */
  export type Parent$enfantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    where?: EleveWhereInput
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    cursor?: EleveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EleveScalarFieldEnum | EleveScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model Enseignant
   */

  export type AggregateEnseignant = {
    _count: EnseignantCountAggregateOutputType | null
    _avg: EnseignantAvgAggregateOutputType | null
    _sum: EnseignantSumAggregateOutputType | null
    _min: EnseignantMinAggregateOutputType | null
    _max: EnseignantMaxAggregateOutputType | null
  }

  export type EnseignantAvgAggregateOutputType = {
    id: number | null
  }

  export type EnseignantSumAggregateOutputType = {
    id: number | null
  }

  export type EnseignantMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    contact: string | null
    sexe: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type EnseignantMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    contact: string | null
    sexe: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type EnseignantCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    prenom: number
    contact: number
    sexe: number
    email: number
    photo: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type EnseignantAvgAggregateInputType = {
    id?: true
  }

  export type EnseignantSumAggregateInputType = {
    id?: true
  }

  export type EnseignantMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    sexe?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type EnseignantMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    sexe?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type EnseignantCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    contact?: true
    sexe?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type EnseignantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseignant to aggregate.
     */
    where?: EnseignantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignants to fetch.
     */
    orderBy?: EnseignantOrderByWithRelationInput | EnseignantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnseignantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enseignants
    **/
    _count?: true | EnseignantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnseignantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnseignantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnseignantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnseignantMaxAggregateInputType
  }

  export type GetEnseignantAggregateType<T extends EnseignantAggregateArgs> = {
        [P in keyof T & keyof AggregateEnseignant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnseignant[P]>
      : GetScalarType<T[P], AggregateEnseignant[P]>
  }




  export type EnseignantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnseignantWhereInput
    orderBy?: EnseignantOrderByWithAggregationInput | EnseignantOrderByWithAggregationInput[]
    by: EnseignantScalarFieldEnum[] | EnseignantScalarFieldEnum
    having?: EnseignantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnseignantCountAggregateInputType | true
    _avg?: EnseignantAvgAggregateInputType
    _sum?: EnseignantSumAggregateInputType
    _min?: EnseignantMinAggregateInputType
    _max?: EnseignantMaxAggregateInputType
  }

  export type EnseignantGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    prenom: string
    contact: string
    sexe: string
    email: string | null
    photo: Buffer | null
    username: string
    password: string
    role: string
    _count: EnseignantCountAggregateOutputType | null
    _avg: EnseignantAvgAggregateOutputType | null
    _sum: EnseignantSumAggregateOutputType | null
    _min: EnseignantMinAggregateOutputType | null
    _max: EnseignantMaxAggregateOutputType | null
  }

  type GetEnseignantGroupByPayload<T extends EnseignantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnseignantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnseignantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnseignantGroupByOutputType[P]>
            : GetScalarType<T[P], EnseignantGroupByOutputType[P]>
        }
      >
    >


  export type EnseignantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    sexe?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    enseignant_classe?: boolean | Enseignant$enseignant_classeArgs<ExtArgs>
    note_inter?: boolean | Enseignant$note_interArgs<ExtArgs>
    note_devoir?: boolean | Enseignant$note_devoirArgs<ExtArgs>
    commentaire?: boolean | Enseignant$commentaireArgs<ExtArgs>
    piecejointe?: boolean | Enseignant$piecejointeArgs<ExtArgs>
    _count?: boolean | EnseignantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enseignant"]>


  export type EnseignantSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    contact?: boolean
    sexe?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }

  export type EnseignantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enseignant_classe?: boolean | Enseignant$enseignant_classeArgs<ExtArgs>
    note_inter?: boolean | Enseignant$note_interArgs<ExtArgs>
    note_devoir?: boolean | Enseignant$note_devoirArgs<ExtArgs>
    commentaire?: boolean | Enseignant$commentaireArgs<ExtArgs>
    piecejointe?: boolean | Enseignant$piecejointeArgs<ExtArgs>
    _count?: boolean | EnseignantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EnseignantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enseignant"
    objects: {
      enseignant_classe: Prisma.$Enseignant_ClassePayload<ExtArgs>[]
      note_inter: Prisma.$Note_interPayload<ExtArgs>[]
      note_devoir: Prisma.$Note_devoirPayload<ExtArgs>[]
      commentaire: Prisma.$CommentairePayload<ExtArgs>[]
      piecejointe: Prisma.$PieceJointePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      prenom: string
      contact: string
      sexe: string
      email: string | null
      photo: Buffer | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["enseignant"]>
    composites: {}
  }

  type EnseignantGetPayload<S extends boolean | null | undefined | EnseignantDefaultArgs> = $Result.GetResult<Prisma.$EnseignantPayload, S>

  type EnseignantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnseignantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnseignantCountAggregateInputType | true
    }

  export interface EnseignantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enseignant'], meta: { name: 'Enseignant' } }
    /**
     * Find zero or one Enseignant that matches the filter.
     * @param {EnseignantFindUniqueArgs} args - Arguments to find a Enseignant
     * @example
     * // Get one Enseignant
     * const enseignant = await prisma.enseignant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnseignantFindUniqueArgs>(args: SelectSubset<T, EnseignantFindUniqueArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enseignant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnseignantFindUniqueOrThrowArgs} args - Arguments to find a Enseignant
     * @example
     * // Get one Enseignant
     * const enseignant = await prisma.enseignant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnseignantFindUniqueOrThrowArgs>(args: SelectSubset<T, EnseignantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enseignant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantFindFirstArgs} args - Arguments to find a Enseignant
     * @example
     * // Get one Enseignant
     * const enseignant = await prisma.enseignant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnseignantFindFirstArgs>(args?: SelectSubset<T, EnseignantFindFirstArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enseignant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantFindFirstOrThrowArgs} args - Arguments to find a Enseignant
     * @example
     * // Get one Enseignant
     * const enseignant = await prisma.enseignant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnseignantFindFirstOrThrowArgs>(args?: SelectSubset<T, EnseignantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enseignants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enseignants
     * const enseignants = await prisma.enseignant.findMany()
     * 
     * // Get first 10 Enseignants
     * const enseignants = await prisma.enseignant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enseignantWithIdOnly = await prisma.enseignant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnseignantFindManyArgs>(args?: SelectSubset<T, EnseignantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enseignant.
     * @param {EnseignantCreateArgs} args - Arguments to create a Enseignant.
     * @example
     * // Create one Enseignant
     * const Enseignant = await prisma.enseignant.create({
     *   data: {
     *     // ... data to create a Enseignant
     *   }
     * })
     * 
     */
    create<T extends EnseignantCreateArgs>(args: SelectSubset<T, EnseignantCreateArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enseignants.
     * @param {EnseignantCreateManyArgs} args - Arguments to create many Enseignants.
     * @example
     * // Create many Enseignants
     * const enseignant = await prisma.enseignant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnseignantCreateManyArgs>(args?: SelectSubset<T, EnseignantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enseignant.
     * @param {EnseignantDeleteArgs} args - Arguments to delete one Enseignant.
     * @example
     * // Delete one Enseignant
     * const Enseignant = await prisma.enseignant.delete({
     *   where: {
     *     // ... filter to delete one Enseignant
     *   }
     * })
     * 
     */
    delete<T extends EnseignantDeleteArgs>(args: SelectSubset<T, EnseignantDeleteArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enseignant.
     * @param {EnseignantUpdateArgs} args - Arguments to update one Enseignant.
     * @example
     * // Update one Enseignant
     * const enseignant = await prisma.enseignant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnseignantUpdateArgs>(args: SelectSubset<T, EnseignantUpdateArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enseignants.
     * @param {EnseignantDeleteManyArgs} args - Arguments to filter Enseignants to delete.
     * @example
     * // Delete a few Enseignants
     * const { count } = await prisma.enseignant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnseignantDeleteManyArgs>(args?: SelectSubset<T, EnseignantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enseignants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enseignants
     * const enseignant = await prisma.enseignant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnseignantUpdateManyArgs>(args: SelectSubset<T, EnseignantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enseignant.
     * @param {EnseignantUpsertArgs} args - Arguments to update or create a Enseignant.
     * @example
     * // Update or create a Enseignant
     * const enseignant = await prisma.enseignant.upsert({
     *   create: {
     *     // ... data to create a Enseignant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enseignant we want to update
     *   }
     * })
     */
    upsert<T extends EnseignantUpsertArgs>(args: SelectSubset<T, EnseignantUpsertArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enseignants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantCountArgs} args - Arguments to filter Enseignants to count.
     * @example
     * // Count the number of Enseignants
     * const count = await prisma.enseignant.count({
     *   where: {
     *     // ... the filter for the Enseignants we want to count
     *   }
     * })
    **/
    count<T extends EnseignantCountArgs>(
      args?: Subset<T, EnseignantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnseignantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enseignant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnseignantAggregateArgs>(args: Subset<T, EnseignantAggregateArgs>): Prisma.PrismaPromise<GetEnseignantAggregateType<T>>

    /**
     * Group by Enseignant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnseignantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnseignantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnseignantGroupByArgs['orderBy'] }
        : { orderBy?: EnseignantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnseignantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnseignantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enseignant model
   */
  readonly fields: EnseignantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enseignant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnseignantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enseignant_classe<T extends Enseignant$enseignant_classeArgs<ExtArgs> = {}>(args?: Subset<T, Enseignant$enseignant_classeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findMany"> | Null>
    note_inter<T extends Enseignant$note_interArgs<ExtArgs> = {}>(args?: Subset<T, Enseignant$note_interArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findMany"> | Null>
    note_devoir<T extends Enseignant$note_devoirArgs<ExtArgs> = {}>(args?: Subset<T, Enseignant$note_devoirArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findMany"> | Null>
    commentaire<T extends Enseignant$commentaireArgs<ExtArgs> = {}>(args?: Subset<T, Enseignant$commentaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findMany"> | Null>
    piecejointe<T extends Enseignant$piecejointeArgs<ExtArgs> = {}>(args?: Subset<T, Enseignant$piecejointeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enseignant model
   */ 
  interface EnseignantFieldRefs {
    readonly id: FieldRef<"Enseignant", 'Int'>
    readonly createdAt: FieldRef<"Enseignant", 'DateTime'>
    readonly updatedAt: FieldRef<"Enseignant", 'DateTime'>
    readonly nom: FieldRef<"Enseignant", 'String'>
    readonly prenom: FieldRef<"Enseignant", 'String'>
    readonly contact: FieldRef<"Enseignant", 'String'>
    readonly sexe: FieldRef<"Enseignant", 'String'>
    readonly email: FieldRef<"Enseignant", 'String'>
    readonly photo: FieldRef<"Enseignant", 'Bytes'>
    readonly username: FieldRef<"Enseignant", 'String'>
    readonly password: FieldRef<"Enseignant", 'String'>
    readonly role: FieldRef<"Enseignant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enseignant findUnique
   */
  export type EnseignantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant to fetch.
     */
    where: EnseignantWhereUniqueInput
  }

  /**
   * Enseignant findUniqueOrThrow
   */
  export type EnseignantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant to fetch.
     */
    where: EnseignantWhereUniqueInput
  }

  /**
   * Enseignant findFirst
   */
  export type EnseignantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant to fetch.
     */
    where?: EnseignantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignants to fetch.
     */
    orderBy?: EnseignantOrderByWithRelationInput | EnseignantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseignants.
     */
    cursor?: EnseignantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseignants.
     */
    distinct?: EnseignantScalarFieldEnum | EnseignantScalarFieldEnum[]
  }

  /**
   * Enseignant findFirstOrThrow
   */
  export type EnseignantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant to fetch.
     */
    where?: EnseignantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignants to fetch.
     */
    orderBy?: EnseignantOrderByWithRelationInput | EnseignantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseignants.
     */
    cursor?: EnseignantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseignants.
     */
    distinct?: EnseignantScalarFieldEnum | EnseignantScalarFieldEnum[]
  }

  /**
   * Enseignant findMany
   */
  export type EnseignantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter, which Enseignants to fetch.
     */
    where?: EnseignantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignants to fetch.
     */
    orderBy?: EnseignantOrderByWithRelationInput | EnseignantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enseignants.
     */
    cursor?: EnseignantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignants.
     */
    skip?: number
    distinct?: EnseignantScalarFieldEnum | EnseignantScalarFieldEnum[]
  }

  /**
   * Enseignant create
   */
  export type EnseignantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * The data needed to create a Enseignant.
     */
    data: XOR<EnseignantCreateInput, EnseignantUncheckedCreateInput>
  }

  /**
   * Enseignant createMany
   */
  export type EnseignantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enseignants.
     */
    data: EnseignantCreateManyInput | EnseignantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enseignant update
   */
  export type EnseignantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * The data needed to update a Enseignant.
     */
    data: XOR<EnseignantUpdateInput, EnseignantUncheckedUpdateInput>
    /**
     * Choose, which Enseignant to update.
     */
    where: EnseignantWhereUniqueInput
  }

  /**
   * Enseignant updateMany
   */
  export type EnseignantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enseignants.
     */
    data: XOR<EnseignantUpdateManyMutationInput, EnseignantUncheckedUpdateManyInput>
    /**
     * Filter which Enseignants to update
     */
    where?: EnseignantWhereInput
  }

  /**
   * Enseignant upsert
   */
  export type EnseignantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * The filter to search for the Enseignant to update in case it exists.
     */
    where: EnseignantWhereUniqueInput
    /**
     * In case the Enseignant found by the `where` argument doesn't exist, create a new Enseignant with this data.
     */
    create: XOR<EnseignantCreateInput, EnseignantUncheckedCreateInput>
    /**
     * In case the Enseignant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnseignantUpdateInput, EnseignantUncheckedUpdateInput>
  }

  /**
   * Enseignant delete
   */
  export type EnseignantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
    /**
     * Filter which Enseignant to delete.
     */
    where: EnseignantWhereUniqueInput
  }

  /**
   * Enseignant deleteMany
   */
  export type EnseignantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseignants to delete
     */
    where?: EnseignantWhereInput
  }

  /**
   * Enseignant.enseignant_classe
   */
  export type Enseignant$enseignant_classeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    where?: Enseignant_ClasseWhereInput
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    cursor?: Enseignant_ClasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Enseignant.note_inter
   */
  export type Enseignant$note_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    where?: Note_interWhereInput
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    cursor?: Note_interWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Enseignant.note_devoir
   */
  export type Enseignant$note_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    where?: Note_devoirWhereInput
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    cursor?: Note_devoirWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Enseignant.commentaire
   */
  export type Enseignant$commentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Enseignant.piecejointe
   */
  export type Enseignant$piecejointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    where?: PieceJointeWhereInput
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    cursor?: PieceJointeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * Enseignant without action
   */
  export type EnseignantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant
     */
    select?: EnseignantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnseignantInclude<ExtArgs> | null
  }


  /**
   * Model Eleve
   */

  export type AggregateEleve = {
    _count: EleveCountAggregateOutputType | null
    _avg: EleveAvgAggregateOutputType | null
    _sum: EleveSumAggregateOutputType | null
    _min: EleveMinAggregateOutputType | null
    _max: EleveMaxAggregateOutputType | null
  }

  export type EleveAvgAggregateOutputType = {
    id: number | null
    id_classe: number | null
    id_parent: number | null
  }

  export type EleveSumAggregateOutputType = {
    id: number | null
    id_classe: number | null
    id_parent: number | null
  }

  export type EleveMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    sexe: string | null
    id_classe: number | null
    id_parent: number | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type EleveMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    sexe: string | null
    id_classe: number | null
    id_parent: number | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type EleveCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    prenom: number
    email: number
    photo: number
    sexe: number
    id_classe: number
    id_parent: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type EleveAvgAggregateInputType = {
    id?: true
    id_classe?: true
    id_parent?: true
  }

  export type EleveSumAggregateInputType = {
    id?: true
    id_classe?: true
    id_parent?: true
  }

  export type EleveMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    sexe?: true
    id_classe?: true
    id_parent?: true
    username?: true
    password?: true
    role?: true
  }

  export type EleveMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    sexe?: true
    id_classe?: true
    id_parent?: true
    username?: true
    password?: true
    role?: true
  }

  export type EleveCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    sexe?: true
    id_classe?: true
    id_parent?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type EleveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eleve to aggregate.
     */
    where?: EleveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eleves to fetch.
     */
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EleveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eleves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eleves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eleves
    **/
    _count?: true | EleveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EleveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EleveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EleveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EleveMaxAggregateInputType
  }

  export type GetEleveAggregateType<T extends EleveAggregateArgs> = {
        [P in keyof T & keyof AggregateEleve]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEleve[P]>
      : GetScalarType<T[P], AggregateEleve[P]>
  }




  export type EleveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EleveWhereInput
    orderBy?: EleveOrderByWithAggregationInput | EleveOrderByWithAggregationInput[]
    by: EleveScalarFieldEnum[] | EleveScalarFieldEnum
    having?: EleveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EleveCountAggregateInputType | true
    _avg?: EleveAvgAggregateInputType
    _sum?: EleveSumAggregateInputType
    _min?: EleveMinAggregateInputType
    _max?: EleveMaxAggregateInputType
  }

  export type EleveGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    prenom: string
    email: string | null
    photo: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role: string
    _count: EleveCountAggregateOutputType | null
    _avg: EleveAvgAggregateOutputType | null
    _sum: EleveSumAggregateOutputType | null
    _min: EleveMinAggregateOutputType | null
    _max: EleveMaxAggregateOutputType | null
  }

  type GetEleveGroupByPayload<T extends EleveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EleveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EleveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EleveGroupByOutputType[P]>
            : GetScalarType<T[P], EleveGroupByOutputType[P]>
        }
      >
    >


  export type EleveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    sexe?: boolean
    id_classe?: boolean
    id_parent?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    note_inter?: boolean | Eleve$note_interArgs<ExtArgs>
    note_devoir?: boolean | Eleve$note_devoirArgs<ExtArgs>
    rang?: boolean | Eleve$rangArgs<ExtArgs>
    commentaire?: boolean | Eleve$commentaireArgs<ExtArgs>
    _count?: boolean | EleveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eleve"]>


  export type EleveSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    sexe?: boolean
    id_classe?: boolean
    id_parent?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }

  export type EleveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    note_inter?: boolean | Eleve$note_interArgs<ExtArgs>
    note_devoir?: boolean | Eleve$note_devoirArgs<ExtArgs>
    rang?: boolean | Eleve$rangArgs<ExtArgs>
    commentaire?: boolean | Eleve$commentaireArgs<ExtArgs>
    _count?: boolean | EleveCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ElevePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Eleve"
    objects: {
      classe: Prisma.$ClassePayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
      note_inter: Prisma.$Note_interPayload<ExtArgs>[]
      note_devoir: Prisma.$Note_devoirPayload<ExtArgs>[]
      rang: Prisma.$RangPayload<ExtArgs>[]
      commentaire: Prisma.$CommentairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      prenom: string
      email: string | null
      photo: Buffer | null
      sexe: string
      id_classe: number
      id_parent: number
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["eleve"]>
    composites: {}
  }

  type EleveGetPayload<S extends boolean | null | undefined | EleveDefaultArgs> = $Result.GetResult<Prisma.$ElevePayload, S>

  type EleveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EleveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EleveCountAggregateInputType | true
    }

  export interface EleveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Eleve'], meta: { name: 'Eleve' } }
    /**
     * Find zero or one Eleve that matches the filter.
     * @param {EleveFindUniqueArgs} args - Arguments to find a Eleve
     * @example
     * // Get one Eleve
     * const eleve = await prisma.eleve.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EleveFindUniqueArgs>(args: SelectSubset<T, EleveFindUniqueArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eleve that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EleveFindUniqueOrThrowArgs} args - Arguments to find a Eleve
     * @example
     * // Get one Eleve
     * const eleve = await prisma.eleve.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EleveFindUniqueOrThrowArgs>(args: SelectSubset<T, EleveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eleve that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveFindFirstArgs} args - Arguments to find a Eleve
     * @example
     * // Get one Eleve
     * const eleve = await prisma.eleve.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EleveFindFirstArgs>(args?: SelectSubset<T, EleveFindFirstArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eleve that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveFindFirstOrThrowArgs} args - Arguments to find a Eleve
     * @example
     * // Get one Eleve
     * const eleve = await prisma.eleve.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EleveFindFirstOrThrowArgs>(args?: SelectSubset<T, EleveFindFirstOrThrowArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eleves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eleves
     * const eleves = await prisma.eleve.findMany()
     * 
     * // Get first 10 Eleves
     * const eleves = await prisma.eleve.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eleveWithIdOnly = await prisma.eleve.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EleveFindManyArgs>(args?: SelectSubset<T, EleveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eleve.
     * @param {EleveCreateArgs} args - Arguments to create a Eleve.
     * @example
     * // Create one Eleve
     * const Eleve = await prisma.eleve.create({
     *   data: {
     *     // ... data to create a Eleve
     *   }
     * })
     * 
     */
    create<T extends EleveCreateArgs>(args: SelectSubset<T, EleveCreateArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eleves.
     * @param {EleveCreateManyArgs} args - Arguments to create many Eleves.
     * @example
     * // Create many Eleves
     * const eleve = await prisma.eleve.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EleveCreateManyArgs>(args?: SelectSubset<T, EleveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eleve.
     * @param {EleveDeleteArgs} args - Arguments to delete one Eleve.
     * @example
     * // Delete one Eleve
     * const Eleve = await prisma.eleve.delete({
     *   where: {
     *     // ... filter to delete one Eleve
     *   }
     * })
     * 
     */
    delete<T extends EleveDeleteArgs>(args: SelectSubset<T, EleveDeleteArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eleve.
     * @param {EleveUpdateArgs} args - Arguments to update one Eleve.
     * @example
     * // Update one Eleve
     * const eleve = await prisma.eleve.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EleveUpdateArgs>(args: SelectSubset<T, EleveUpdateArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eleves.
     * @param {EleveDeleteManyArgs} args - Arguments to filter Eleves to delete.
     * @example
     * // Delete a few Eleves
     * const { count } = await prisma.eleve.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EleveDeleteManyArgs>(args?: SelectSubset<T, EleveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eleves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eleves
     * const eleve = await prisma.eleve.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EleveUpdateManyArgs>(args: SelectSubset<T, EleveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eleve.
     * @param {EleveUpsertArgs} args - Arguments to update or create a Eleve.
     * @example
     * // Update or create a Eleve
     * const eleve = await prisma.eleve.upsert({
     *   create: {
     *     // ... data to create a Eleve
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eleve we want to update
     *   }
     * })
     */
    upsert<T extends EleveUpsertArgs>(args: SelectSubset<T, EleveUpsertArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eleves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveCountArgs} args - Arguments to filter Eleves to count.
     * @example
     * // Count the number of Eleves
     * const count = await prisma.eleve.count({
     *   where: {
     *     // ... the filter for the Eleves we want to count
     *   }
     * })
    **/
    count<T extends EleveCountArgs>(
      args?: Subset<T, EleveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EleveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eleve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EleveAggregateArgs>(args: Subset<T, EleveAggregateArgs>): Prisma.PrismaPromise<GetEleveAggregateType<T>>

    /**
     * Group by Eleve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EleveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EleveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EleveGroupByArgs['orderBy'] }
        : { orderBy?: EleveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EleveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEleveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Eleve model
   */
  readonly fields: EleveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Eleve.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EleveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    note_inter<T extends Eleve$note_interArgs<ExtArgs> = {}>(args?: Subset<T, Eleve$note_interArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findMany"> | Null>
    note_devoir<T extends Eleve$note_devoirArgs<ExtArgs> = {}>(args?: Subset<T, Eleve$note_devoirArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findMany"> | Null>
    rang<T extends Eleve$rangArgs<ExtArgs> = {}>(args?: Subset<T, Eleve$rangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findMany"> | Null>
    commentaire<T extends Eleve$commentaireArgs<ExtArgs> = {}>(args?: Subset<T, Eleve$commentaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Eleve model
   */ 
  interface EleveFieldRefs {
    readonly id: FieldRef<"Eleve", 'Int'>
    readonly createdAt: FieldRef<"Eleve", 'DateTime'>
    readonly updatedAt: FieldRef<"Eleve", 'DateTime'>
    readonly nom: FieldRef<"Eleve", 'String'>
    readonly prenom: FieldRef<"Eleve", 'String'>
    readonly email: FieldRef<"Eleve", 'String'>
    readonly photo: FieldRef<"Eleve", 'Bytes'>
    readonly sexe: FieldRef<"Eleve", 'String'>
    readonly id_classe: FieldRef<"Eleve", 'Int'>
    readonly id_parent: FieldRef<"Eleve", 'Int'>
    readonly username: FieldRef<"Eleve", 'String'>
    readonly password: FieldRef<"Eleve", 'String'>
    readonly role: FieldRef<"Eleve", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Eleve findUnique
   */
  export type EleveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter, which Eleve to fetch.
     */
    where: EleveWhereUniqueInput
  }

  /**
   * Eleve findUniqueOrThrow
   */
  export type EleveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter, which Eleve to fetch.
     */
    where: EleveWhereUniqueInput
  }

  /**
   * Eleve findFirst
   */
  export type EleveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter, which Eleve to fetch.
     */
    where?: EleveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eleves to fetch.
     */
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eleves.
     */
    cursor?: EleveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eleves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eleves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eleves.
     */
    distinct?: EleveScalarFieldEnum | EleveScalarFieldEnum[]
  }

  /**
   * Eleve findFirstOrThrow
   */
  export type EleveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter, which Eleve to fetch.
     */
    where?: EleveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eleves to fetch.
     */
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eleves.
     */
    cursor?: EleveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eleves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eleves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eleves.
     */
    distinct?: EleveScalarFieldEnum | EleveScalarFieldEnum[]
  }

  /**
   * Eleve findMany
   */
  export type EleveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter, which Eleves to fetch.
     */
    where?: EleveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eleves to fetch.
     */
    orderBy?: EleveOrderByWithRelationInput | EleveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eleves.
     */
    cursor?: EleveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eleves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eleves.
     */
    skip?: number
    distinct?: EleveScalarFieldEnum | EleveScalarFieldEnum[]
  }

  /**
   * Eleve create
   */
  export type EleveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * The data needed to create a Eleve.
     */
    data: XOR<EleveCreateInput, EleveUncheckedCreateInput>
  }

  /**
   * Eleve createMany
   */
  export type EleveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eleves.
     */
    data: EleveCreateManyInput | EleveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Eleve update
   */
  export type EleveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * The data needed to update a Eleve.
     */
    data: XOR<EleveUpdateInput, EleveUncheckedUpdateInput>
    /**
     * Choose, which Eleve to update.
     */
    where: EleveWhereUniqueInput
  }

  /**
   * Eleve updateMany
   */
  export type EleveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eleves.
     */
    data: XOR<EleveUpdateManyMutationInput, EleveUncheckedUpdateManyInput>
    /**
     * Filter which Eleves to update
     */
    where?: EleveWhereInput
  }

  /**
   * Eleve upsert
   */
  export type EleveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * The filter to search for the Eleve to update in case it exists.
     */
    where: EleveWhereUniqueInput
    /**
     * In case the Eleve found by the `where` argument doesn't exist, create a new Eleve with this data.
     */
    create: XOR<EleveCreateInput, EleveUncheckedCreateInput>
    /**
     * In case the Eleve was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EleveUpdateInput, EleveUncheckedUpdateInput>
  }

  /**
   * Eleve delete
   */
  export type EleveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
    /**
     * Filter which Eleve to delete.
     */
    where: EleveWhereUniqueInput
  }

  /**
   * Eleve deleteMany
   */
  export type EleveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eleves to delete
     */
    where?: EleveWhereInput
  }

  /**
   * Eleve.note_inter
   */
  export type Eleve$note_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    where?: Note_interWhereInput
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    cursor?: Note_interWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Eleve.note_devoir
   */
  export type Eleve$note_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    where?: Note_devoirWhereInput
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    cursor?: Note_devoirWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Eleve.rang
   */
  export type Eleve$rangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    where?: RangWhereInput
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    cursor?: RangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Eleve.commentaire
   */
  export type Eleve$commentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Eleve without action
   */
  export type EleveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Eleve
     */
    select?: EleveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EleveInclude<ExtArgs> | null
  }


  /**
   * Model Commentaire
   */

  export type AggregateCommentaire = {
    _count: CommentaireCountAggregateOutputType | null
    _avg: CommentaireAvgAggregateOutputType | null
    _sum: CommentaireSumAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  export type CommentaireAvgAggregateOutputType = {
    id: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type CommentaireSumAggregateOutputType = {
    id: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type CommentaireMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    contenu: string | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type CommentaireMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    contenu: string | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type CommentaireCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    contenu: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: number
    _all: number
  }


  export type CommentaireAvgAggregateInputType = {
    id?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type CommentaireSumAggregateInputType = {
    id?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type CommentaireMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    contenu?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type CommentaireMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    contenu?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type CommentaireCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    contenu?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
    _all?: true
  }

  export type CommentaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaire to aggregate.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commentaires
    **/
    _count?: true | CommentaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentaireMaxAggregateInputType
  }

  export type GetCommentaireAggregateType<T extends CommentaireAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentaire[P]>
      : GetScalarType<T[P], AggregateCommentaire[P]>
  }




  export type CommentaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithAggregationInput | CommentaireOrderByWithAggregationInput[]
    by: CommentaireScalarFieldEnum[] | CommentaireScalarFieldEnum
    having?: CommentaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentaireCountAggregateInputType | true
    _avg?: CommentaireAvgAggregateInputType
    _sum?: CommentaireSumAggregateInputType
    _min?: CommentaireMinAggregateInputType
    _max?: CommentaireMaxAggregateInputType
  }

  export type CommentaireGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: boolean
    _count: CommentaireCountAggregateOutputType | null
    _avg: CommentaireAvgAggregateOutputType | null
    _sum: CommentaireSumAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  type GetCommentaireGroupByPayload<T extends CommentaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
            : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
        }
      >
    >


  export type CommentaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contenu?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentaire"]>


  export type CommentaireSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contenu?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
  }

  export type CommentaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }

  export type $CommentairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commentaire"
    objects: {
      eleve: Prisma.$ElevePayload<ExtArgs>
      enseignant: Prisma.$EnseignantPayload<ExtArgs>
      matiere: Prisma.$MatierePayload<ExtArgs>
      trimestre: Prisma.$TrimestrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      contenu: string
      id_eleve: number
      id_enseignant: number
      id_matiere: number
      id_trimestre: number
      vu: boolean
    }, ExtArgs["result"]["commentaire"]>
    composites: {}
  }

  type CommentaireGetPayload<S extends boolean | null | undefined | CommentaireDefaultArgs> = $Result.GetResult<Prisma.$CommentairePayload, S>

  type CommentaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentaireCountAggregateInputType | true
    }

  export interface CommentaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commentaire'], meta: { name: 'Commentaire' } }
    /**
     * Find zero or one Commentaire that matches the filter.
     * @param {CommentaireFindUniqueArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentaireFindUniqueArgs>(args: SelectSubset<T, CommentaireFindUniqueArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commentaire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentaireFindUniqueOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentaireFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentaireFindFirstArgs>(args?: SelectSubset<T, CommentaireFindFirstArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentaireFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commentaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commentaires
     * const commentaires = await prisma.commentaire.findMany()
     * 
     * // Get first 10 Commentaires
     * const commentaires = await prisma.commentaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentaireWithIdOnly = await prisma.commentaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentaireFindManyArgs>(args?: SelectSubset<T, CommentaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commentaire.
     * @param {CommentaireCreateArgs} args - Arguments to create a Commentaire.
     * @example
     * // Create one Commentaire
     * const Commentaire = await prisma.commentaire.create({
     *   data: {
     *     // ... data to create a Commentaire
     *   }
     * })
     * 
     */
    create<T extends CommentaireCreateArgs>(args: SelectSubset<T, CommentaireCreateArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commentaires.
     * @param {CommentaireCreateManyArgs} args - Arguments to create many Commentaires.
     * @example
     * // Create many Commentaires
     * const commentaire = await prisma.commentaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentaireCreateManyArgs>(args?: SelectSubset<T, CommentaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commentaire.
     * @param {CommentaireDeleteArgs} args - Arguments to delete one Commentaire.
     * @example
     * // Delete one Commentaire
     * const Commentaire = await prisma.commentaire.delete({
     *   where: {
     *     // ... filter to delete one Commentaire
     *   }
     * })
     * 
     */
    delete<T extends CommentaireDeleteArgs>(args: SelectSubset<T, CommentaireDeleteArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commentaire.
     * @param {CommentaireUpdateArgs} args - Arguments to update one Commentaire.
     * @example
     * // Update one Commentaire
     * const commentaire = await prisma.commentaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentaireUpdateArgs>(args: SelectSubset<T, CommentaireUpdateArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commentaires.
     * @param {CommentaireDeleteManyArgs} args - Arguments to filter Commentaires to delete.
     * @example
     * // Delete a few Commentaires
     * const { count } = await prisma.commentaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentaireDeleteManyArgs>(args?: SelectSubset<T, CommentaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commentaires
     * const commentaire = await prisma.commentaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentaireUpdateManyArgs>(args: SelectSubset<T, CommentaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commentaire.
     * @param {CommentaireUpsertArgs} args - Arguments to update or create a Commentaire.
     * @example
     * // Update or create a Commentaire
     * const commentaire = await prisma.commentaire.upsert({
     *   create: {
     *     // ... data to create a Commentaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commentaire we want to update
     *   }
     * })
     */
    upsert<T extends CommentaireUpsertArgs>(args: SelectSubset<T, CommentaireUpsertArgs<ExtArgs>>): Prisma__CommentaireClient<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireCountArgs} args - Arguments to filter Commentaires to count.
     * @example
     * // Count the number of Commentaires
     * const count = await prisma.commentaire.count({
     *   where: {
     *     // ... the filter for the Commentaires we want to count
     *   }
     * })
    **/
    count<T extends CommentaireCountArgs>(
      args?: Subset<T, CommentaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentaireAggregateArgs>(args: Subset<T, CommentaireAggregateArgs>): Prisma.PrismaPromise<GetCommentaireAggregateType<T>>

    /**
     * Group by Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentaireGroupByArgs['orderBy'] }
        : { orderBy?: CommentaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commentaire model
   */
  readonly fields: CommentaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commentaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eleve<T extends EleveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EleveDefaultArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enseignant<T extends EnseignantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseignantDefaultArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trimestre<T extends TrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrimestreDefaultArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commentaire model
   */ 
  interface CommentaireFieldRefs {
    readonly id: FieldRef<"Commentaire", 'Int'>
    readonly createdAt: FieldRef<"Commentaire", 'DateTime'>
    readonly updatedAt: FieldRef<"Commentaire", 'DateTime'>
    readonly contenu: FieldRef<"Commentaire", 'String'>
    readonly id_eleve: FieldRef<"Commentaire", 'Int'>
    readonly id_enseignant: FieldRef<"Commentaire", 'Int'>
    readonly id_matiere: FieldRef<"Commentaire", 'Int'>
    readonly id_trimestre: FieldRef<"Commentaire", 'Int'>
    readonly vu: FieldRef<"Commentaire", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Commentaire findUnique
   */
  export type CommentaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }

  /**
   * Commentaire findUniqueOrThrow
   */
  export type CommentaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }

  /**
   * Commentaire findFirst
   */
  export type CommentaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Commentaire findFirstOrThrow
   */
  export type CommentaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Commentaire findMany
   */
  export type CommentaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaires to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Commentaire create
   */
  export type CommentaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Commentaire.
     */
    data: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
  }

  /**
   * Commentaire createMany
   */
  export type CommentaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commentaires.
     */
    data: CommentaireCreateManyInput | CommentaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commentaire update
   */
  export type CommentaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Commentaire.
     */
    data: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
    /**
     * Choose, which Commentaire to update.
     */
    where: CommentaireWhereUniqueInput
  }

  /**
   * Commentaire updateMany
   */
  export type CommentaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commentaires.
     */
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyInput>
    /**
     * Filter which Commentaires to update
     */
    where?: CommentaireWhereInput
  }

  /**
   * Commentaire upsert
   */
  export type CommentaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Commentaire to update in case it exists.
     */
    where: CommentaireWhereUniqueInput
    /**
     * In case the Commentaire found by the `where` argument doesn't exist, create a new Commentaire with this data.
     */
    create: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
    /**
     * In case the Commentaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
  }

  /**
   * Commentaire delete
   */
  export type CommentaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter which Commentaire to delete.
     */
    where: CommentaireWhereUniqueInput
  }

  /**
   * Commentaire deleteMany
   */
  export type CommentaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaires to delete
     */
    where?: CommentaireWhereInput
  }

  /**
   * Commentaire without action
   */
  export type CommentaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
  }


  /**
   * Model PieceJointe
   */

  export type AggregatePieceJointe = {
    _count: PieceJointeCountAggregateOutputType | null
    _avg: PieceJointeAvgAggregateOutputType | null
    _sum: PieceJointeSumAggregateOutputType | null
    _min: PieceJointeMinAggregateOutputType | null
    _max: PieceJointeMaxAggregateOutputType | null
  }

  export type PieceJointeAvgAggregateOutputType = {
    id: number | null
    id_classe: number | null
    id_matiere: number | null
    id_enseignant: number | null
  }

  export type PieceJointeSumAggregateOutputType = {
    id: number | null
    id_classe: number | null
    id_matiere: number | null
    id_enseignant: number | null
  }

  export type PieceJointeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    titre: string | null
    piece: Buffer | null
    id_classe: number | null
    id_matiere: number | null
    id_enseignant: number | null
  }

  export type PieceJointeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    titre: string | null
    piece: Buffer | null
    id_classe: number | null
    id_matiere: number | null
    id_enseignant: number | null
  }

  export type PieceJointeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    titre: number
    piece: number
    id_classe: number
    id_matiere: number
    id_enseignant: number
    _all: number
  }


  export type PieceJointeAvgAggregateInputType = {
    id?: true
    id_classe?: true
    id_matiere?: true
    id_enseignant?: true
  }

  export type PieceJointeSumAggregateInputType = {
    id?: true
    id_classe?: true
    id_matiere?: true
    id_enseignant?: true
  }

  export type PieceJointeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    titre?: true
    piece?: true
    id_classe?: true
    id_matiere?: true
    id_enseignant?: true
  }

  export type PieceJointeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    titre?: true
    piece?: true
    id_classe?: true
    id_matiere?: true
    id_enseignant?: true
  }

  export type PieceJointeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    titre?: true
    piece?: true
    id_classe?: true
    id_matiere?: true
    id_enseignant?: true
    _all?: true
  }

  export type PieceJointeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PieceJointe to aggregate.
     */
    where?: PieceJointeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PieceJointes to fetch.
     */
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PieceJointeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PieceJointes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PieceJointes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PieceJointes
    **/
    _count?: true | PieceJointeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PieceJointeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PieceJointeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PieceJointeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PieceJointeMaxAggregateInputType
  }

  export type GetPieceJointeAggregateType<T extends PieceJointeAggregateArgs> = {
        [P in keyof T & keyof AggregatePieceJointe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePieceJointe[P]>
      : GetScalarType<T[P], AggregatePieceJointe[P]>
  }




  export type PieceJointeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PieceJointeWhereInput
    orderBy?: PieceJointeOrderByWithAggregationInput | PieceJointeOrderByWithAggregationInput[]
    by: PieceJointeScalarFieldEnum[] | PieceJointeScalarFieldEnum
    having?: PieceJointeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PieceJointeCountAggregateInputType | true
    _avg?: PieceJointeAvgAggregateInputType
    _sum?: PieceJointeSumAggregateInputType
    _min?: PieceJointeMinAggregateInputType
    _max?: PieceJointeMaxAggregateInputType
  }

  export type PieceJointeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    titre: string
    piece: Buffer
    id_classe: number
    id_matiere: number
    id_enseignant: number
    _count: PieceJointeCountAggregateOutputType | null
    _avg: PieceJointeAvgAggregateOutputType | null
    _sum: PieceJointeSumAggregateOutputType | null
    _min: PieceJointeMinAggregateOutputType | null
    _max: PieceJointeMaxAggregateOutputType | null
  }

  type GetPieceJointeGroupByPayload<T extends PieceJointeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PieceJointeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PieceJointeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PieceJointeGroupByOutputType[P]>
            : GetScalarType<T[P], PieceJointeGroupByOutputType[P]>
        }
      >
    >


  export type PieceJointeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    titre?: boolean
    piece?: boolean
    id_classe?: boolean
    id_matiere?: boolean
    id_enseignant?: boolean
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pieceJointe"]>


  export type PieceJointeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    titre?: boolean
    piece?: boolean
    id_classe?: boolean
    id_matiere?: boolean
    id_enseignant?: boolean
  }

  export type PieceJointeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
  }

  export type $PieceJointePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PieceJointe"
    objects: {
      classe: Prisma.$ClassePayload<ExtArgs>
      matiere: Prisma.$MatierePayload<ExtArgs>
      enseignant: Prisma.$EnseignantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      titre: string
      piece: Buffer
      id_classe: number
      id_matiere: number
      id_enseignant: number
    }, ExtArgs["result"]["pieceJointe"]>
    composites: {}
  }

  type PieceJointeGetPayload<S extends boolean | null | undefined | PieceJointeDefaultArgs> = $Result.GetResult<Prisma.$PieceJointePayload, S>

  type PieceJointeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PieceJointeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PieceJointeCountAggregateInputType | true
    }

  export interface PieceJointeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PieceJointe'], meta: { name: 'PieceJointe' } }
    /**
     * Find zero or one PieceJointe that matches the filter.
     * @param {PieceJointeFindUniqueArgs} args - Arguments to find a PieceJointe
     * @example
     * // Get one PieceJointe
     * const pieceJointe = await prisma.pieceJointe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PieceJointeFindUniqueArgs>(args: SelectSubset<T, PieceJointeFindUniqueArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PieceJointe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PieceJointeFindUniqueOrThrowArgs} args - Arguments to find a PieceJointe
     * @example
     * // Get one PieceJointe
     * const pieceJointe = await prisma.pieceJointe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PieceJointeFindUniqueOrThrowArgs>(args: SelectSubset<T, PieceJointeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PieceJointe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeFindFirstArgs} args - Arguments to find a PieceJointe
     * @example
     * // Get one PieceJointe
     * const pieceJointe = await prisma.pieceJointe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PieceJointeFindFirstArgs>(args?: SelectSubset<T, PieceJointeFindFirstArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PieceJointe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeFindFirstOrThrowArgs} args - Arguments to find a PieceJointe
     * @example
     * // Get one PieceJointe
     * const pieceJointe = await prisma.pieceJointe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PieceJointeFindFirstOrThrowArgs>(args?: SelectSubset<T, PieceJointeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PieceJointes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PieceJointes
     * const pieceJointes = await prisma.pieceJointe.findMany()
     * 
     * // Get first 10 PieceJointes
     * const pieceJointes = await prisma.pieceJointe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pieceJointeWithIdOnly = await prisma.pieceJointe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PieceJointeFindManyArgs>(args?: SelectSubset<T, PieceJointeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PieceJointe.
     * @param {PieceJointeCreateArgs} args - Arguments to create a PieceJointe.
     * @example
     * // Create one PieceJointe
     * const PieceJointe = await prisma.pieceJointe.create({
     *   data: {
     *     // ... data to create a PieceJointe
     *   }
     * })
     * 
     */
    create<T extends PieceJointeCreateArgs>(args: SelectSubset<T, PieceJointeCreateArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PieceJointes.
     * @param {PieceJointeCreateManyArgs} args - Arguments to create many PieceJointes.
     * @example
     * // Create many PieceJointes
     * const pieceJointe = await prisma.pieceJointe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PieceJointeCreateManyArgs>(args?: SelectSubset<T, PieceJointeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PieceJointe.
     * @param {PieceJointeDeleteArgs} args - Arguments to delete one PieceJointe.
     * @example
     * // Delete one PieceJointe
     * const PieceJointe = await prisma.pieceJointe.delete({
     *   where: {
     *     // ... filter to delete one PieceJointe
     *   }
     * })
     * 
     */
    delete<T extends PieceJointeDeleteArgs>(args: SelectSubset<T, PieceJointeDeleteArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PieceJointe.
     * @param {PieceJointeUpdateArgs} args - Arguments to update one PieceJointe.
     * @example
     * // Update one PieceJointe
     * const pieceJointe = await prisma.pieceJointe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PieceJointeUpdateArgs>(args: SelectSubset<T, PieceJointeUpdateArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PieceJointes.
     * @param {PieceJointeDeleteManyArgs} args - Arguments to filter PieceJointes to delete.
     * @example
     * // Delete a few PieceJointes
     * const { count } = await prisma.pieceJointe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PieceJointeDeleteManyArgs>(args?: SelectSubset<T, PieceJointeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PieceJointes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PieceJointes
     * const pieceJointe = await prisma.pieceJointe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PieceJointeUpdateManyArgs>(args: SelectSubset<T, PieceJointeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PieceJointe.
     * @param {PieceJointeUpsertArgs} args - Arguments to update or create a PieceJointe.
     * @example
     * // Update or create a PieceJointe
     * const pieceJointe = await prisma.pieceJointe.upsert({
     *   create: {
     *     // ... data to create a PieceJointe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PieceJointe we want to update
     *   }
     * })
     */
    upsert<T extends PieceJointeUpsertArgs>(args: SelectSubset<T, PieceJointeUpsertArgs<ExtArgs>>): Prisma__PieceJointeClient<$Result.GetResult<Prisma.$PieceJointePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PieceJointes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeCountArgs} args - Arguments to filter PieceJointes to count.
     * @example
     * // Count the number of PieceJointes
     * const count = await prisma.pieceJointe.count({
     *   where: {
     *     // ... the filter for the PieceJointes we want to count
     *   }
     * })
    **/
    count<T extends PieceJointeCountArgs>(
      args?: Subset<T, PieceJointeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PieceJointeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PieceJointe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PieceJointeAggregateArgs>(args: Subset<T, PieceJointeAggregateArgs>): Prisma.PrismaPromise<GetPieceJointeAggregateType<T>>

    /**
     * Group by PieceJointe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PieceJointeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PieceJointeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PieceJointeGroupByArgs['orderBy'] }
        : { orderBy?: PieceJointeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PieceJointeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPieceJointeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PieceJointe model
   */
  readonly fields: PieceJointeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PieceJointe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PieceJointeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enseignant<T extends EnseignantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseignantDefaultArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PieceJointe model
   */ 
  interface PieceJointeFieldRefs {
    readonly id: FieldRef<"PieceJointe", 'Int'>
    readonly createdAt: FieldRef<"PieceJointe", 'DateTime'>
    readonly updatedAt: FieldRef<"PieceJointe", 'DateTime'>
    readonly titre: FieldRef<"PieceJointe", 'String'>
    readonly piece: FieldRef<"PieceJointe", 'Bytes'>
    readonly id_classe: FieldRef<"PieceJointe", 'Int'>
    readonly id_matiere: FieldRef<"PieceJointe", 'Int'>
    readonly id_enseignant: FieldRef<"PieceJointe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PieceJointe findUnique
   */
  export type PieceJointeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter, which PieceJointe to fetch.
     */
    where: PieceJointeWhereUniqueInput
  }

  /**
   * PieceJointe findUniqueOrThrow
   */
  export type PieceJointeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter, which PieceJointe to fetch.
     */
    where: PieceJointeWhereUniqueInput
  }

  /**
   * PieceJointe findFirst
   */
  export type PieceJointeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter, which PieceJointe to fetch.
     */
    where?: PieceJointeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PieceJointes to fetch.
     */
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PieceJointes.
     */
    cursor?: PieceJointeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PieceJointes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PieceJointes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PieceJointes.
     */
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * PieceJointe findFirstOrThrow
   */
  export type PieceJointeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter, which PieceJointe to fetch.
     */
    where?: PieceJointeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PieceJointes to fetch.
     */
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PieceJointes.
     */
    cursor?: PieceJointeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PieceJointes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PieceJointes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PieceJointes.
     */
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * PieceJointe findMany
   */
  export type PieceJointeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter, which PieceJointes to fetch.
     */
    where?: PieceJointeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PieceJointes to fetch.
     */
    orderBy?: PieceJointeOrderByWithRelationInput | PieceJointeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PieceJointes.
     */
    cursor?: PieceJointeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PieceJointes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PieceJointes.
     */
    skip?: number
    distinct?: PieceJointeScalarFieldEnum | PieceJointeScalarFieldEnum[]
  }

  /**
   * PieceJointe create
   */
  export type PieceJointeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * The data needed to create a PieceJointe.
     */
    data: XOR<PieceJointeCreateInput, PieceJointeUncheckedCreateInput>
  }

  /**
   * PieceJointe createMany
   */
  export type PieceJointeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PieceJointes.
     */
    data: PieceJointeCreateManyInput | PieceJointeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PieceJointe update
   */
  export type PieceJointeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * The data needed to update a PieceJointe.
     */
    data: XOR<PieceJointeUpdateInput, PieceJointeUncheckedUpdateInput>
    /**
     * Choose, which PieceJointe to update.
     */
    where: PieceJointeWhereUniqueInput
  }

  /**
   * PieceJointe updateMany
   */
  export type PieceJointeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PieceJointes.
     */
    data: XOR<PieceJointeUpdateManyMutationInput, PieceJointeUncheckedUpdateManyInput>
    /**
     * Filter which PieceJointes to update
     */
    where?: PieceJointeWhereInput
  }

  /**
   * PieceJointe upsert
   */
  export type PieceJointeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * The filter to search for the PieceJointe to update in case it exists.
     */
    where: PieceJointeWhereUniqueInput
    /**
     * In case the PieceJointe found by the `where` argument doesn't exist, create a new PieceJointe with this data.
     */
    create: XOR<PieceJointeCreateInput, PieceJointeUncheckedCreateInput>
    /**
     * In case the PieceJointe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PieceJointeUpdateInput, PieceJointeUncheckedUpdateInput>
  }

  /**
   * PieceJointe delete
   */
  export type PieceJointeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
    /**
     * Filter which PieceJointe to delete.
     */
    where: PieceJointeWhereUniqueInput
  }

  /**
   * PieceJointe deleteMany
   */
  export type PieceJointeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PieceJointes to delete
     */
    where?: PieceJointeWhereInput
  }

  /**
   * PieceJointe without action
   */
  export type PieceJointeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PieceJointe
     */
    select?: PieceJointeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PieceJointeInclude<ExtArgs> | null
  }


  /**
   * Model Enseignant_Classe
   */

  export type AggregateEnseignant_Classe = {
    _count: Enseignant_ClasseCountAggregateOutputType | null
    _avg: Enseignant_ClasseAvgAggregateOutputType | null
    _sum: Enseignant_ClasseSumAggregateOutputType | null
    _min: Enseignant_ClasseMinAggregateOutputType | null
    _max: Enseignant_ClasseMaxAggregateOutputType | null
  }

  export type Enseignant_ClasseAvgAggregateOutputType = {
    id: number | null
    id_enseignant: number | null
    id_classe: number | null
    id_matiere: number | null
  }

  export type Enseignant_ClasseSumAggregateOutputType = {
    id: number | null
    id_enseignant: number | null
    id_classe: number | null
    id_matiere: number | null
  }

  export type Enseignant_ClasseMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id_enseignant: number | null
    id_classe: number | null
    id_matiere: number | null
  }

  export type Enseignant_ClasseMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id_enseignant: number | null
    id_classe: number | null
    id_matiere: number | null
  }

  export type Enseignant_ClasseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    id_enseignant: number
    id_classe: number
    id_matiere: number
    _all: number
  }


  export type Enseignant_ClasseAvgAggregateInputType = {
    id?: true
    id_enseignant?: true
    id_classe?: true
    id_matiere?: true
  }

  export type Enseignant_ClasseSumAggregateInputType = {
    id?: true
    id_enseignant?: true
    id_classe?: true
    id_matiere?: true
  }

  export type Enseignant_ClasseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    id_enseignant?: true
    id_classe?: true
    id_matiere?: true
  }

  export type Enseignant_ClasseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    id_enseignant?: true
    id_classe?: true
    id_matiere?: true
  }

  export type Enseignant_ClasseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    id_enseignant?: true
    id_classe?: true
    id_matiere?: true
    _all?: true
  }

  export type Enseignant_ClasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseignant_Classe to aggregate.
     */
    where?: Enseignant_ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignant_Classes to fetch.
     */
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Enseignant_ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignant_Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignant_Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enseignant_Classes
    **/
    _count?: true | Enseignant_ClasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Enseignant_ClasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Enseignant_ClasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Enseignant_ClasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Enseignant_ClasseMaxAggregateInputType
  }

  export type GetEnseignant_ClasseAggregateType<T extends Enseignant_ClasseAggregateArgs> = {
        [P in keyof T & keyof AggregateEnseignant_Classe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnseignant_Classe[P]>
      : GetScalarType<T[P], AggregateEnseignant_Classe[P]>
  }




  export type Enseignant_ClasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Enseignant_ClasseWhereInput
    orderBy?: Enseignant_ClasseOrderByWithAggregationInput | Enseignant_ClasseOrderByWithAggregationInput[]
    by: Enseignant_ClasseScalarFieldEnum[] | Enseignant_ClasseScalarFieldEnum
    having?: Enseignant_ClasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Enseignant_ClasseCountAggregateInputType | true
    _avg?: Enseignant_ClasseAvgAggregateInputType
    _sum?: Enseignant_ClasseSumAggregateInputType
    _min?: Enseignant_ClasseMinAggregateInputType
    _max?: Enseignant_ClasseMaxAggregateInputType
  }

  export type Enseignant_ClasseGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    id_enseignant: number
    id_classe: number
    id_matiere: number
    _count: Enseignant_ClasseCountAggregateOutputType | null
    _avg: Enseignant_ClasseAvgAggregateOutputType | null
    _sum: Enseignant_ClasseSumAggregateOutputType | null
    _min: Enseignant_ClasseMinAggregateOutputType | null
    _max: Enseignant_ClasseMaxAggregateOutputType | null
  }

  type GetEnseignant_ClasseGroupByPayload<T extends Enseignant_ClasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Enseignant_ClasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Enseignant_ClasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Enseignant_ClasseGroupByOutputType[P]>
            : GetScalarType<T[P], Enseignant_ClasseGroupByOutputType[P]>
        }
      >
    >


  export type Enseignant_ClasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_enseignant?: boolean
    id_classe?: boolean
    id_matiere?: boolean
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enseignant_Classe"]>


  export type Enseignant_ClasseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_enseignant?: boolean
    id_classe?: boolean
    id_matiere?: boolean
  }

  export type Enseignant_ClasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    classe?: boolean | ClasseDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
  }

  export type $Enseignant_ClassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enseignant_Classe"
    objects: {
      enseignant: Prisma.$EnseignantPayload<ExtArgs>
      classe: Prisma.$ClassePayload<ExtArgs>
      matiere: Prisma.$MatierePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      id_enseignant: number
      id_classe: number
      id_matiere: number
    }, ExtArgs["result"]["enseignant_Classe"]>
    composites: {}
  }

  type Enseignant_ClasseGetPayload<S extends boolean | null | undefined | Enseignant_ClasseDefaultArgs> = $Result.GetResult<Prisma.$Enseignant_ClassePayload, S>

  type Enseignant_ClasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Enseignant_ClasseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Enseignant_ClasseCountAggregateInputType | true
    }

  export interface Enseignant_ClasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enseignant_Classe'], meta: { name: 'Enseignant_Classe' } }
    /**
     * Find zero or one Enseignant_Classe that matches the filter.
     * @param {Enseignant_ClasseFindUniqueArgs} args - Arguments to find a Enseignant_Classe
     * @example
     * // Get one Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Enseignant_ClasseFindUniqueArgs>(args: SelectSubset<T, Enseignant_ClasseFindUniqueArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enseignant_Classe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Enseignant_ClasseFindUniqueOrThrowArgs} args - Arguments to find a Enseignant_Classe
     * @example
     * // Get one Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Enseignant_ClasseFindUniqueOrThrowArgs>(args: SelectSubset<T, Enseignant_ClasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enseignant_Classe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseFindFirstArgs} args - Arguments to find a Enseignant_Classe
     * @example
     * // Get one Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Enseignant_ClasseFindFirstArgs>(args?: SelectSubset<T, Enseignant_ClasseFindFirstArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enseignant_Classe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseFindFirstOrThrowArgs} args - Arguments to find a Enseignant_Classe
     * @example
     * // Get one Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Enseignant_ClasseFindFirstOrThrowArgs>(args?: SelectSubset<T, Enseignant_ClasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enseignant_Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enseignant_Classes
     * const enseignant_Classes = await prisma.enseignant_Classe.findMany()
     * 
     * // Get first 10 Enseignant_Classes
     * const enseignant_Classes = await prisma.enseignant_Classe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enseignant_ClasseWithIdOnly = await prisma.enseignant_Classe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Enseignant_ClasseFindManyArgs>(args?: SelectSubset<T, Enseignant_ClasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enseignant_Classe.
     * @param {Enseignant_ClasseCreateArgs} args - Arguments to create a Enseignant_Classe.
     * @example
     * // Create one Enseignant_Classe
     * const Enseignant_Classe = await prisma.enseignant_Classe.create({
     *   data: {
     *     // ... data to create a Enseignant_Classe
     *   }
     * })
     * 
     */
    create<T extends Enseignant_ClasseCreateArgs>(args: SelectSubset<T, Enseignant_ClasseCreateArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enseignant_Classes.
     * @param {Enseignant_ClasseCreateManyArgs} args - Arguments to create many Enseignant_Classes.
     * @example
     * // Create many Enseignant_Classes
     * const enseignant_Classe = await prisma.enseignant_Classe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Enseignant_ClasseCreateManyArgs>(args?: SelectSubset<T, Enseignant_ClasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enseignant_Classe.
     * @param {Enseignant_ClasseDeleteArgs} args - Arguments to delete one Enseignant_Classe.
     * @example
     * // Delete one Enseignant_Classe
     * const Enseignant_Classe = await prisma.enseignant_Classe.delete({
     *   where: {
     *     // ... filter to delete one Enseignant_Classe
     *   }
     * })
     * 
     */
    delete<T extends Enseignant_ClasseDeleteArgs>(args: SelectSubset<T, Enseignant_ClasseDeleteArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enseignant_Classe.
     * @param {Enseignant_ClasseUpdateArgs} args - Arguments to update one Enseignant_Classe.
     * @example
     * // Update one Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Enseignant_ClasseUpdateArgs>(args: SelectSubset<T, Enseignant_ClasseUpdateArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enseignant_Classes.
     * @param {Enseignant_ClasseDeleteManyArgs} args - Arguments to filter Enseignant_Classes to delete.
     * @example
     * // Delete a few Enseignant_Classes
     * const { count } = await prisma.enseignant_Classe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Enseignant_ClasseDeleteManyArgs>(args?: SelectSubset<T, Enseignant_ClasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enseignant_Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enseignant_Classes
     * const enseignant_Classe = await prisma.enseignant_Classe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Enseignant_ClasseUpdateManyArgs>(args: SelectSubset<T, Enseignant_ClasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enseignant_Classe.
     * @param {Enseignant_ClasseUpsertArgs} args - Arguments to update or create a Enseignant_Classe.
     * @example
     * // Update or create a Enseignant_Classe
     * const enseignant_Classe = await prisma.enseignant_Classe.upsert({
     *   create: {
     *     // ... data to create a Enseignant_Classe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enseignant_Classe we want to update
     *   }
     * })
     */
    upsert<T extends Enseignant_ClasseUpsertArgs>(args: SelectSubset<T, Enseignant_ClasseUpsertArgs<ExtArgs>>): Prisma__Enseignant_ClasseClient<$Result.GetResult<Prisma.$Enseignant_ClassePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enseignant_Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseCountArgs} args - Arguments to filter Enseignant_Classes to count.
     * @example
     * // Count the number of Enseignant_Classes
     * const count = await prisma.enseignant_Classe.count({
     *   where: {
     *     // ... the filter for the Enseignant_Classes we want to count
     *   }
     * })
    **/
    count<T extends Enseignant_ClasseCountArgs>(
      args?: Subset<T, Enseignant_ClasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Enseignant_ClasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enseignant_Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Enseignant_ClasseAggregateArgs>(args: Subset<T, Enseignant_ClasseAggregateArgs>): Prisma.PrismaPromise<GetEnseignant_ClasseAggregateType<T>>

    /**
     * Group by Enseignant_Classe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Enseignant_ClasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Enseignant_ClasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Enseignant_ClasseGroupByArgs['orderBy'] }
        : { orderBy?: Enseignant_ClasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Enseignant_ClasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnseignant_ClasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enseignant_Classe model
   */
  readonly fields: Enseignant_ClasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enseignant_Classe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Enseignant_ClasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enseignant<T extends EnseignantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseignantDefaultArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classe<T extends ClasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClasseDefaultArgs<ExtArgs>>): Prisma__ClasseClient<$Result.GetResult<Prisma.$ClassePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enseignant_Classe model
   */ 
  interface Enseignant_ClasseFieldRefs {
    readonly id: FieldRef<"Enseignant_Classe", 'Int'>
    readonly createdAt: FieldRef<"Enseignant_Classe", 'DateTime'>
    readonly updatedAt: FieldRef<"Enseignant_Classe", 'DateTime'>
    readonly id_enseignant: FieldRef<"Enseignant_Classe", 'Int'>
    readonly id_classe: FieldRef<"Enseignant_Classe", 'Int'>
    readonly id_matiere: FieldRef<"Enseignant_Classe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Enseignant_Classe findUnique
   */
  export type Enseignant_ClasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant_Classe to fetch.
     */
    where: Enseignant_ClasseWhereUniqueInput
  }

  /**
   * Enseignant_Classe findUniqueOrThrow
   */
  export type Enseignant_ClasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant_Classe to fetch.
     */
    where: Enseignant_ClasseWhereUniqueInput
  }

  /**
   * Enseignant_Classe findFirst
   */
  export type Enseignant_ClasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant_Classe to fetch.
     */
    where?: Enseignant_ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignant_Classes to fetch.
     */
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseignant_Classes.
     */
    cursor?: Enseignant_ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignant_Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignant_Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseignant_Classes.
     */
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Enseignant_Classe findFirstOrThrow
   */
  export type Enseignant_ClasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant_Classe to fetch.
     */
    where?: Enseignant_ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignant_Classes to fetch.
     */
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enseignant_Classes.
     */
    cursor?: Enseignant_ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignant_Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignant_Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enseignant_Classes.
     */
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Enseignant_Classe findMany
   */
  export type Enseignant_ClasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter, which Enseignant_Classes to fetch.
     */
    where?: Enseignant_ClasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enseignant_Classes to fetch.
     */
    orderBy?: Enseignant_ClasseOrderByWithRelationInput | Enseignant_ClasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enseignant_Classes.
     */
    cursor?: Enseignant_ClasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enseignant_Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enseignant_Classes.
     */
    skip?: number
    distinct?: Enseignant_ClasseScalarFieldEnum | Enseignant_ClasseScalarFieldEnum[]
  }

  /**
   * Enseignant_Classe create
   */
  export type Enseignant_ClasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Enseignant_Classe.
     */
    data: XOR<Enseignant_ClasseCreateInput, Enseignant_ClasseUncheckedCreateInput>
  }

  /**
   * Enseignant_Classe createMany
   */
  export type Enseignant_ClasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enseignant_Classes.
     */
    data: Enseignant_ClasseCreateManyInput | Enseignant_ClasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enseignant_Classe update
   */
  export type Enseignant_ClasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Enseignant_Classe.
     */
    data: XOR<Enseignant_ClasseUpdateInput, Enseignant_ClasseUncheckedUpdateInput>
    /**
     * Choose, which Enseignant_Classe to update.
     */
    where: Enseignant_ClasseWhereUniqueInput
  }

  /**
   * Enseignant_Classe updateMany
   */
  export type Enseignant_ClasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enseignant_Classes.
     */
    data: XOR<Enseignant_ClasseUpdateManyMutationInput, Enseignant_ClasseUncheckedUpdateManyInput>
    /**
     * Filter which Enseignant_Classes to update
     */
    where?: Enseignant_ClasseWhereInput
  }

  /**
   * Enseignant_Classe upsert
   */
  export type Enseignant_ClasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Enseignant_Classe to update in case it exists.
     */
    where: Enseignant_ClasseWhereUniqueInput
    /**
     * In case the Enseignant_Classe found by the `where` argument doesn't exist, create a new Enseignant_Classe with this data.
     */
    create: XOR<Enseignant_ClasseCreateInput, Enseignant_ClasseUncheckedCreateInput>
    /**
     * In case the Enseignant_Classe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Enseignant_ClasseUpdateInput, Enseignant_ClasseUncheckedUpdateInput>
  }

  /**
   * Enseignant_Classe delete
   */
  export type Enseignant_ClasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
    /**
     * Filter which Enseignant_Classe to delete.
     */
    where: Enseignant_ClasseWhereUniqueInput
  }

  /**
   * Enseignant_Classe deleteMany
   */
  export type Enseignant_ClasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enseignant_Classes to delete
     */
    where?: Enseignant_ClasseWhereInput
  }

  /**
   * Enseignant_Classe without action
   */
  export type Enseignant_ClasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enseignant_Classe
     */
    select?: Enseignant_ClasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Enseignant_ClasseInclude<ExtArgs> | null
  }


  /**
   * Model Trimestre
   */

  export type AggregateTrimestre = {
    _count: TrimestreCountAggregateOutputType | null
    _avg: TrimestreAvgAggregateOutputType | null
    _sum: TrimestreSumAggregateOutputType | null
    _min: TrimestreMinAggregateOutputType | null
    _max: TrimestreMaxAggregateOutputType | null
  }

  export type TrimestreAvgAggregateOutputType = {
    id: number | null
  }

  export type TrimestreSumAggregateOutputType = {
    id: number | null
  }

  export type TrimestreMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
  }

  export type TrimestreMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
  }

  export type TrimestreCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    _all: number
  }


  export type TrimestreAvgAggregateInputType = {
    id?: true
  }

  export type TrimestreSumAggregateInputType = {
    id?: true
  }

  export type TrimestreMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
  }

  export type TrimestreMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
  }

  export type TrimestreCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    _all?: true
  }

  export type TrimestreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trimestre to aggregate.
     */
    where?: TrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trimestres to fetch.
     */
    orderBy?: TrimestreOrderByWithRelationInput | TrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trimestres
    **/
    _count?: true | TrimestreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrimestreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrimestreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrimestreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrimestreMaxAggregateInputType
  }

  export type GetTrimestreAggregateType<T extends TrimestreAggregateArgs> = {
        [P in keyof T & keyof AggregateTrimestre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrimestre[P]>
      : GetScalarType<T[P], AggregateTrimestre[P]>
  }




  export type TrimestreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrimestreWhereInput
    orderBy?: TrimestreOrderByWithAggregationInput | TrimestreOrderByWithAggregationInput[]
    by: TrimestreScalarFieldEnum[] | TrimestreScalarFieldEnum
    having?: TrimestreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrimestreCountAggregateInputType | true
    _avg?: TrimestreAvgAggregateInputType
    _sum?: TrimestreSumAggregateInputType
    _min?: TrimestreMinAggregateInputType
    _max?: TrimestreMaxAggregateInputType
  }

  export type TrimestreGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    _count: TrimestreCountAggregateOutputType | null
    _avg: TrimestreAvgAggregateOutputType | null
    _sum: TrimestreSumAggregateOutputType | null
    _min: TrimestreMinAggregateOutputType | null
    _max: TrimestreMaxAggregateOutputType | null
  }

  type GetTrimestreGroupByPayload<T extends TrimestreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrimestreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrimestreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrimestreGroupByOutputType[P]>
            : GetScalarType<T[P], TrimestreGroupByOutputType[P]>
        }
      >
    >


  export type TrimestreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    note_inter?: boolean | Trimestre$note_interArgs<ExtArgs>
    note_devoir?: boolean | Trimestre$note_devoirArgs<ExtArgs>
    rang?: boolean | Trimestre$rangArgs<ExtArgs>
    commenstaire?: boolean | Trimestre$commenstaireArgs<ExtArgs>
    _count?: boolean | TrimestreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trimestre"]>


  export type TrimestreSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
  }

  export type TrimestreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    note_inter?: boolean | Trimestre$note_interArgs<ExtArgs>
    note_devoir?: boolean | Trimestre$note_devoirArgs<ExtArgs>
    rang?: boolean | Trimestre$rangArgs<ExtArgs>
    commenstaire?: boolean | Trimestre$commenstaireArgs<ExtArgs>
    _count?: boolean | TrimestreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TrimestrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trimestre"
    objects: {
      note_inter: Prisma.$Note_interPayload<ExtArgs>[]
      note_devoir: Prisma.$Note_devoirPayload<ExtArgs>[]
      rang: Prisma.$RangPayload<ExtArgs>[]
      commenstaire: Prisma.$CommentairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
    }, ExtArgs["result"]["trimestre"]>
    composites: {}
  }

  type TrimestreGetPayload<S extends boolean | null | undefined | TrimestreDefaultArgs> = $Result.GetResult<Prisma.$TrimestrePayload, S>

  type TrimestreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrimestreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrimestreCountAggregateInputType | true
    }

  export interface TrimestreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trimestre'], meta: { name: 'Trimestre' } }
    /**
     * Find zero or one Trimestre that matches the filter.
     * @param {TrimestreFindUniqueArgs} args - Arguments to find a Trimestre
     * @example
     * // Get one Trimestre
     * const trimestre = await prisma.trimestre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrimestreFindUniqueArgs>(args: SelectSubset<T, TrimestreFindUniqueArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trimestre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrimestreFindUniqueOrThrowArgs} args - Arguments to find a Trimestre
     * @example
     * // Get one Trimestre
     * const trimestre = await prisma.trimestre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrimestreFindUniqueOrThrowArgs>(args: SelectSubset<T, TrimestreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trimestre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreFindFirstArgs} args - Arguments to find a Trimestre
     * @example
     * // Get one Trimestre
     * const trimestre = await prisma.trimestre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrimestreFindFirstArgs>(args?: SelectSubset<T, TrimestreFindFirstArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trimestre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreFindFirstOrThrowArgs} args - Arguments to find a Trimestre
     * @example
     * // Get one Trimestre
     * const trimestre = await prisma.trimestre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrimestreFindFirstOrThrowArgs>(args?: SelectSubset<T, TrimestreFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trimestres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trimestres
     * const trimestres = await prisma.trimestre.findMany()
     * 
     * // Get first 10 Trimestres
     * const trimestres = await prisma.trimestre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trimestreWithIdOnly = await prisma.trimestre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrimestreFindManyArgs>(args?: SelectSubset<T, TrimestreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trimestre.
     * @param {TrimestreCreateArgs} args - Arguments to create a Trimestre.
     * @example
     * // Create one Trimestre
     * const Trimestre = await prisma.trimestre.create({
     *   data: {
     *     // ... data to create a Trimestre
     *   }
     * })
     * 
     */
    create<T extends TrimestreCreateArgs>(args: SelectSubset<T, TrimestreCreateArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trimestres.
     * @param {TrimestreCreateManyArgs} args - Arguments to create many Trimestres.
     * @example
     * // Create many Trimestres
     * const trimestre = await prisma.trimestre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrimestreCreateManyArgs>(args?: SelectSubset<T, TrimestreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trimestre.
     * @param {TrimestreDeleteArgs} args - Arguments to delete one Trimestre.
     * @example
     * // Delete one Trimestre
     * const Trimestre = await prisma.trimestre.delete({
     *   where: {
     *     // ... filter to delete one Trimestre
     *   }
     * })
     * 
     */
    delete<T extends TrimestreDeleteArgs>(args: SelectSubset<T, TrimestreDeleteArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trimestre.
     * @param {TrimestreUpdateArgs} args - Arguments to update one Trimestre.
     * @example
     * // Update one Trimestre
     * const trimestre = await prisma.trimestre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrimestreUpdateArgs>(args: SelectSubset<T, TrimestreUpdateArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trimestres.
     * @param {TrimestreDeleteManyArgs} args - Arguments to filter Trimestres to delete.
     * @example
     * // Delete a few Trimestres
     * const { count } = await prisma.trimestre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrimestreDeleteManyArgs>(args?: SelectSubset<T, TrimestreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trimestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trimestres
     * const trimestre = await prisma.trimestre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrimestreUpdateManyArgs>(args: SelectSubset<T, TrimestreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trimestre.
     * @param {TrimestreUpsertArgs} args - Arguments to update or create a Trimestre.
     * @example
     * // Update or create a Trimestre
     * const trimestre = await prisma.trimestre.upsert({
     *   create: {
     *     // ... data to create a Trimestre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trimestre we want to update
     *   }
     * })
     */
    upsert<T extends TrimestreUpsertArgs>(args: SelectSubset<T, TrimestreUpsertArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trimestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreCountArgs} args - Arguments to filter Trimestres to count.
     * @example
     * // Count the number of Trimestres
     * const count = await prisma.trimestre.count({
     *   where: {
     *     // ... the filter for the Trimestres we want to count
     *   }
     * })
    **/
    count<T extends TrimestreCountArgs>(
      args?: Subset<T, TrimestreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrimestreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trimestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrimestreAggregateArgs>(args: Subset<T, TrimestreAggregateArgs>): Prisma.PrismaPromise<GetTrimestreAggregateType<T>>

    /**
     * Group by Trimestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrimestreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrimestreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrimestreGroupByArgs['orderBy'] }
        : { orderBy?: TrimestreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrimestreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrimestreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trimestre model
   */
  readonly fields: TrimestreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trimestre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrimestreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    note_inter<T extends Trimestre$note_interArgs<ExtArgs> = {}>(args?: Subset<T, Trimestre$note_interArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findMany"> | Null>
    note_devoir<T extends Trimestre$note_devoirArgs<ExtArgs> = {}>(args?: Subset<T, Trimestre$note_devoirArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findMany"> | Null>
    rang<T extends Trimestre$rangArgs<ExtArgs> = {}>(args?: Subset<T, Trimestre$rangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangPayload<ExtArgs>, T, "findMany"> | Null>
    commenstaire<T extends Trimestre$commenstaireArgs<ExtArgs> = {}>(args?: Subset<T, Trimestre$commenstaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trimestre model
   */ 
  interface TrimestreFieldRefs {
    readonly id: FieldRef<"Trimestre", 'Int'>
    readonly createdAt: FieldRef<"Trimestre", 'DateTime'>
    readonly updatedAt: FieldRef<"Trimestre", 'DateTime'>
    readonly nom: FieldRef<"Trimestre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trimestre findUnique
   */
  export type TrimestreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Trimestre to fetch.
     */
    where: TrimestreWhereUniqueInput
  }

  /**
   * Trimestre findUniqueOrThrow
   */
  export type TrimestreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Trimestre to fetch.
     */
    where: TrimestreWhereUniqueInput
  }

  /**
   * Trimestre findFirst
   */
  export type TrimestreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Trimestre to fetch.
     */
    where?: TrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trimestres to fetch.
     */
    orderBy?: TrimestreOrderByWithRelationInput | TrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trimestres.
     */
    cursor?: TrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trimestres.
     */
    distinct?: TrimestreScalarFieldEnum | TrimestreScalarFieldEnum[]
  }

  /**
   * Trimestre findFirstOrThrow
   */
  export type TrimestreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Trimestre to fetch.
     */
    where?: TrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trimestres to fetch.
     */
    orderBy?: TrimestreOrderByWithRelationInput | TrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trimestres.
     */
    cursor?: TrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trimestres.
     */
    distinct?: TrimestreScalarFieldEnum | TrimestreScalarFieldEnum[]
  }

  /**
   * Trimestre findMany
   */
  export type TrimestreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Trimestres to fetch.
     */
    where?: TrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trimestres to fetch.
     */
    orderBy?: TrimestreOrderByWithRelationInput | TrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trimestres.
     */
    cursor?: TrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trimestres.
     */
    skip?: number
    distinct?: TrimestreScalarFieldEnum | TrimestreScalarFieldEnum[]
  }

  /**
   * Trimestre create
   */
  export type TrimestreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * The data needed to create a Trimestre.
     */
    data: XOR<TrimestreCreateInput, TrimestreUncheckedCreateInput>
  }

  /**
   * Trimestre createMany
   */
  export type TrimestreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trimestres.
     */
    data: TrimestreCreateManyInput | TrimestreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trimestre update
   */
  export type TrimestreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * The data needed to update a Trimestre.
     */
    data: XOR<TrimestreUpdateInput, TrimestreUncheckedUpdateInput>
    /**
     * Choose, which Trimestre to update.
     */
    where: TrimestreWhereUniqueInput
  }

  /**
   * Trimestre updateMany
   */
  export type TrimestreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trimestres.
     */
    data: XOR<TrimestreUpdateManyMutationInput, TrimestreUncheckedUpdateManyInput>
    /**
     * Filter which Trimestres to update
     */
    where?: TrimestreWhereInput
  }

  /**
   * Trimestre upsert
   */
  export type TrimestreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * The filter to search for the Trimestre to update in case it exists.
     */
    where: TrimestreWhereUniqueInput
    /**
     * In case the Trimestre found by the `where` argument doesn't exist, create a new Trimestre with this data.
     */
    create: XOR<TrimestreCreateInput, TrimestreUncheckedCreateInput>
    /**
     * In case the Trimestre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrimestreUpdateInput, TrimestreUncheckedUpdateInput>
  }

  /**
   * Trimestre delete
   */
  export type TrimestreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
    /**
     * Filter which Trimestre to delete.
     */
    where: TrimestreWhereUniqueInput
  }

  /**
   * Trimestre deleteMany
   */
  export type TrimestreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trimestres to delete
     */
    where?: TrimestreWhereInput
  }

  /**
   * Trimestre.note_inter
   */
  export type Trimestre$note_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    where?: Note_interWhereInput
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    cursor?: Note_interWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Trimestre.note_devoir
   */
  export type Trimestre$note_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    where?: Note_devoirWhereInput
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    cursor?: Note_devoirWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Trimestre.rang
   */
  export type Trimestre$rangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rang
     */
    select?: RangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangInclude<ExtArgs> | null
    where?: RangWhereInput
    orderBy?: RangOrderByWithRelationInput | RangOrderByWithRelationInput[]
    cursor?: RangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RangScalarFieldEnum | RangScalarFieldEnum[]
  }

  /**
   * Trimestre.commenstaire
   */
  export type Trimestre$commenstaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: CommentaireOrderByWithRelationInput | CommentaireOrderByWithRelationInput[]
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentaireScalarFieldEnum | CommentaireScalarFieldEnum[]
  }

  /**
   * Trimestre without action
   */
  export type TrimestreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trimestre
     */
    select?: TrimestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrimestreInclude<ExtArgs> | null
  }


  /**
   * Model Note_inter
   */

  export type AggregateNote_inter = {
    _count: Note_interCountAggregateOutputType | null
    _avg: Note_interAvgAggregateOutputType | null
    _sum: Note_interSumAggregateOutputType | null
    _min: Note_interMinAggregateOutputType | null
    _max: Note_interMaxAggregateOutputType | null
  }

  export type Note_interAvgAggregateOutputType = {
    id: number | null
    inter: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type Note_interSumAggregateOutputType = {
    id: number | null
    inter: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type Note_interMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    inter: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type Note_interMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    inter: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type Note_interCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: number
    _all: number
  }


  export type Note_interAvgAggregateInputType = {
    id?: true
    inter?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type Note_interSumAggregateInputType = {
    id?: true
    inter?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type Note_interMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    inter?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type Note_interMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    inter?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type Note_interCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    inter?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
    _all?: true
  }

  export type Note_interAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note_inter to aggregate.
     */
    where?: Note_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_inters to fetch.
     */
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Note_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Note_inters
    **/
    _count?: true | Note_interCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Note_interAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Note_interSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Note_interMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Note_interMaxAggregateInputType
  }

  export type GetNote_interAggregateType<T extends Note_interAggregateArgs> = {
        [P in keyof T & keyof AggregateNote_inter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote_inter[P]>
      : GetScalarType<T[P], AggregateNote_inter[P]>
  }




  export type Note_interGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_interWhereInput
    orderBy?: Note_interOrderByWithAggregationInput | Note_interOrderByWithAggregationInput[]
    by: Note_interScalarFieldEnum[] | Note_interScalarFieldEnum
    having?: Note_interScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Note_interCountAggregateInputType | true
    _avg?: Note_interAvgAggregateInputType
    _sum?: Note_interSumAggregateInputType
    _min?: Note_interMinAggregateInputType
    _max?: Note_interMaxAggregateInputType
  }

  export type Note_interGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: boolean
    _count: Note_interCountAggregateOutputType | null
    _avg: Note_interAvgAggregateOutputType | null
    _sum: Note_interSumAggregateOutputType | null
    _min: Note_interMinAggregateOutputType | null
    _max: Note_interMaxAggregateOutputType | null
  }

  type GetNote_interGroupByPayload<T extends Note_interGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Note_interGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Note_interGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Note_interGroupByOutputType[P]>
            : GetScalarType<T[P], Note_interGroupByOutputType[P]>
        }
      >
    >


  export type Note_interSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inter?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note_inter"]>


  export type Note_interSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inter?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
  }

  export type Note_interInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }

  export type $Note_interPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note_inter"
    objects: {
      eleve: Prisma.$ElevePayload<ExtArgs>
      enseignant: Prisma.$EnseignantPayload<ExtArgs>
      matiere: Prisma.$MatierePayload<ExtArgs>
      trimestre: Prisma.$TrimestrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      inter: number
      id_eleve: number
      id_enseignant: number
      id_matiere: number
      id_trimestre: number
      vu: boolean
    }, ExtArgs["result"]["note_inter"]>
    composites: {}
  }

  type Note_interGetPayload<S extends boolean | null | undefined | Note_interDefaultArgs> = $Result.GetResult<Prisma.$Note_interPayload, S>

  type Note_interCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Note_interFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Note_interCountAggregateInputType | true
    }

  export interface Note_interDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note_inter'], meta: { name: 'Note_inter' } }
    /**
     * Find zero or one Note_inter that matches the filter.
     * @param {Note_interFindUniqueArgs} args - Arguments to find a Note_inter
     * @example
     * // Get one Note_inter
     * const note_inter = await prisma.note_inter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Note_interFindUniqueArgs>(args: SelectSubset<T, Note_interFindUniqueArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note_inter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Note_interFindUniqueOrThrowArgs} args - Arguments to find a Note_inter
     * @example
     * // Get one Note_inter
     * const note_inter = await prisma.note_inter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Note_interFindUniqueOrThrowArgs>(args: SelectSubset<T, Note_interFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note_inter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interFindFirstArgs} args - Arguments to find a Note_inter
     * @example
     * // Get one Note_inter
     * const note_inter = await prisma.note_inter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Note_interFindFirstArgs>(args?: SelectSubset<T, Note_interFindFirstArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note_inter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interFindFirstOrThrowArgs} args - Arguments to find a Note_inter
     * @example
     * // Get one Note_inter
     * const note_inter = await prisma.note_inter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Note_interFindFirstOrThrowArgs>(args?: SelectSubset<T, Note_interFindFirstOrThrowArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Note_inters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Note_inters
     * const note_inters = await prisma.note_inter.findMany()
     * 
     * // Get first 10 Note_inters
     * const note_inters = await prisma.note_inter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const note_interWithIdOnly = await prisma.note_inter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Note_interFindManyArgs>(args?: SelectSubset<T, Note_interFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note_inter.
     * @param {Note_interCreateArgs} args - Arguments to create a Note_inter.
     * @example
     * // Create one Note_inter
     * const Note_inter = await prisma.note_inter.create({
     *   data: {
     *     // ... data to create a Note_inter
     *   }
     * })
     * 
     */
    create<T extends Note_interCreateArgs>(args: SelectSubset<T, Note_interCreateArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Note_inters.
     * @param {Note_interCreateManyArgs} args - Arguments to create many Note_inters.
     * @example
     * // Create many Note_inters
     * const note_inter = await prisma.note_inter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Note_interCreateManyArgs>(args?: SelectSubset<T, Note_interCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note_inter.
     * @param {Note_interDeleteArgs} args - Arguments to delete one Note_inter.
     * @example
     * // Delete one Note_inter
     * const Note_inter = await prisma.note_inter.delete({
     *   where: {
     *     // ... filter to delete one Note_inter
     *   }
     * })
     * 
     */
    delete<T extends Note_interDeleteArgs>(args: SelectSubset<T, Note_interDeleteArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note_inter.
     * @param {Note_interUpdateArgs} args - Arguments to update one Note_inter.
     * @example
     * // Update one Note_inter
     * const note_inter = await prisma.note_inter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Note_interUpdateArgs>(args: SelectSubset<T, Note_interUpdateArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Note_inters.
     * @param {Note_interDeleteManyArgs} args - Arguments to filter Note_inters to delete.
     * @example
     * // Delete a few Note_inters
     * const { count } = await prisma.note_inter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Note_interDeleteManyArgs>(args?: SelectSubset<T, Note_interDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Note_inters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Note_inters
     * const note_inter = await prisma.note_inter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Note_interUpdateManyArgs>(args: SelectSubset<T, Note_interUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note_inter.
     * @param {Note_interUpsertArgs} args - Arguments to update or create a Note_inter.
     * @example
     * // Update or create a Note_inter
     * const note_inter = await prisma.note_inter.upsert({
     *   create: {
     *     // ... data to create a Note_inter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note_inter we want to update
     *   }
     * })
     */
    upsert<T extends Note_interUpsertArgs>(args: SelectSubset<T, Note_interUpsertArgs<ExtArgs>>): Prisma__Note_interClient<$Result.GetResult<Prisma.$Note_interPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Note_inters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interCountArgs} args - Arguments to filter Note_inters to count.
     * @example
     * // Count the number of Note_inters
     * const count = await prisma.note_inter.count({
     *   where: {
     *     // ... the filter for the Note_inters we want to count
     *   }
     * })
    **/
    count<T extends Note_interCountArgs>(
      args?: Subset<T, Note_interCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Note_interCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note_inter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Note_interAggregateArgs>(args: Subset<T, Note_interAggregateArgs>): Prisma.PrismaPromise<GetNote_interAggregateType<T>>

    /**
     * Group by Note_inter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_interGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Note_interGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Note_interGroupByArgs['orderBy'] }
        : { orderBy?: Note_interGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Note_interGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNote_interGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note_inter model
   */
  readonly fields: Note_interFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note_inter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Note_interClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eleve<T extends EleveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EleveDefaultArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enseignant<T extends EnseignantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseignantDefaultArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trimestre<T extends TrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrimestreDefaultArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note_inter model
   */ 
  interface Note_interFieldRefs {
    readonly id: FieldRef<"Note_inter", 'Int'>
    readonly createdAt: FieldRef<"Note_inter", 'DateTime'>
    readonly updatedAt: FieldRef<"Note_inter", 'DateTime'>
    readonly inter: FieldRef<"Note_inter", 'Float'>
    readonly id_eleve: FieldRef<"Note_inter", 'Int'>
    readonly id_enseignant: FieldRef<"Note_inter", 'Int'>
    readonly id_matiere: FieldRef<"Note_inter", 'Int'>
    readonly id_trimestre: FieldRef<"Note_inter", 'Int'>
    readonly vu: FieldRef<"Note_inter", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Note_inter findUnique
   */
  export type Note_interFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter, which Note_inter to fetch.
     */
    where: Note_interWhereUniqueInput
  }

  /**
   * Note_inter findUniqueOrThrow
   */
  export type Note_interFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter, which Note_inter to fetch.
     */
    where: Note_interWhereUniqueInput
  }

  /**
   * Note_inter findFirst
   */
  export type Note_interFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter, which Note_inter to fetch.
     */
    where?: Note_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_inters to fetch.
     */
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Note_inters.
     */
    cursor?: Note_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Note_inters.
     */
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Note_inter findFirstOrThrow
   */
  export type Note_interFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter, which Note_inter to fetch.
     */
    where?: Note_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_inters to fetch.
     */
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Note_inters.
     */
    cursor?: Note_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Note_inters.
     */
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Note_inter findMany
   */
  export type Note_interFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter, which Note_inters to fetch.
     */
    where?: Note_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_inters to fetch.
     */
    orderBy?: Note_interOrderByWithRelationInput | Note_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Note_inters.
     */
    cursor?: Note_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_inters.
     */
    skip?: number
    distinct?: Note_interScalarFieldEnum | Note_interScalarFieldEnum[]
  }

  /**
   * Note_inter create
   */
  export type Note_interCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * The data needed to create a Note_inter.
     */
    data: XOR<Note_interCreateInput, Note_interUncheckedCreateInput>
  }

  /**
   * Note_inter createMany
   */
  export type Note_interCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Note_inters.
     */
    data: Note_interCreateManyInput | Note_interCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note_inter update
   */
  export type Note_interUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * The data needed to update a Note_inter.
     */
    data: XOR<Note_interUpdateInput, Note_interUncheckedUpdateInput>
    /**
     * Choose, which Note_inter to update.
     */
    where: Note_interWhereUniqueInput
  }

  /**
   * Note_inter updateMany
   */
  export type Note_interUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Note_inters.
     */
    data: XOR<Note_interUpdateManyMutationInput, Note_interUncheckedUpdateManyInput>
    /**
     * Filter which Note_inters to update
     */
    where?: Note_interWhereInput
  }

  /**
   * Note_inter upsert
   */
  export type Note_interUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * The filter to search for the Note_inter to update in case it exists.
     */
    where: Note_interWhereUniqueInput
    /**
     * In case the Note_inter found by the `where` argument doesn't exist, create a new Note_inter with this data.
     */
    create: XOR<Note_interCreateInput, Note_interUncheckedCreateInput>
    /**
     * In case the Note_inter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Note_interUpdateInput, Note_interUncheckedUpdateInput>
  }

  /**
   * Note_inter delete
   */
  export type Note_interDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
    /**
     * Filter which Note_inter to delete.
     */
    where: Note_interWhereUniqueInput
  }

  /**
   * Note_inter deleteMany
   */
  export type Note_interDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note_inters to delete
     */
    where?: Note_interWhereInput
  }

  /**
   * Note_inter without action
   */
  export type Note_interDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_inter
     */
    select?: Note_interSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_interInclude<ExtArgs> | null
  }


  /**
   * Model Note_devoir
   */

  export type AggregateNote_devoir = {
    _count: Note_devoirCountAggregateOutputType | null
    _avg: Note_devoirAvgAggregateOutputType | null
    _sum: Note_devoirSumAggregateOutputType | null
    _min: Note_devoirMinAggregateOutputType | null
    _max: Note_devoirMaxAggregateOutputType | null
  }

  export type Note_devoirAvgAggregateOutputType = {
    id: number | null
    devoir: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type Note_devoirSumAggregateOutputType = {
    id: number | null
    devoir: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
  }

  export type Note_devoirMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    devoir: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type Note_devoirMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    devoir: number | null
    id_eleve: number | null
    id_enseignant: number | null
    id_matiere: number | null
    id_trimestre: number | null
    vu: boolean | null
  }

  export type Note_devoirCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: number
    _all: number
  }


  export type Note_devoirAvgAggregateInputType = {
    id?: true
    devoir?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type Note_devoirSumAggregateInputType = {
    id?: true
    devoir?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
  }

  export type Note_devoirMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    devoir?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type Note_devoirMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    devoir?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
  }

  export type Note_devoirCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    devoir?: true
    id_eleve?: true
    id_enseignant?: true
    id_matiere?: true
    id_trimestre?: true
    vu?: true
    _all?: true
  }

  export type Note_devoirAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note_devoir to aggregate.
     */
    where?: Note_devoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_devoirs to fetch.
     */
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Note_devoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_devoirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_devoirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Note_devoirs
    **/
    _count?: true | Note_devoirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Note_devoirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Note_devoirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Note_devoirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Note_devoirMaxAggregateInputType
  }

  export type GetNote_devoirAggregateType<T extends Note_devoirAggregateArgs> = {
        [P in keyof T & keyof AggregateNote_devoir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote_devoir[P]>
      : GetScalarType<T[P], AggregateNote_devoir[P]>
  }




  export type Note_devoirGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Note_devoirWhereInput
    orderBy?: Note_devoirOrderByWithAggregationInput | Note_devoirOrderByWithAggregationInput[]
    by: Note_devoirScalarFieldEnum[] | Note_devoirScalarFieldEnum
    having?: Note_devoirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Note_devoirCountAggregateInputType | true
    _avg?: Note_devoirAvgAggregateInputType
    _sum?: Note_devoirSumAggregateInputType
    _min?: Note_devoirMinAggregateInputType
    _max?: Note_devoirMaxAggregateInputType
  }

  export type Note_devoirGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu: boolean
    _count: Note_devoirCountAggregateOutputType | null
    _avg: Note_devoirAvgAggregateOutputType | null
    _sum: Note_devoirSumAggregateOutputType | null
    _min: Note_devoirMinAggregateOutputType | null
    _max: Note_devoirMaxAggregateOutputType | null
  }

  type GetNote_devoirGroupByPayload<T extends Note_devoirGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Note_devoirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Note_devoirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Note_devoirGroupByOutputType[P]>
            : GetScalarType<T[P], Note_devoirGroupByOutputType[P]>
        }
      >
    >


  export type Note_devoirSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devoir?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note_devoir"]>


  export type Note_devoirSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devoir?: boolean
    id_eleve?: boolean
    id_enseignant?: boolean
    id_matiere?: boolean
    id_trimestre?: boolean
    vu?: boolean
  }

  export type Note_devoirInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eleve?: boolean | EleveDefaultArgs<ExtArgs>
    enseignant?: boolean | EnseignantDefaultArgs<ExtArgs>
    matiere?: boolean | MatiereDefaultArgs<ExtArgs>
    trimestre?: boolean | TrimestreDefaultArgs<ExtArgs>
  }

  export type $Note_devoirPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note_devoir"
    objects: {
      eleve: Prisma.$ElevePayload<ExtArgs>
      enseignant: Prisma.$EnseignantPayload<ExtArgs>
      matiere: Prisma.$MatierePayload<ExtArgs>
      trimestre: Prisma.$TrimestrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      devoir: number
      id_eleve: number
      id_enseignant: number
      id_matiere: number
      id_trimestre: number
      vu: boolean
    }, ExtArgs["result"]["note_devoir"]>
    composites: {}
  }

  type Note_devoirGetPayload<S extends boolean | null | undefined | Note_devoirDefaultArgs> = $Result.GetResult<Prisma.$Note_devoirPayload, S>

  type Note_devoirCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Note_devoirFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Note_devoirCountAggregateInputType | true
    }

  export interface Note_devoirDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note_devoir'], meta: { name: 'Note_devoir' } }
    /**
     * Find zero or one Note_devoir that matches the filter.
     * @param {Note_devoirFindUniqueArgs} args - Arguments to find a Note_devoir
     * @example
     * // Get one Note_devoir
     * const note_devoir = await prisma.note_devoir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Note_devoirFindUniqueArgs>(args: SelectSubset<T, Note_devoirFindUniqueArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note_devoir that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Note_devoirFindUniqueOrThrowArgs} args - Arguments to find a Note_devoir
     * @example
     * // Get one Note_devoir
     * const note_devoir = await prisma.note_devoir.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Note_devoirFindUniqueOrThrowArgs>(args: SelectSubset<T, Note_devoirFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note_devoir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirFindFirstArgs} args - Arguments to find a Note_devoir
     * @example
     * // Get one Note_devoir
     * const note_devoir = await prisma.note_devoir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Note_devoirFindFirstArgs>(args?: SelectSubset<T, Note_devoirFindFirstArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note_devoir that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirFindFirstOrThrowArgs} args - Arguments to find a Note_devoir
     * @example
     * // Get one Note_devoir
     * const note_devoir = await prisma.note_devoir.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Note_devoirFindFirstOrThrowArgs>(args?: SelectSubset<T, Note_devoirFindFirstOrThrowArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Note_devoirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Note_devoirs
     * const note_devoirs = await prisma.note_devoir.findMany()
     * 
     * // Get first 10 Note_devoirs
     * const note_devoirs = await prisma.note_devoir.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const note_devoirWithIdOnly = await prisma.note_devoir.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Note_devoirFindManyArgs>(args?: SelectSubset<T, Note_devoirFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note_devoir.
     * @param {Note_devoirCreateArgs} args - Arguments to create a Note_devoir.
     * @example
     * // Create one Note_devoir
     * const Note_devoir = await prisma.note_devoir.create({
     *   data: {
     *     // ... data to create a Note_devoir
     *   }
     * })
     * 
     */
    create<T extends Note_devoirCreateArgs>(args: SelectSubset<T, Note_devoirCreateArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Note_devoirs.
     * @param {Note_devoirCreateManyArgs} args - Arguments to create many Note_devoirs.
     * @example
     * // Create many Note_devoirs
     * const note_devoir = await prisma.note_devoir.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Note_devoirCreateManyArgs>(args?: SelectSubset<T, Note_devoirCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note_devoir.
     * @param {Note_devoirDeleteArgs} args - Arguments to delete one Note_devoir.
     * @example
     * // Delete one Note_devoir
     * const Note_devoir = await prisma.note_devoir.delete({
     *   where: {
     *     // ... filter to delete one Note_devoir
     *   }
     * })
     * 
     */
    delete<T extends Note_devoirDeleteArgs>(args: SelectSubset<T, Note_devoirDeleteArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note_devoir.
     * @param {Note_devoirUpdateArgs} args - Arguments to update one Note_devoir.
     * @example
     * // Update one Note_devoir
     * const note_devoir = await prisma.note_devoir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Note_devoirUpdateArgs>(args: SelectSubset<T, Note_devoirUpdateArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Note_devoirs.
     * @param {Note_devoirDeleteManyArgs} args - Arguments to filter Note_devoirs to delete.
     * @example
     * // Delete a few Note_devoirs
     * const { count } = await prisma.note_devoir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Note_devoirDeleteManyArgs>(args?: SelectSubset<T, Note_devoirDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Note_devoirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Note_devoirs
     * const note_devoir = await prisma.note_devoir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Note_devoirUpdateManyArgs>(args: SelectSubset<T, Note_devoirUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note_devoir.
     * @param {Note_devoirUpsertArgs} args - Arguments to update or create a Note_devoir.
     * @example
     * // Update or create a Note_devoir
     * const note_devoir = await prisma.note_devoir.upsert({
     *   create: {
     *     // ... data to create a Note_devoir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note_devoir we want to update
     *   }
     * })
     */
    upsert<T extends Note_devoirUpsertArgs>(args: SelectSubset<T, Note_devoirUpsertArgs<ExtArgs>>): Prisma__Note_devoirClient<$Result.GetResult<Prisma.$Note_devoirPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Note_devoirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirCountArgs} args - Arguments to filter Note_devoirs to count.
     * @example
     * // Count the number of Note_devoirs
     * const count = await prisma.note_devoir.count({
     *   where: {
     *     // ... the filter for the Note_devoirs we want to count
     *   }
     * })
    **/
    count<T extends Note_devoirCountArgs>(
      args?: Subset<T, Note_devoirCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Note_devoirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note_devoir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Note_devoirAggregateArgs>(args: Subset<T, Note_devoirAggregateArgs>): Prisma.PrismaPromise<GetNote_devoirAggregateType<T>>

    /**
     * Group by Note_devoir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Note_devoirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Note_devoirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Note_devoirGroupByArgs['orderBy'] }
        : { orderBy?: Note_devoirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Note_devoirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNote_devoirGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note_devoir model
   */
  readonly fields: Note_devoirFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note_devoir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Note_devoirClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eleve<T extends EleveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EleveDefaultArgs<ExtArgs>>): Prisma__EleveClient<$Result.GetResult<Prisma.$ElevePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enseignant<T extends EnseignantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnseignantDefaultArgs<ExtArgs>>): Prisma__EnseignantClient<$Result.GetResult<Prisma.$EnseignantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matiere<T extends MatiereDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatiereDefaultArgs<ExtArgs>>): Prisma__MatiereClient<$Result.GetResult<Prisma.$MatierePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trimestre<T extends TrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrimestreDefaultArgs<ExtArgs>>): Prisma__TrimestreClient<$Result.GetResult<Prisma.$TrimestrePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note_devoir model
   */ 
  interface Note_devoirFieldRefs {
    readonly id: FieldRef<"Note_devoir", 'Int'>
    readonly createdAt: FieldRef<"Note_devoir", 'DateTime'>
    readonly updatedAt: FieldRef<"Note_devoir", 'DateTime'>
    readonly devoir: FieldRef<"Note_devoir", 'Float'>
    readonly id_eleve: FieldRef<"Note_devoir", 'Int'>
    readonly id_enseignant: FieldRef<"Note_devoir", 'Int'>
    readonly id_matiere: FieldRef<"Note_devoir", 'Int'>
    readonly id_trimestre: FieldRef<"Note_devoir", 'Int'>
    readonly vu: FieldRef<"Note_devoir", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Note_devoir findUnique
   */
  export type Note_devoirFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter, which Note_devoir to fetch.
     */
    where: Note_devoirWhereUniqueInput
  }

  /**
   * Note_devoir findUniqueOrThrow
   */
  export type Note_devoirFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter, which Note_devoir to fetch.
     */
    where: Note_devoirWhereUniqueInput
  }

  /**
   * Note_devoir findFirst
   */
  export type Note_devoirFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter, which Note_devoir to fetch.
     */
    where?: Note_devoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_devoirs to fetch.
     */
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Note_devoirs.
     */
    cursor?: Note_devoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_devoirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_devoirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Note_devoirs.
     */
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Note_devoir findFirstOrThrow
   */
  export type Note_devoirFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter, which Note_devoir to fetch.
     */
    where?: Note_devoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_devoirs to fetch.
     */
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Note_devoirs.
     */
    cursor?: Note_devoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_devoirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_devoirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Note_devoirs.
     */
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Note_devoir findMany
   */
  export type Note_devoirFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter, which Note_devoirs to fetch.
     */
    where?: Note_devoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Note_devoirs to fetch.
     */
    orderBy?: Note_devoirOrderByWithRelationInput | Note_devoirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Note_devoirs.
     */
    cursor?: Note_devoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Note_devoirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Note_devoirs.
     */
    skip?: number
    distinct?: Note_devoirScalarFieldEnum | Note_devoirScalarFieldEnum[]
  }

  /**
   * Note_devoir create
   */
  export type Note_devoirCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * The data needed to create a Note_devoir.
     */
    data: XOR<Note_devoirCreateInput, Note_devoirUncheckedCreateInput>
  }

  /**
   * Note_devoir createMany
   */
  export type Note_devoirCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Note_devoirs.
     */
    data: Note_devoirCreateManyInput | Note_devoirCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note_devoir update
   */
  export type Note_devoirUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * The data needed to update a Note_devoir.
     */
    data: XOR<Note_devoirUpdateInput, Note_devoirUncheckedUpdateInput>
    /**
     * Choose, which Note_devoir to update.
     */
    where: Note_devoirWhereUniqueInput
  }

  /**
   * Note_devoir updateMany
   */
  export type Note_devoirUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Note_devoirs.
     */
    data: XOR<Note_devoirUpdateManyMutationInput, Note_devoirUncheckedUpdateManyInput>
    /**
     * Filter which Note_devoirs to update
     */
    where?: Note_devoirWhereInput
  }

  /**
   * Note_devoir upsert
   */
  export type Note_devoirUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * The filter to search for the Note_devoir to update in case it exists.
     */
    where: Note_devoirWhereUniqueInput
    /**
     * In case the Note_devoir found by the `where` argument doesn't exist, create a new Note_devoir with this data.
     */
    create: XOR<Note_devoirCreateInput, Note_devoirUncheckedCreateInput>
    /**
     * In case the Note_devoir was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Note_devoirUpdateInput, Note_devoirUncheckedUpdateInput>
  }

  /**
   * Note_devoir delete
   */
  export type Note_devoirDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
    /**
     * Filter which Note_devoir to delete.
     */
    where: Note_devoirWhereUniqueInput
  }

  /**
   * Note_devoir deleteMany
   */
  export type Note_devoirDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note_devoirs to delete
     */
    where?: Note_devoirWhereInput
  }

  /**
   * Note_devoir without action
   */
  export type Note_devoirDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note_devoir
     */
    select?: Note_devoirSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Note_devoirInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    prenom: number
    email: number
    photo: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    prenom: string
    email: string | null
    photo: Buffer | null
    username: string
    password: string
    role: string
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["admin"]>


  export type AdminSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      prenom: string
      email: string | null
      photo: Buffer | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly nom: FieldRef<"Admin", 'String'>
    readonly prenom: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly photo: FieldRef<"Admin", 'Bytes'>
    readonly username: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }


  /**
   * Model Directeur
   */

  export type AggregateDirecteur = {
    _count: DirecteurCountAggregateOutputType | null
    _avg: DirecteurAvgAggregateOutputType | null
    _sum: DirecteurSumAggregateOutputType | null
    _min: DirecteurMinAggregateOutputType | null
    _max: DirecteurMaxAggregateOutputType | null
  }

  export type DirecteurAvgAggregateOutputType = {
    id: number | null
  }

  export type DirecteurSumAggregateOutputType = {
    id: number | null
  }

  export type DirecteurMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type DirecteurMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nom: string | null
    prenom: string | null
    email: string | null
    photo: Buffer | null
    username: string | null
    password: string | null
    role: string | null
  }

  export type DirecteurCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nom: number
    prenom: number
    email: number
    photo: number
    username: number
    password: number
    role: number
    _all: number
  }


  export type DirecteurAvgAggregateInputType = {
    id?: true
  }

  export type DirecteurSumAggregateInputType = {
    id?: true
  }

  export type DirecteurMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type DirecteurMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
  }

  export type DirecteurCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nom?: true
    prenom?: true
    email?: true
    photo?: true
    username?: true
    password?: true
    role?: true
    _all?: true
  }

  export type DirecteurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Directeur to aggregate.
     */
    where?: DirecteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directeurs to fetch.
     */
    orderBy?: DirecteurOrderByWithRelationInput | DirecteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirecteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Directeurs
    **/
    _count?: true | DirecteurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirecteurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirecteurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirecteurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirecteurMaxAggregateInputType
  }

  export type GetDirecteurAggregateType<T extends DirecteurAggregateArgs> = {
        [P in keyof T & keyof AggregateDirecteur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirecteur[P]>
      : GetScalarType<T[P], AggregateDirecteur[P]>
  }




  export type DirecteurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirecteurWhereInput
    orderBy?: DirecteurOrderByWithAggregationInput | DirecteurOrderByWithAggregationInput[]
    by: DirecteurScalarFieldEnum[] | DirecteurScalarFieldEnum
    having?: DirecteurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirecteurCountAggregateInputType | true
    _avg?: DirecteurAvgAggregateInputType
    _sum?: DirecteurSumAggregateInputType
    _min?: DirecteurMinAggregateInputType
    _max?: DirecteurMaxAggregateInputType
  }

  export type DirecteurGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nom: string
    prenom: string
    email: string | null
    photo: Buffer | null
    username: string
    password: string
    role: string
    _count: DirecteurCountAggregateOutputType | null
    _avg: DirecteurAvgAggregateOutputType | null
    _sum: DirecteurSumAggregateOutputType | null
    _min: DirecteurMinAggregateOutputType | null
    _max: DirecteurMaxAggregateOutputType | null
  }

  type GetDirecteurGroupByPayload<T extends DirecteurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirecteurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirecteurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirecteurGroupByOutputType[P]>
            : GetScalarType<T[P], DirecteurGroupByOutputType[P]>
        }
      >
    >


  export type DirecteurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["directeur"]>


  export type DirecteurSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    photo?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
  }


  export type $DirecteurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Directeur"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nom: string
      prenom: string
      email: string | null
      photo: Buffer | null
      username: string
      password: string
      role: string
    }, ExtArgs["result"]["directeur"]>
    composites: {}
  }

  type DirecteurGetPayload<S extends boolean | null | undefined | DirecteurDefaultArgs> = $Result.GetResult<Prisma.$DirecteurPayload, S>

  type DirecteurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DirecteurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DirecteurCountAggregateInputType | true
    }

  export interface DirecteurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Directeur'], meta: { name: 'Directeur' } }
    /**
     * Find zero or one Directeur that matches the filter.
     * @param {DirecteurFindUniqueArgs} args - Arguments to find a Directeur
     * @example
     * // Get one Directeur
     * const directeur = await prisma.directeur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirecteurFindUniqueArgs>(args: SelectSubset<T, DirecteurFindUniqueArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Directeur that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DirecteurFindUniqueOrThrowArgs} args - Arguments to find a Directeur
     * @example
     * // Get one Directeur
     * const directeur = await prisma.directeur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirecteurFindUniqueOrThrowArgs>(args: SelectSubset<T, DirecteurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Directeur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurFindFirstArgs} args - Arguments to find a Directeur
     * @example
     * // Get one Directeur
     * const directeur = await prisma.directeur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirecteurFindFirstArgs>(args?: SelectSubset<T, DirecteurFindFirstArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Directeur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurFindFirstOrThrowArgs} args - Arguments to find a Directeur
     * @example
     * // Get one Directeur
     * const directeur = await prisma.directeur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirecteurFindFirstOrThrowArgs>(args?: SelectSubset<T, DirecteurFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Directeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Directeurs
     * const directeurs = await prisma.directeur.findMany()
     * 
     * // Get first 10 Directeurs
     * const directeurs = await prisma.directeur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directeurWithIdOnly = await prisma.directeur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirecteurFindManyArgs>(args?: SelectSubset<T, DirecteurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Directeur.
     * @param {DirecteurCreateArgs} args - Arguments to create a Directeur.
     * @example
     * // Create one Directeur
     * const Directeur = await prisma.directeur.create({
     *   data: {
     *     // ... data to create a Directeur
     *   }
     * })
     * 
     */
    create<T extends DirecteurCreateArgs>(args: SelectSubset<T, DirecteurCreateArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Directeurs.
     * @param {DirecteurCreateManyArgs} args - Arguments to create many Directeurs.
     * @example
     * // Create many Directeurs
     * const directeur = await prisma.directeur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirecteurCreateManyArgs>(args?: SelectSubset<T, DirecteurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Directeur.
     * @param {DirecteurDeleteArgs} args - Arguments to delete one Directeur.
     * @example
     * // Delete one Directeur
     * const Directeur = await prisma.directeur.delete({
     *   where: {
     *     // ... filter to delete one Directeur
     *   }
     * })
     * 
     */
    delete<T extends DirecteurDeleteArgs>(args: SelectSubset<T, DirecteurDeleteArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Directeur.
     * @param {DirecteurUpdateArgs} args - Arguments to update one Directeur.
     * @example
     * // Update one Directeur
     * const directeur = await prisma.directeur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirecteurUpdateArgs>(args: SelectSubset<T, DirecteurUpdateArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Directeurs.
     * @param {DirecteurDeleteManyArgs} args - Arguments to filter Directeurs to delete.
     * @example
     * // Delete a few Directeurs
     * const { count } = await prisma.directeur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirecteurDeleteManyArgs>(args?: SelectSubset<T, DirecteurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Directeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Directeurs
     * const directeur = await prisma.directeur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirecteurUpdateManyArgs>(args: SelectSubset<T, DirecteurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Directeur.
     * @param {DirecteurUpsertArgs} args - Arguments to update or create a Directeur.
     * @example
     * // Update or create a Directeur
     * const directeur = await prisma.directeur.upsert({
     *   create: {
     *     // ... data to create a Directeur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Directeur we want to update
     *   }
     * })
     */
    upsert<T extends DirecteurUpsertArgs>(args: SelectSubset<T, DirecteurUpsertArgs<ExtArgs>>): Prisma__DirecteurClient<$Result.GetResult<Prisma.$DirecteurPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Directeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurCountArgs} args - Arguments to filter Directeurs to count.
     * @example
     * // Count the number of Directeurs
     * const count = await prisma.directeur.count({
     *   where: {
     *     // ... the filter for the Directeurs we want to count
     *   }
     * })
    **/
    count<T extends DirecteurCountArgs>(
      args?: Subset<T, DirecteurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirecteurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Directeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirecteurAggregateArgs>(args: Subset<T, DirecteurAggregateArgs>): Prisma.PrismaPromise<GetDirecteurAggregateType<T>>

    /**
     * Group by Directeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecteurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirecteurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirecteurGroupByArgs['orderBy'] }
        : { orderBy?: DirecteurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirecteurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirecteurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Directeur model
   */
  readonly fields: DirecteurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Directeur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirecteurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Directeur model
   */ 
  interface DirecteurFieldRefs {
    readonly id: FieldRef<"Directeur", 'Int'>
    readonly createdAt: FieldRef<"Directeur", 'DateTime'>
    readonly updatedAt: FieldRef<"Directeur", 'DateTime'>
    readonly nom: FieldRef<"Directeur", 'String'>
    readonly prenom: FieldRef<"Directeur", 'String'>
    readonly email: FieldRef<"Directeur", 'String'>
    readonly photo: FieldRef<"Directeur", 'Bytes'>
    readonly username: FieldRef<"Directeur", 'String'>
    readonly password: FieldRef<"Directeur", 'String'>
    readonly role: FieldRef<"Directeur", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Directeur findUnique
   */
  export type DirecteurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter, which Directeur to fetch.
     */
    where: DirecteurWhereUniqueInput
  }

  /**
   * Directeur findUniqueOrThrow
   */
  export type DirecteurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter, which Directeur to fetch.
     */
    where: DirecteurWhereUniqueInput
  }

  /**
   * Directeur findFirst
   */
  export type DirecteurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter, which Directeur to fetch.
     */
    where?: DirecteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directeurs to fetch.
     */
    orderBy?: DirecteurOrderByWithRelationInput | DirecteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Directeurs.
     */
    cursor?: DirecteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Directeurs.
     */
    distinct?: DirecteurScalarFieldEnum | DirecteurScalarFieldEnum[]
  }

  /**
   * Directeur findFirstOrThrow
   */
  export type DirecteurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter, which Directeur to fetch.
     */
    where?: DirecteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directeurs to fetch.
     */
    orderBy?: DirecteurOrderByWithRelationInput | DirecteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Directeurs.
     */
    cursor?: DirecteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Directeurs.
     */
    distinct?: DirecteurScalarFieldEnum | DirecteurScalarFieldEnum[]
  }

  /**
   * Directeur findMany
   */
  export type DirecteurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter, which Directeurs to fetch.
     */
    where?: DirecteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Directeurs to fetch.
     */
    orderBy?: DirecteurOrderByWithRelationInput | DirecteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Directeurs.
     */
    cursor?: DirecteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Directeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Directeurs.
     */
    skip?: number
    distinct?: DirecteurScalarFieldEnum | DirecteurScalarFieldEnum[]
  }

  /**
   * Directeur create
   */
  export type DirecteurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * The data needed to create a Directeur.
     */
    data: XOR<DirecteurCreateInput, DirecteurUncheckedCreateInput>
  }

  /**
   * Directeur createMany
   */
  export type DirecteurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Directeurs.
     */
    data: DirecteurCreateManyInput | DirecteurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Directeur update
   */
  export type DirecteurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * The data needed to update a Directeur.
     */
    data: XOR<DirecteurUpdateInput, DirecteurUncheckedUpdateInput>
    /**
     * Choose, which Directeur to update.
     */
    where: DirecteurWhereUniqueInput
  }

  /**
   * Directeur updateMany
   */
  export type DirecteurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Directeurs.
     */
    data: XOR<DirecteurUpdateManyMutationInput, DirecteurUncheckedUpdateManyInput>
    /**
     * Filter which Directeurs to update
     */
    where?: DirecteurWhereInput
  }

  /**
   * Directeur upsert
   */
  export type DirecteurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * The filter to search for the Directeur to update in case it exists.
     */
    where: DirecteurWhereUniqueInput
    /**
     * In case the Directeur found by the `where` argument doesn't exist, create a new Directeur with this data.
     */
    create: XOR<DirecteurCreateInput, DirecteurUncheckedCreateInput>
    /**
     * In case the Directeur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirecteurUpdateInput, DirecteurUncheckedUpdateInput>
  }

  /**
   * Directeur delete
   */
  export type DirecteurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
    /**
     * Filter which Directeur to delete.
     */
    where: DirecteurWhereUniqueInput
  }

  /**
   * Directeur deleteMany
   */
  export type DirecteurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Directeurs to delete
     */
    where?: DirecteurWhereInput
  }

  /**
   * Directeur without action
   */
  export type DirecteurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Directeur
     */
    select?: DirecteurSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClasseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom'
  };

  export type ClasseScalarFieldEnum = (typeof ClasseScalarFieldEnum)[keyof typeof ClasseScalarFieldEnum]


  export const MatiereScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    matiere: 'matiere',
    id_coefficient: 'id_coefficient'
  };

  export type MatiereScalarFieldEnum = (typeof MatiereScalarFieldEnum)[keyof typeof MatiereScalarFieldEnum]


  export const RangScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rang: 'rang',
    id_matiere: 'id_matiere',
    id_eleve: 'id_eleve',
    id_trimestre: 'id_trimestre'
  };

  export type RangScalarFieldEnum = (typeof RangScalarFieldEnum)[keyof typeof RangScalarFieldEnum]


  export const CoefficientScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    coefficient: 'coefficient'
  };

  export type CoefficientScalarFieldEnum = (typeof CoefficientScalarFieldEnum)[keyof typeof CoefficientScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    prenom: 'prenom',
    contact: 'contact',
    email: 'email',
    photo: 'photo',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const EnseignantScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    prenom: 'prenom',
    contact: 'contact',
    sexe: 'sexe',
    email: 'email',
    photo: 'photo',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type EnseignantScalarFieldEnum = (typeof EnseignantScalarFieldEnum)[keyof typeof EnseignantScalarFieldEnum]


  export const EleveScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    photo: 'photo',
    sexe: 'sexe',
    id_classe: 'id_classe',
    id_parent: 'id_parent',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type EleveScalarFieldEnum = (typeof EleveScalarFieldEnum)[keyof typeof EleveScalarFieldEnum]


  export const CommentaireScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contenu: 'contenu',
    id_eleve: 'id_eleve',
    id_enseignant: 'id_enseignant',
    id_matiere: 'id_matiere',
    id_trimestre: 'id_trimestre',
    vu: 'vu'
  };

  export type CommentaireScalarFieldEnum = (typeof CommentaireScalarFieldEnum)[keyof typeof CommentaireScalarFieldEnum]


  export const PieceJointeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    titre: 'titre',
    piece: 'piece',
    id_classe: 'id_classe',
    id_matiere: 'id_matiere',
    id_enseignant: 'id_enseignant'
  };

  export type PieceJointeScalarFieldEnum = (typeof PieceJointeScalarFieldEnum)[keyof typeof PieceJointeScalarFieldEnum]


  export const Enseignant_ClasseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id_enseignant: 'id_enseignant',
    id_classe: 'id_classe',
    id_matiere: 'id_matiere'
  };

  export type Enseignant_ClasseScalarFieldEnum = (typeof Enseignant_ClasseScalarFieldEnum)[keyof typeof Enseignant_ClasseScalarFieldEnum]


  export const TrimestreScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom'
  };

  export type TrimestreScalarFieldEnum = (typeof TrimestreScalarFieldEnum)[keyof typeof TrimestreScalarFieldEnum]


  export const Note_interScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inter: 'inter',
    id_eleve: 'id_eleve',
    id_enseignant: 'id_enseignant',
    id_matiere: 'id_matiere',
    id_trimestre: 'id_trimestre',
    vu: 'vu'
  };

  export type Note_interScalarFieldEnum = (typeof Note_interScalarFieldEnum)[keyof typeof Note_interScalarFieldEnum]


  export const Note_devoirScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    devoir: 'devoir',
    id_eleve: 'id_eleve',
    id_enseignant: 'id_enseignant',
    id_matiere: 'id_matiere',
    id_trimestre: 'id_trimestre',
    vu: 'vu'
  };

  export type Note_devoirScalarFieldEnum = (typeof Note_devoirScalarFieldEnum)[keyof typeof Note_devoirScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    photo: 'photo',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DirecteurScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    photo: 'photo',
    username: 'username',
    password: 'password',
    role: 'role'
  };

  export type DirecteurScalarFieldEnum = (typeof DirecteurScalarFieldEnum)[keyof typeof DirecteurScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ClasseWhereInput = {
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    id?: IntFilter<"Classe"> | number
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    nom?: StringFilter<"Classe"> | string
    eleves?: EleveListRelationFilter
    enseignant_classe?: Enseignant_ClasseListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }

  export type ClasseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    eleves?: EleveOrderByRelationAggregateInput
    enseignant_classe?: Enseignant_ClasseOrderByRelationAggregateInput
    piecejointe?: PieceJointeOrderByRelationAggregateInput
  }

  export type ClasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClasseWhereInput | ClasseWhereInput[]
    OR?: ClasseWhereInput[]
    NOT?: ClasseWhereInput | ClasseWhereInput[]
    createdAt?: DateTimeFilter<"Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Classe"> | Date | string
    nom?: StringFilter<"Classe"> | string
    eleves?: EleveListRelationFilter
    enseignant_classe?: Enseignant_ClasseListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }, "id">

  export type ClasseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    _count?: ClasseCountOrderByAggregateInput
    _avg?: ClasseAvgOrderByAggregateInput
    _max?: ClasseMaxOrderByAggregateInput
    _min?: ClasseMinOrderByAggregateInput
    _sum?: ClasseSumOrderByAggregateInput
  }

  export type ClasseScalarWhereWithAggregatesInput = {
    AND?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    OR?: ClasseScalarWhereWithAggregatesInput[]
    NOT?: ClasseScalarWhereWithAggregatesInput | ClasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classe"> | Date | string
    nom?: StringWithAggregatesFilter<"Classe"> | string
  }

  export type MatiereWhereInput = {
    AND?: MatiereWhereInput | MatiereWhereInput[]
    OR?: MatiereWhereInput[]
    NOT?: MatiereWhereInput | MatiereWhereInput[]
    id?: IntFilter<"Matiere"> | number
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    matiere?: StringFilter<"Matiere"> | string
    id_coefficient?: IntFilter<"Matiere"> | number
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    coeffient?: XOR<CoefficientRelationFilter, CoefficientWhereInput>
    enseignant_matiere?: Enseignant_ClasseListRelationFilter
    commentaire?: CommentaireListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }

  export type MatiereOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: SortOrder
    id_coefficient?: SortOrder
    note_inter?: Note_interOrderByRelationAggregateInput
    note_devoir?: Note_devoirOrderByRelationAggregateInput
    rang?: RangOrderByRelationAggregateInput
    coeffient?: CoefficientOrderByWithRelationInput
    enseignant_matiere?: Enseignant_ClasseOrderByRelationAggregateInput
    commentaire?: CommentaireOrderByRelationAggregateInput
    piecejointe?: PieceJointeOrderByRelationAggregateInput
  }

  export type MatiereWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatiereWhereInput | MatiereWhereInput[]
    OR?: MatiereWhereInput[]
    NOT?: MatiereWhereInput | MatiereWhereInput[]
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    matiere?: StringFilter<"Matiere"> | string
    id_coefficient?: IntFilter<"Matiere"> | number
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    coeffient?: XOR<CoefficientRelationFilter, CoefficientWhereInput>
    enseignant_matiere?: Enseignant_ClasseListRelationFilter
    commentaire?: CommentaireListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }, "id">

  export type MatiereOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: SortOrder
    id_coefficient?: SortOrder
    _count?: MatiereCountOrderByAggregateInput
    _avg?: MatiereAvgOrderByAggregateInput
    _max?: MatiereMaxOrderByAggregateInput
    _min?: MatiereMinOrderByAggregateInput
    _sum?: MatiereSumOrderByAggregateInput
  }

  export type MatiereScalarWhereWithAggregatesInput = {
    AND?: MatiereScalarWhereWithAggregatesInput | MatiereScalarWhereWithAggregatesInput[]
    OR?: MatiereScalarWhereWithAggregatesInput[]
    NOT?: MatiereScalarWhereWithAggregatesInput | MatiereScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Matiere"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Matiere"> | Date | string
    matiere?: StringWithAggregatesFilter<"Matiere"> | string
    id_coefficient?: IntWithAggregatesFilter<"Matiere"> | number
  }

  export type RangWhereInput = {
    AND?: RangWhereInput | RangWhereInput[]
    OR?: RangWhereInput[]
    NOT?: RangWhereInput | RangWhereInput[]
    id?: IntFilter<"Rang"> | number
    createdAt?: DateTimeFilter<"Rang"> | Date | string
    updatedAt?: DateTimeFilter<"Rang"> | Date | string
    rang?: IntFilter<"Rang"> | number
    id_matiere?: IntFilter<"Rang"> | number
    id_eleve?: IntFilter<"Rang"> | number
    id_trimestre?: IntFilter<"Rang"> | number
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }

  export type RangOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
    matiere?: MatiereOrderByWithRelationInput
    eleve?: EleveOrderByWithRelationInput
    trimestre?: TrimestreOrderByWithRelationInput
  }

  export type RangWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    id_eleve_id_matiere_id_trimestre?: RangId_eleveId_matiereId_trimestreCompoundUniqueInput
    AND?: RangWhereInput | RangWhereInput[]
    OR?: RangWhereInput[]
    NOT?: RangWhereInput | RangWhereInput[]
    createdAt?: DateTimeFilter<"Rang"> | Date | string
    updatedAt?: DateTimeFilter<"Rang"> | Date | string
    rang?: IntFilter<"Rang"> | number
    id_matiere?: IntFilter<"Rang"> | number
    id_eleve?: IntFilter<"Rang"> | number
    id_trimestre?: IntFilter<"Rang"> | number
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }, "id" | "id_eleve_id_matiere_id_trimestre">

  export type RangOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
    _count?: RangCountOrderByAggregateInput
    _avg?: RangAvgOrderByAggregateInput
    _max?: RangMaxOrderByAggregateInput
    _min?: RangMinOrderByAggregateInput
    _sum?: RangSumOrderByAggregateInput
  }

  export type RangScalarWhereWithAggregatesInput = {
    AND?: RangScalarWhereWithAggregatesInput | RangScalarWhereWithAggregatesInput[]
    OR?: RangScalarWhereWithAggregatesInput[]
    NOT?: RangScalarWhereWithAggregatesInput | RangScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rang"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Rang"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rang"> | Date | string
    rang?: IntWithAggregatesFilter<"Rang"> | number
    id_matiere?: IntWithAggregatesFilter<"Rang"> | number
    id_eleve?: IntWithAggregatesFilter<"Rang"> | number
    id_trimestre?: IntWithAggregatesFilter<"Rang"> | number
  }

  export type CoefficientWhereInput = {
    AND?: CoefficientWhereInput | CoefficientWhereInput[]
    OR?: CoefficientWhereInput[]
    NOT?: CoefficientWhereInput | CoefficientWhereInput[]
    id?: IntFilter<"Coefficient"> | number
    createdAt?: DateTimeFilter<"Coefficient"> | Date | string
    updatedAt?: DateTimeFilter<"Coefficient"> | Date | string
    coefficient?: IntFilter<"Coefficient"> | number
    matiere?: MatiereListRelationFilter
  }

  export type CoefficientOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coefficient?: SortOrder
    matiere?: MatiereOrderByRelationAggregateInput
  }

  export type CoefficientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CoefficientWhereInput | CoefficientWhereInput[]
    OR?: CoefficientWhereInput[]
    NOT?: CoefficientWhereInput | CoefficientWhereInput[]
    createdAt?: DateTimeFilter<"Coefficient"> | Date | string
    updatedAt?: DateTimeFilter<"Coefficient"> | Date | string
    coefficient?: IntFilter<"Coefficient"> | number
    matiere?: MatiereListRelationFilter
  }, "id">

  export type CoefficientOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coefficient?: SortOrder
    _count?: CoefficientCountOrderByAggregateInput
    _avg?: CoefficientAvgOrderByAggregateInput
    _max?: CoefficientMaxOrderByAggregateInput
    _min?: CoefficientMinOrderByAggregateInput
    _sum?: CoefficientSumOrderByAggregateInput
  }

  export type CoefficientScalarWhereWithAggregatesInput = {
    AND?: CoefficientScalarWhereWithAggregatesInput | CoefficientScalarWhereWithAggregatesInput[]
    OR?: CoefficientScalarWhereWithAggregatesInput[]
    NOT?: CoefficientScalarWhereWithAggregatesInput | CoefficientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Coefficient"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Coefficient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coefficient"> | Date | string
    coefficient?: IntWithAggregatesFilter<"Coefficient"> | number
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: IntFilter<"Parent"> | number
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    nom?: StringFilter<"Parent"> | string
    prenom?: StringFilter<"Parent"> | string
    contact?: StringFilter<"Parent"> | string
    email?: StringNullableFilter<"Parent"> | string | null
    photo?: BytesNullableFilter<"Parent"> | Buffer | null
    username?: StringFilter<"Parent"> | string
    password?: StringFilter<"Parent"> | string
    role?: StringFilter<"Parent"> | string
    enfants?: EleveListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enfants?: EleveOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    nom?: StringFilter<"Parent"> | string
    prenom?: StringFilter<"Parent"> | string
    contact?: StringFilter<"Parent"> | string
    email?: StringNullableFilter<"Parent"> | string | null
    photo?: BytesNullableFilter<"Parent"> | Buffer | null
    role?: StringFilter<"Parent"> | string
    enfants?: EleveListRelationFilter
  }, "id" | "username" | "password">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _avg?: ParentAvgOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
    _sum?: ParentSumOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    nom?: StringWithAggregatesFilter<"Parent"> | string
    prenom?: StringWithAggregatesFilter<"Parent"> | string
    contact?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    photo?: BytesNullableWithAggregatesFilter<"Parent"> | Buffer | null
    username?: StringWithAggregatesFilter<"Parent"> | string
    password?: StringWithAggregatesFilter<"Parent"> | string
    role?: StringWithAggregatesFilter<"Parent"> | string
  }

  export type EnseignantWhereInput = {
    AND?: EnseignantWhereInput | EnseignantWhereInput[]
    OR?: EnseignantWhereInput[]
    NOT?: EnseignantWhereInput | EnseignantWhereInput[]
    id?: IntFilter<"Enseignant"> | number
    createdAt?: DateTimeFilter<"Enseignant"> | Date | string
    updatedAt?: DateTimeFilter<"Enseignant"> | Date | string
    nom?: StringFilter<"Enseignant"> | string
    prenom?: StringFilter<"Enseignant"> | string
    contact?: StringFilter<"Enseignant"> | string
    sexe?: StringFilter<"Enseignant"> | string
    email?: StringNullableFilter<"Enseignant"> | string | null
    photo?: BytesNullableFilter<"Enseignant"> | Buffer | null
    username?: StringFilter<"Enseignant"> | string
    password?: StringFilter<"Enseignant"> | string
    role?: StringFilter<"Enseignant"> | string
    enseignant_classe?: Enseignant_ClasseListRelationFilter
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    commentaire?: CommentaireListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }

  export type EnseignantOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    sexe?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    enseignant_classe?: Enseignant_ClasseOrderByRelationAggregateInput
    note_inter?: Note_interOrderByRelationAggregateInput
    note_devoir?: Note_devoirOrderByRelationAggregateInput
    commentaire?: CommentaireOrderByRelationAggregateInput
    piecejointe?: PieceJointeOrderByRelationAggregateInput
  }

  export type EnseignantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password?: string
    AND?: EnseignantWhereInput | EnseignantWhereInput[]
    OR?: EnseignantWhereInput[]
    NOT?: EnseignantWhereInput | EnseignantWhereInput[]
    createdAt?: DateTimeFilter<"Enseignant"> | Date | string
    updatedAt?: DateTimeFilter<"Enseignant"> | Date | string
    nom?: StringFilter<"Enseignant"> | string
    prenom?: StringFilter<"Enseignant"> | string
    contact?: StringFilter<"Enseignant"> | string
    sexe?: StringFilter<"Enseignant"> | string
    email?: StringNullableFilter<"Enseignant"> | string | null
    photo?: BytesNullableFilter<"Enseignant"> | Buffer | null
    role?: StringFilter<"Enseignant"> | string
    enseignant_classe?: Enseignant_ClasseListRelationFilter
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    commentaire?: CommentaireListRelationFilter
    piecejointe?: PieceJointeListRelationFilter
  }, "id" | "username" | "password">

  export type EnseignantOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    sexe?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: EnseignantCountOrderByAggregateInput
    _avg?: EnseignantAvgOrderByAggregateInput
    _max?: EnseignantMaxOrderByAggregateInput
    _min?: EnseignantMinOrderByAggregateInput
    _sum?: EnseignantSumOrderByAggregateInput
  }

  export type EnseignantScalarWhereWithAggregatesInput = {
    AND?: EnseignantScalarWhereWithAggregatesInput | EnseignantScalarWhereWithAggregatesInput[]
    OR?: EnseignantScalarWhereWithAggregatesInput[]
    NOT?: EnseignantScalarWhereWithAggregatesInput | EnseignantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enseignant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Enseignant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enseignant"> | Date | string
    nom?: StringWithAggregatesFilter<"Enseignant"> | string
    prenom?: StringWithAggregatesFilter<"Enseignant"> | string
    contact?: StringWithAggregatesFilter<"Enseignant"> | string
    sexe?: StringWithAggregatesFilter<"Enseignant"> | string
    email?: StringNullableWithAggregatesFilter<"Enseignant"> | string | null
    photo?: BytesNullableWithAggregatesFilter<"Enseignant"> | Buffer | null
    username?: StringWithAggregatesFilter<"Enseignant"> | string
    password?: StringWithAggregatesFilter<"Enseignant"> | string
    role?: StringWithAggregatesFilter<"Enseignant"> | string
  }

  export type EleveWhereInput = {
    AND?: EleveWhereInput | EleveWhereInput[]
    OR?: EleveWhereInput[]
    NOT?: EleveWhereInput | EleveWhereInput[]
    id?: IntFilter<"Eleve"> | number
    createdAt?: DateTimeFilter<"Eleve"> | Date | string
    updatedAt?: DateTimeFilter<"Eleve"> | Date | string
    nom?: StringFilter<"Eleve"> | string
    prenom?: StringFilter<"Eleve"> | string
    email?: StringNullableFilter<"Eleve"> | string | null
    photo?: BytesNullableFilter<"Eleve"> | Buffer | null
    sexe?: StringFilter<"Eleve"> | string
    id_classe?: IntFilter<"Eleve"> | number
    id_parent?: IntFilter<"Eleve"> | number
    username?: StringFilter<"Eleve"> | string
    password?: StringFilter<"Eleve"> | string
    role?: StringFilter<"Eleve"> | string
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    commentaire?: CommentaireListRelationFilter
  }

  export type EleveOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    sexe?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    classe?: ClasseOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    note_inter?: Note_interOrderByRelationAggregateInput
    note_devoir?: Note_devoirOrderByRelationAggregateInput
    rang?: RangOrderByRelationAggregateInput
    commentaire?: CommentaireOrderByRelationAggregateInput
  }

  export type EleveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password?: string
    AND?: EleveWhereInput | EleveWhereInput[]
    OR?: EleveWhereInput[]
    NOT?: EleveWhereInput | EleveWhereInput[]
    createdAt?: DateTimeFilter<"Eleve"> | Date | string
    updatedAt?: DateTimeFilter<"Eleve"> | Date | string
    nom?: StringFilter<"Eleve"> | string
    prenom?: StringFilter<"Eleve"> | string
    email?: StringNullableFilter<"Eleve"> | string | null
    photo?: BytesNullableFilter<"Eleve"> | Buffer | null
    sexe?: StringFilter<"Eleve"> | string
    id_classe?: IntFilter<"Eleve"> | number
    id_parent?: IntFilter<"Eleve"> | number
    role?: StringFilter<"Eleve"> | string
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    commentaire?: CommentaireListRelationFilter
  }, "id" | "username" | "password">

  export type EleveOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    sexe?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: EleveCountOrderByAggregateInput
    _avg?: EleveAvgOrderByAggregateInput
    _max?: EleveMaxOrderByAggregateInput
    _min?: EleveMinOrderByAggregateInput
    _sum?: EleveSumOrderByAggregateInput
  }

  export type EleveScalarWhereWithAggregatesInput = {
    AND?: EleveScalarWhereWithAggregatesInput | EleveScalarWhereWithAggregatesInput[]
    OR?: EleveScalarWhereWithAggregatesInput[]
    NOT?: EleveScalarWhereWithAggregatesInput | EleveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Eleve"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Eleve"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Eleve"> | Date | string
    nom?: StringWithAggregatesFilter<"Eleve"> | string
    prenom?: StringWithAggregatesFilter<"Eleve"> | string
    email?: StringNullableWithAggregatesFilter<"Eleve"> | string | null
    photo?: BytesNullableWithAggregatesFilter<"Eleve"> | Buffer | null
    sexe?: StringWithAggregatesFilter<"Eleve"> | string
    id_classe?: IntWithAggregatesFilter<"Eleve"> | number
    id_parent?: IntWithAggregatesFilter<"Eleve"> | number
    username?: StringWithAggregatesFilter<"Eleve"> | string
    password?: StringWithAggregatesFilter<"Eleve"> | string
    role?: StringWithAggregatesFilter<"Eleve"> | string
  }

  export type CommentaireWhereInput = {
    AND?: CommentaireWhereInput | CommentaireWhereInput[]
    OR?: CommentaireWhereInput[]
    NOT?: CommentaireWhereInput | CommentaireWhereInput[]
    id?: IntFilter<"Commentaire"> | number
    createdAt?: DateTimeFilter<"Commentaire"> | Date | string
    updatedAt?: DateTimeFilter<"Commentaire"> | Date | string
    contenu?: StringFilter<"Commentaire"> | string
    id_eleve?: IntFilter<"Commentaire"> | number
    id_enseignant?: IntFilter<"Commentaire"> | number
    id_matiere?: IntFilter<"Commentaire"> | number
    id_trimestre?: IntFilter<"Commentaire"> | number
    vu?: BoolFilter<"Commentaire"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }

  export type CommentaireOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contenu?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    eleve?: EleveOrderByWithRelationInput
    enseignant?: EnseignantOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
    trimestre?: TrimestreOrderByWithRelationInput
  }

  export type CommentaireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentaireWhereInput | CommentaireWhereInput[]
    OR?: CommentaireWhereInput[]
    NOT?: CommentaireWhereInput | CommentaireWhereInput[]
    createdAt?: DateTimeFilter<"Commentaire"> | Date | string
    updatedAt?: DateTimeFilter<"Commentaire"> | Date | string
    contenu?: StringFilter<"Commentaire"> | string
    id_eleve?: IntFilter<"Commentaire"> | number
    id_enseignant?: IntFilter<"Commentaire"> | number
    id_matiere?: IntFilter<"Commentaire"> | number
    id_trimestre?: IntFilter<"Commentaire"> | number
    vu?: BoolFilter<"Commentaire"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }, "id">

  export type CommentaireOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contenu?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    _count?: CommentaireCountOrderByAggregateInput
    _avg?: CommentaireAvgOrderByAggregateInput
    _max?: CommentaireMaxOrderByAggregateInput
    _min?: CommentaireMinOrderByAggregateInput
    _sum?: CommentaireSumOrderByAggregateInput
  }

  export type CommentaireScalarWhereWithAggregatesInput = {
    AND?: CommentaireScalarWhereWithAggregatesInput | CommentaireScalarWhereWithAggregatesInput[]
    OR?: CommentaireScalarWhereWithAggregatesInput[]
    NOT?: CommentaireScalarWhereWithAggregatesInput | CommentaireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commentaire"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Commentaire"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commentaire"> | Date | string
    contenu?: StringWithAggregatesFilter<"Commentaire"> | string
    id_eleve?: IntWithAggregatesFilter<"Commentaire"> | number
    id_enseignant?: IntWithAggregatesFilter<"Commentaire"> | number
    id_matiere?: IntWithAggregatesFilter<"Commentaire"> | number
    id_trimestre?: IntWithAggregatesFilter<"Commentaire"> | number
    vu?: BoolWithAggregatesFilter<"Commentaire"> | boolean
  }

  export type PieceJointeWhereInput = {
    AND?: PieceJointeWhereInput | PieceJointeWhereInput[]
    OR?: PieceJointeWhereInput[]
    NOT?: PieceJointeWhereInput | PieceJointeWhereInput[]
    id?: IntFilter<"PieceJointe"> | number
    createdAt?: DateTimeFilter<"PieceJointe"> | Date | string
    updatedAt?: DateTimeFilter<"PieceJointe"> | Date | string
    titre?: StringFilter<"PieceJointe"> | string
    piece?: BytesFilter<"PieceJointe"> | Buffer
    id_classe?: IntFilter<"PieceJointe"> | number
    id_matiere?: IntFilter<"PieceJointe"> | number
    id_enseignant?: IntFilter<"PieceJointe"> | number
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
  }

  export type PieceJointeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titre?: SortOrder
    piece?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
    classe?: ClasseOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
    enseignant?: EnseignantOrderByWithRelationInput
  }

  export type PieceJointeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PieceJointeWhereInput | PieceJointeWhereInput[]
    OR?: PieceJointeWhereInput[]
    NOT?: PieceJointeWhereInput | PieceJointeWhereInput[]
    createdAt?: DateTimeFilter<"PieceJointe"> | Date | string
    updatedAt?: DateTimeFilter<"PieceJointe"> | Date | string
    titre?: StringFilter<"PieceJointe"> | string
    piece?: BytesFilter<"PieceJointe"> | Buffer
    id_classe?: IntFilter<"PieceJointe"> | number
    id_matiere?: IntFilter<"PieceJointe"> | number
    id_enseignant?: IntFilter<"PieceJointe"> | number
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
  }, "id">

  export type PieceJointeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titre?: SortOrder
    piece?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
    _count?: PieceJointeCountOrderByAggregateInput
    _avg?: PieceJointeAvgOrderByAggregateInput
    _max?: PieceJointeMaxOrderByAggregateInput
    _min?: PieceJointeMinOrderByAggregateInput
    _sum?: PieceJointeSumOrderByAggregateInput
  }

  export type PieceJointeScalarWhereWithAggregatesInput = {
    AND?: PieceJointeScalarWhereWithAggregatesInput | PieceJointeScalarWhereWithAggregatesInput[]
    OR?: PieceJointeScalarWhereWithAggregatesInput[]
    NOT?: PieceJointeScalarWhereWithAggregatesInput | PieceJointeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PieceJointe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PieceJointe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PieceJointe"> | Date | string
    titre?: StringWithAggregatesFilter<"PieceJointe"> | string
    piece?: BytesWithAggregatesFilter<"PieceJointe"> | Buffer
    id_classe?: IntWithAggregatesFilter<"PieceJointe"> | number
    id_matiere?: IntWithAggregatesFilter<"PieceJointe"> | number
    id_enseignant?: IntWithAggregatesFilter<"PieceJointe"> | number
  }

  export type Enseignant_ClasseWhereInput = {
    AND?: Enseignant_ClasseWhereInput | Enseignant_ClasseWhereInput[]
    OR?: Enseignant_ClasseWhereInput[]
    NOT?: Enseignant_ClasseWhereInput | Enseignant_ClasseWhereInput[]
    id?: IntFilter<"Enseignant_Classe"> | number
    createdAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    id_enseignant?: IntFilter<"Enseignant_Classe"> | number
    id_classe?: IntFilter<"Enseignant_Classe"> | number
    id_matiere?: IntFilter<"Enseignant_Classe"> | number
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
  }

  export type Enseignant_ClasseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    enseignant?: EnseignantOrderByWithRelationInput
    classe?: ClasseOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
  }

  export type Enseignant_ClasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enseignant_ClasseWhereInput | Enseignant_ClasseWhereInput[]
    OR?: Enseignant_ClasseWhereInput[]
    NOT?: Enseignant_ClasseWhereInput | Enseignant_ClasseWhereInput[]
    createdAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    id_enseignant?: IntFilter<"Enseignant_Classe"> | number
    id_classe?: IntFilter<"Enseignant_Classe"> | number
    id_matiere?: IntFilter<"Enseignant_Classe"> | number
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    classe?: XOR<ClasseRelationFilter, ClasseWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
  }, "id">

  export type Enseignant_ClasseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    _count?: Enseignant_ClasseCountOrderByAggregateInput
    _avg?: Enseignant_ClasseAvgOrderByAggregateInput
    _max?: Enseignant_ClasseMaxOrderByAggregateInput
    _min?: Enseignant_ClasseMinOrderByAggregateInput
    _sum?: Enseignant_ClasseSumOrderByAggregateInput
  }

  export type Enseignant_ClasseScalarWhereWithAggregatesInput = {
    AND?: Enseignant_ClasseScalarWhereWithAggregatesInput | Enseignant_ClasseScalarWhereWithAggregatesInput[]
    OR?: Enseignant_ClasseScalarWhereWithAggregatesInput[]
    NOT?: Enseignant_ClasseScalarWhereWithAggregatesInput | Enseignant_ClasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enseignant_Classe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Enseignant_Classe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enseignant_Classe"> | Date | string
    id_enseignant?: IntWithAggregatesFilter<"Enseignant_Classe"> | number
    id_classe?: IntWithAggregatesFilter<"Enseignant_Classe"> | number
    id_matiere?: IntWithAggregatesFilter<"Enseignant_Classe"> | number
  }

  export type TrimestreWhereInput = {
    AND?: TrimestreWhereInput | TrimestreWhereInput[]
    OR?: TrimestreWhereInput[]
    NOT?: TrimestreWhereInput | TrimestreWhereInput[]
    id?: IntFilter<"Trimestre"> | number
    createdAt?: DateTimeFilter<"Trimestre"> | Date | string
    updatedAt?: DateTimeFilter<"Trimestre"> | Date | string
    nom?: StringFilter<"Trimestre"> | string
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    commenstaire?: CommentaireListRelationFilter
  }

  export type TrimestreOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    note_inter?: Note_interOrderByRelationAggregateInput
    note_devoir?: Note_devoirOrderByRelationAggregateInput
    rang?: RangOrderByRelationAggregateInput
    commenstaire?: CommentaireOrderByRelationAggregateInput
  }

  export type TrimestreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrimestreWhereInput | TrimestreWhereInput[]
    OR?: TrimestreWhereInput[]
    NOT?: TrimestreWhereInput | TrimestreWhereInput[]
    createdAt?: DateTimeFilter<"Trimestre"> | Date | string
    updatedAt?: DateTimeFilter<"Trimestre"> | Date | string
    nom?: StringFilter<"Trimestre"> | string
    note_inter?: Note_interListRelationFilter
    note_devoir?: Note_devoirListRelationFilter
    rang?: RangListRelationFilter
    commenstaire?: CommentaireListRelationFilter
  }, "id">

  export type TrimestreOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    _count?: TrimestreCountOrderByAggregateInput
    _avg?: TrimestreAvgOrderByAggregateInput
    _max?: TrimestreMaxOrderByAggregateInput
    _min?: TrimestreMinOrderByAggregateInput
    _sum?: TrimestreSumOrderByAggregateInput
  }

  export type TrimestreScalarWhereWithAggregatesInput = {
    AND?: TrimestreScalarWhereWithAggregatesInput | TrimestreScalarWhereWithAggregatesInput[]
    OR?: TrimestreScalarWhereWithAggregatesInput[]
    NOT?: TrimestreScalarWhereWithAggregatesInput | TrimestreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trimestre"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Trimestre"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trimestre"> | Date | string
    nom?: StringWithAggregatesFilter<"Trimestre"> | string
  }

  export type Note_interWhereInput = {
    AND?: Note_interWhereInput | Note_interWhereInput[]
    OR?: Note_interWhereInput[]
    NOT?: Note_interWhereInput | Note_interWhereInput[]
    id?: IntFilter<"Note_inter"> | number
    createdAt?: DateTimeFilter<"Note_inter"> | Date | string
    updatedAt?: DateTimeFilter<"Note_inter"> | Date | string
    inter?: FloatFilter<"Note_inter"> | number
    id_eleve?: IntFilter<"Note_inter"> | number
    id_enseignant?: IntFilter<"Note_inter"> | number
    id_matiere?: IntFilter<"Note_inter"> | number
    id_trimestre?: IntFilter<"Note_inter"> | number
    vu?: BoolFilter<"Note_inter"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }

  export type Note_interOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    eleve?: EleveOrderByWithRelationInput
    enseignant?: EnseignantOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
    trimestre?: TrimestreOrderByWithRelationInput
  }

  export type Note_interWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Note_interWhereInput | Note_interWhereInput[]
    OR?: Note_interWhereInput[]
    NOT?: Note_interWhereInput | Note_interWhereInput[]
    createdAt?: DateTimeFilter<"Note_inter"> | Date | string
    updatedAt?: DateTimeFilter<"Note_inter"> | Date | string
    inter?: FloatFilter<"Note_inter"> | number
    id_eleve?: IntFilter<"Note_inter"> | number
    id_enseignant?: IntFilter<"Note_inter"> | number
    id_matiere?: IntFilter<"Note_inter"> | number
    id_trimestre?: IntFilter<"Note_inter"> | number
    vu?: BoolFilter<"Note_inter"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }, "id">

  export type Note_interOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    _count?: Note_interCountOrderByAggregateInput
    _avg?: Note_interAvgOrderByAggregateInput
    _max?: Note_interMaxOrderByAggregateInput
    _min?: Note_interMinOrderByAggregateInput
    _sum?: Note_interSumOrderByAggregateInput
  }

  export type Note_interScalarWhereWithAggregatesInput = {
    AND?: Note_interScalarWhereWithAggregatesInput | Note_interScalarWhereWithAggregatesInput[]
    OR?: Note_interScalarWhereWithAggregatesInput[]
    NOT?: Note_interScalarWhereWithAggregatesInput | Note_interScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Note_inter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Note_inter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note_inter"> | Date | string
    inter?: FloatWithAggregatesFilter<"Note_inter"> | number
    id_eleve?: IntWithAggregatesFilter<"Note_inter"> | number
    id_enseignant?: IntWithAggregatesFilter<"Note_inter"> | number
    id_matiere?: IntWithAggregatesFilter<"Note_inter"> | number
    id_trimestre?: IntWithAggregatesFilter<"Note_inter"> | number
    vu?: BoolWithAggregatesFilter<"Note_inter"> | boolean
  }

  export type Note_devoirWhereInput = {
    AND?: Note_devoirWhereInput | Note_devoirWhereInput[]
    OR?: Note_devoirWhereInput[]
    NOT?: Note_devoirWhereInput | Note_devoirWhereInput[]
    id?: IntFilter<"Note_devoir"> | number
    createdAt?: DateTimeFilter<"Note_devoir"> | Date | string
    updatedAt?: DateTimeFilter<"Note_devoir"> | Date | string
    devoir?: FloatFilter<"Note_devoir"> | number
    id_eleve?: IntFilter<"Note_devoir"> | number
    id_enseignant?: IntFilter<"Note_devoir"> | number
    id_matiere?: IntFilter<"Note_devoir"> | number
    id_trimestre?: IntFilter<"Note_devoir"> | number
    vu?: BoolFilter<"Note_devoir"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }

  export type Note_devoirOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    eleve?: EleveOrderByWithRelationInput
    enseignant?: EnseignantOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
    trimestre?: TrimestreOrderByWithRelationInput
  }

  export type Note_devoirWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Note_devoirWhereInput | Note_devoirWhereInput[]
    OR?: Note_devoirWhereInput[]
    NOT?: Note_devoirWhereInput | Note_devoirWhereInput[]
    createdAt?: DateTimeFilter<"Note_devoir"> | Date | string
    updatedAt?: DateTimeFilter<"Note_devoir"> | Date | string
    devoir?: FloatFilter<"Note_devoir"> | number
    id_eleve?: IntFilter<"Note_devoir"> | number
    id_enseignant?: IntFilter<"Note_devoir"> | number
    id_matiere?: IntFilter<"Note_devoir"> | number
    id_trimestre?: IntFilter<"Note_devoir"> | number
    vu?: BoolFilter<"Note_devoir"> | boolean
    eleve?: XOR<EleveRelationFilter, EleveWhereInput>
    enseignant?: XOR<EnseignantRelationFilter, EnseignantWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
    trimestre?: XOR<TrimestreRelationFilter, TrimestreWhereInput>
  }, "id">

  export type Note_devoirOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
    _count?: Note_devoirCountOrderByAggregateInput
    _avg?: Note_devoirAvgOrderByAggregateInput
    _max?: Note_devoirMaxOrderByAggregateInput
    _min?: Note_devoirMinOrderByAggregateInput
    _sum?: Note_devoirSumOrderByAggregateInput
  }

  export type Note_devoirScalarWhereWithAggregatesInput = {
    AND?: Note_devoirScalarWhereWithAggregatesInput | Note_devoirScalarWhereWithAggregatesInput[]
    OR?: Note_devoirScalarWhereWithAggregatesInput[]
    NOT?: Note_devoirScalarWhereWithAggregatesInput | Note_devoirScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Note_devoir"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Note_devoir"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note_devoir"> | Date | string
    devoir?: FloatWithAggregatesFilter<"Note_devoir"> | number
    id_eleve?: IntWithAggregatesFilter<"Note_devoir"> | number
    id_enseignant?: IntWithAggregatesFilter<"Note_devoir"> | number
    id_matiere?: IntWithAggregatesFilter<"Note_devoir"> | number
    id_trimestre?: IntWithAggregatesFilter<"Note_devoir"> | number
    vu?: BoolWithAggregatesFilter<"Note_devoir"> | boolean
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    nom?: StringFilter<"Admin"> | string
    prenom?: StringFilter<"Admin"> | string
    email?: StringNullableFilter<"Admin"> | string | null
    photo?: BytesNullableFilter<"Admin"> | Buffer | null
    username?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    nom?: StringFilter<"Admin"> | string
    prenom?: StringFilter<"Admin"> | string
    email?: StringNullableFilter<"Admin"> | string | null
    photo?: BytesNullableFilter<"Admin"> | Buffer | null
    role?: StringFilter<"Admin"> | string
  }, "id" | "username" | "password">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    nom?: StringWithAggregatesFilter<"Admin"> | string
    prenom?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    photo?: BytesNullableWithAggregatesFilter<"Admin"> | Buffer | null
    username?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    role?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type DirecteurWhereInput = {
    AND?: DirecteurWhereInput | DirecteurWhereInput[]
    OR?: DirecteurWhereInput[]
    NOT?: DirecteurWhereInput | DirecteurWhereInput[]
    id?: IntFilter<"Directeur"> | number
    createdAt?: DateTimeFilter<"Directeur"> | Date | string
    updatedAt?: DateTimeFilter<"Directeur"> | Date | string
    nom?: StringFilter<"Directeur"> | string
    prenom?: StringFilter<"Directeur"> | string
    email?: StringNullableFilter<"Directeur"> | string | null
    photo?: BytesNullableFilter<"Directeur"> | Buffer | null
    username?: StringFilter<"Directeur"> | string
    password?: StringFilter<"Directeur"> | string
    role?: StringFilter<"Directeur"> | string
  }

  export type DirecteurOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type DirecteurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password?: string
    AND?: DirecteurWhereInput | DirecteurWhereInput[]
    OR?: DirecteurWhereInput[]
    NOT?: DirecteurWhereInput | DirecteurWhereInput[]
    createdAt?: DateTimeFilter<"Directeur"> | Date | string
    updatedAt?: DateTimeFilter<"Directeur"> | Date | string
    nom?: StringFilter<"Directeur"> | string
    prenom?: StringFilter<"Directeur"> | string
    email?: StringNullableFilter<"Directeur"> | string | null
    photo?: BytesNullableFilter<"Directeur"> | Buffer | null
    role?: StringFilter<"Directeur"> | string
  }, "id" | "username" | "password">

  export type DirecteurOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: DirecteurCountOrderByAggregateInput
    _avg?: DirecteurAvgOrderByAggregateInput
    _max?: DirecteurMaxOrderByAggregateInput
    _min?: DirecteurMinOrderByAggregateInput
    _sum?: DirecteurSumOrderByAggregateInput
  }

  export type DirecteurScalarWhereWithAggregatesInput = {
    AND?: DirecteurScalarWhereWithAggregatesInput | DirecteurScalarWhereWithAggregatesInput[]
    OR?: DirecteurScalarWhereWithAggregatesInput[]
    NOT?: DirecteurScalarWhereWithAggregatesInput | DirecteurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Directeur"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Directeur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Directeur"> | Date | string
    nom?: StringWithAggregatesFilter<"Directeur"> | string
    prenom?: StringWithAggregatesFilter<"Directeur"> | string
    email?: StringNullableWithAggregatesFilter<"Directeur"> | string | null
    photo?: BytesNullableWithAggregatesFilter<"Directeur"> | Buffer | null
    username?: StringWithAggregatesFilter<"Directeur"> | string
    password?: StringWithAggregatesFilter<"Directeur"> | string
    role?: StringWithAggregatesFilter<"Directeur"> | string
  }

  export type ClasseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveCreateNestedManyWithoutClasseInput
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveUncheckedCreateNestedManyWithoutClasseInput
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUpdateManyWithoutClasseNestedInput
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUncheckedUpdateManyWithoutClasseNestedInput
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ClasseCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
  }

  export type ClasseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ClasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type MatiereCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
  }

  export type MatiereUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
  }

  export type MatiereUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
  }

  export type RangCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    matiere: MatiereCreateNestedOneWithoutRangInput
    eleve: EleveCreateNestedOneWithoutRangInput
    trimestre: TrimestreCreateNestedOneWithoutRangInput
  }

  export type RangUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_eleve: number
    id_trimestre: number
  }

  export type RangUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    matiere?: MatiereUpdateOneRequiredWithoutRangNestedInput
    eleve?: EleveUpdateOneRequiredWithoutRangNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutRangNestedInput
  }

  export type RangUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type RangCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_eleve: number
    id_trimestre: number
  }

  export type RangUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
  }

  export type RangUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type CoefficientCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coefficient: number
    matiere?: MatiereCreateNestedManyWithoutCoeffientInput
  }

  export type CoefficientUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coefficient: number
    matiere?: MatiereUncheckedCreateNestedManyWithoutCoeffientInput
  }

  export type CoefficientUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
    matiere?: MatiereUpdateManyWithoutCoeffientNestedInput
  }

  export type CoefficientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
    matiere?: MatiereUncheckedUpdateManyWithoutCoeffientNestedInput
  }

  export type CoefficientCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coefficient: number
  }

  export type CoefficientUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
  }

  export type CoefficientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
  }

  export type ParentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enfants?: EleveCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enfants?: EleveUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enfants?: EleveUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enfants?: EleveUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type ParentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EnseignantCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUncheckedUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type EnseignantUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EnseignantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EleveCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EleveCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
  }

  export type EleveUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EleveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CommentaireCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutCommentaireInput
    enseignant: EnseignantCreateNestedOneWithoutCommentaireInput
    matiere: MatiereCreateNestedOneWithoutCommentaireInput
    trimestre: TrimestreCreateNestedOneWithoutCommenstaireInput
  }

  export type CommentaireUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutCommentaireNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutCommentaireNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutCommentaireNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutCommenstaireNestedInput
  }

  export type CommentaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PieceJointeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    classe: ClasseCreateNestedOneWithoutPiecejointeInput
    matiere: MatiereCreateNestedOneWithoutPiecejointeInput
    enseignant: EnseignantCreateNestedOneWithoutPiecejointeInput
  }

  export type PieceJointeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_matiere: number
    id_enseignant: number
  }

  export type PieceJointeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    classe?: ClasseUpdateOneRequiredWithoutPiecejointeNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutPiecejointeNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutPiecejointeNestedInput
  }

  export type PieceJointeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type PieceJointeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_matiere: number
    id_enseignant: number
  }

  export type PieceJointeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type PieceJointeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    enseignant: EnseignantCreateNestedOneWithoutEnseignant_classeInput
    classe: ClasseCreateNestedOneWithoutEnseignant_classeInput
    matiere: MatiereCreateNestedOneWithoutEnseignant_matiereInput
  }

  export type Enseignant_ClasseUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_classe: number
    id_matiere: number
  }

  export type Enseignant_ClasseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enseignant?: EnseignantUpdateOneRequiredWithoutEnseignant_classeNestedInput
    classe?: ClasseUpdateOneRequiredWithoutEnseignant_classeNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutEnseignant_matiereNestedInput
  }

  export type Enseignant_ClasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_classe: number
    id_matiere: number
  }

  export type Enseignant_ClasseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Enseignant_ClasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type TrimestreCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirCreateNestedManyWithoutTrimestreInput
    rang?: RangCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutTrimestreInput
    rang?: RangUncheckedCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireUncheckedCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutTrimestreNestedInput
    rang?: RangUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutTrimestreNestedInput
    rang?: RangUncheckedUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUncheckedUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
  }

  export type TrimestreUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type TrimestreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type Note_interCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_interInput
    enseignant: EnseignantCreateNestedOneWithoutNote_interInput
    matiere: MatiereCreateNestedOneWithoutNote_interInput
    trimestre: TrimestreCreateNestedOneWithoutNote_interInput
  }

  export type Note_interUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_interNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_interNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_interNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_interNestedInput
  }

  export type Note_interUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_devoirInput
    enseignant: EnseignantCreateNestedOneWithoutNote_devoirInput
    matiere: MatiereCreateNestedOneWithoutNote_devoirInput
    trimestre: TrimestreCreateNestedOneWithoutNote_devoirInput
  }

  export type Note_devoirUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_devoirNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_devoirNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_devoirNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_devoirNestedInput
  }

  export type Note_devoirUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type AdminUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type AdminUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DirecteurCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type DirecteurUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type DirecteurUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DirecteurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DirecteurCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type DirecteurUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type DirecteurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EleveListRelationFilter = {
    every?: EleveWhereInput
    some?: EleveWhereInput
    none?: EleveWhereInput
  }

  export type Enseignant_ClasseListRelationFilter = {
    every?: Enseignant_ClasseWhereInput
    some?: Enseignant_ClasseWhereInput
    none?: Enseignant_ClasseWhereInput
  }

  export type PieceJointeListRelationFilter = {
    every?: PieceJointeWhereInput
    some?: PieceJointeWhereInput
    none?: PieceJointeWhereInput
  }

  export type EleveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Enseignant_ClasseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PieceJointeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClasseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type ClasseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClasseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type ClasseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type ClasseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Note_interListRelationFilter = {
    every?: Note_interWhereInput
    some?: Note_interWhereInput
    none?: Note_interWhereInput
  }

  export type Note_devoirListRelationFilter = {
    every?: Note_devoirWhereInput
    some?: Note_devoirWhereInput
    none?: Note_devoirWhereInput
  }

  export type RangListRelationFilter = {
    every?: RangWhereInput
    some?: RangWhereInput
    none?: RangWhereInput
  }

  export type CoefficientRelationFilter = {
    is?: CoefficientWhereInput
    isNot?: CoefficientWhereInput
  }

  export type CommentaireListRelationFilter = {
    every?: CommentaireWhereInput
    some?: CommentaireWhereInput
    none?: CommentaireWhereInput
  }

  export type Note_interOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Note_devoirOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatiereCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: SortOrder
    id_coefficient?: SortOrder
  }

  export type MatiereAvgOrderByAggregateInput = {
    id?: SortOrder
    id_coefficient?: SortOrder
  }

  export type MatiereMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: SortOrder
    id_coefficient?: SortOrder
  }

  export type MatiereMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: SortOrder
    id_coefficient?: SortOrder
  }

  export type MatiereSumOrderByAggregateInput = {
    id?: SortOrder
    id_coefficient?: SortOrder
  }

  export type MatiereRelationFilter = {
    is?: MatiereWhereInput
    isNot?: MatiereWhereInput
  }

  export type EleveRelationFilter = {
    is?: EleveWhereInput
    isNot?: EleveWhereInput
  }

  export type TrimestreRelationFilter = {
    is?: TrimestreWhereInput
    isNot?: TrimestreWhereInput
  }

  export type RangId_eleveId_matiereId_trimestreCompoundUniqueInput = {
    id_eleve: number
    id_matiere: number
    id_trimestre: number
  }

  export type RangCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
  }

  export type RangAvgOrderByAggregateInput = {
    id?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
  }

  export type RangMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
  }

  export type RangMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
  }

  export type RangSumOrderByAggregateInput = {
    id?: SortOrder
    rang?: SortOrder
    id_matiere?: SortOrder
    id_eleve?: SortOrder
    id_trimestre?: SortOrder
  }

  export type MatiereListRelationFilter = {
    every?: MatiereWhereInput
    some?: MatiereWhereInput
    none?: MatiereWhereInput
  }

  export type MatiereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoefficientCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coefficient?: SortOrder
  }

  export type CoefficientAvgOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
  }

  export type CoefficientMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coefficient?: SortOrder
  }

  export type CoefficientMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coefficient?: SortOrder
  }

  export type CoefficientSumOrderByAggregateInput = {
    id?: SortOrder
    coefficient?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type ParentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type ParentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type EnseignantCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EnseignantAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnseignantMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EnseignantMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    contact?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EnseignantSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClasseRelationFilter = {
    is?: ClasseWhereInput
    isNot?: ClasseWhereInput
  }

  export type ParentRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type EleveCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    sexe?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EleveAvgOrderByAggregateInput = {
    id?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
  }

  export type EleveMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    sexe?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EleveMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    sexe?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type EleveSumOrderByAggregateInput = {
    id?: SortOrder
    id_classe?: SortOrder
    id_parent?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnseignantRelationFilter = {
    is?: EnseignantWhereInput
    isNot?: EnseignantWhereInput
  }

  export type CommentaireCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contenu?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type CommentaireAvgOrderByAggregateInput = {
    id?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type CommentaireMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contenu?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type CommentaireMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contenu?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type CommentaireSumOrderByAggregateInput = {
    id?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type PieceJointeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titre?: SortOrder
    piece?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
  }

  export type PieceJointeAvgOrderByAggregateInput = {
    id?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
  }

  export type PieceJointeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titre?: SortOrder
    piece?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
  }

  export type PieceJointeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    titre?: SortOrder
    piece?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
  }

  export type PieceJointeSumOrderByAggregateInput = {
    id?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
    id_enseignant?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type Enseignant_ClasseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
  }

  export type Enseignant_ClasseAvgOrderByAggregateInput = {
    id?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
  }

  export type Enseignant_ClasseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
  }

  export type Enseignant_ClasseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
  }

  export type Enseignant_ClasseSumOrderByAggregateInput = {
    id?: SortOrder
    id_enseignant?: SortOrder
    id_classe?: SortOrder
    id_matiere?: SortOrder
  }

  export type TrimestreCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type TrimestreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrimestreMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type TrimestreMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
  }

  export type TrimestreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Note_interCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_interAvgOrderByAggregateInput = {
    id?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type Note_interMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_interMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_interSumOrderByAggregateInput = {
    id?: SortOrder
    inter?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Note_devoirCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_devoirAvgOrderByAggregateInput = {
    id?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type Note_devoirMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_devoirMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
    vu?: SortOrder
  }

  export type Note_devoirSumOrderByAggregateInput = {
    id?: SortOrder
    devoir?: SortOrder
    id_eleve?: SortOrder
    id_enseignant?: SortOrder
    id_matiere?: SortOrder
    id_trimestre?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirecteurCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type DirecteurAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirecteurMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type DirecteurMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type DirecteurSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EleveCreateNestedManyWithoutClasseInput = {
    create?: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput> | EleveCreateWithoutClasseInput[] | EleveUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutClasseInput | EleveCreateOrConnectWithoutClasseInput[]
    createMany?: EleveCreateManyClasseInputEnvelope
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
  }

  export type Enseignant_ClasseCreateNestedManyWithoutClasseInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput> | Enseignant_ClasseCreateWithoutClasseInput[] | Enseignant_ClasseUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutClasseInput | Enseignant_ClasseCreateOrConnectWithoutClasseInput[]
    createMany?: Enseignant_ClasseCreateManyClasseInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type PieceJointeCreateNestedManyWithoutClasseInput = {
    create?: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput> | PieceJointeCreateWithoutClasseInput[] | PieceJointeUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutClasseInput | PieceJointeCreateOrConnectWithoutClasseInput[]
    createMany?: PieceJointeCreateManyClasseInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type EleveUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput> | EleveCreateWithoutClasseInput[] | EleveUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutClasseInput | EleveCreateOrConnectWithoutClasseInput[]
    createMany?: EleveCreateManyClasseInputEnvelope
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
  }

  export type Enseignant_ClasseUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput> | Enseignant_ClasseCreateWithoutClasseInput[] | Enseignant_ClasseUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutClasseInput | Enseignant_ClasseCreateOrConnectWithoutClasseInput[]
    createMany?: Enseignant_ClasseCreateManyClasseInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type PieceJointeUncheckedCreateNestedManyWithoutClasseInput = {
    create?: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput> | PieceJointeCreateWithoutClasseInput[] | PieceJointeUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutClasseInput | PieceJointeCreateOrConnectWithoutClasseInput[]
    createMany?: PieceJointeCreateManyClasseInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EleveUpdateManyWithoutClasseNestedInput = {
    create?: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput> | EleveCreateWithoutClasseInput[] | EleveUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutClasseInput | EleveCreateOrConnectWithoutClasseInput[]
    upsert?: EleveUpsertWithWhereUniqueWithoutClasseInput | EleveUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: EleveCreateManyClasseInputEnvelope
    set?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    disconnect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    delete?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    update?: EleveUpdateWithWhereUniqueWithoutClasseInput | EleveUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: EleveUpdateManyWithWhereWithoutClasseInput | EleveUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: EleveScalarWhereInput | EleveScalarWhereInput[]
  }

  export type Enseignant_ClasseUpdateManyWithoutClasseNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput> | Enseignant_ClasseCreateWithoutClasseInput[] | Enseignant_ClasseUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutClasseInput | Enseignant_ClasseCreateOrConnectWithoutClasseInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutClasseInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: Enseignant_ClasseCreateManyClasseInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutClasseInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutClasseInput | Enseignant_ClasseUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type PieceJointeUpdateManyWithoutClasseNestedInput = {
    create?: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput> | PieceJointeCreateWithoutClasseInput[] | PieceJointeUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutClasseInput | PieceJointeCreateOrConnectWithoutClasseInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutClasseInput | PieceJointeUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: PieceJointeCreateManyClasseInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutClasseInput | PieceJointeUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutClasseInput | PieceJointeUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EleveUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput> | EleveCreateWithoutClasseInput[] | EleveUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutClasseInput | EleveCreateOrConnectWithoutClasseInput[]
    upsert?: EleveUpsertWithWhereUniqueWithoutClasseInput | EleveUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: EleveCreateManyClasseInputEnvelope
    set?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    disconnect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    delete?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    update?: EleveUpdateWithWhereUniqueWithoutClasseInput | EleveUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: EleveUpdateManyWithWhereWithoutClasseInput | EleveUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: EleveScalarWhereInput | EleveScalarWhereInput[]
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput> | Enseignant_ClasseCreateWithoutClasseInput[] | Enseignant_ClasseUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutClasseInput | Enseignant_ClasseCreateOrConnectWithoutClasseInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutClasseInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: Enseignant_ClasseCreateManyClasseInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutClasseInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutClasseInput | Enseignant_ClasseUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type PieceJointeUncheckedUpdateManyWithoutClasseNestedInput = {
    create?: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput> | PieceJointeCreateWithoutClasseInput[] | PieceJointeUncheckedCreateWithoutClasseInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutClasseInput | PieceJointeCreateOrConnectWithoutClasseInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutClasseInput | PieceJointeUpsertWithWhereUniqueWithoutClasseInput[]
    createMany?: PieceJointeCreateManyClasseInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutClasseInput | PieceJointeUpdateWithWhereUniqueWithoutClasseInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutClasseInput | PieceJointeUpdateManyWithWhereWithoutClasseInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type Note_interCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput> | Note_interCreateWithoutMatiereInput[] | Note_interUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutMatiereInput | Note_interCreateOrConnectWithoutMatiereInput[]
    createMany?: Note_interCreateManyMatiereInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput> | Note_devoirCreateWithoutMatiereInput[] | Note_devoirUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutMatiereInput | Note_devoirCreateOrConnectWithoutMatiereInput[]
    createMany?: Note_devoirCreateManyMatiereInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangCreateNestedManyWithoutMatiereInput = {
    create?: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput> | RangCreateWithoutMatiereInput[] | RangUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: RangCreateOrConnectWithoutMatiereInput | RangCreateOrConnectWithoutMatiereInput[]
    createMany?: RangCreateManyMatiereInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type CoefficientCreateNestedOneWithoutMatiereInput = {
    create?: XOR<CoefficientCreateWithoutMatiereInput, CoefficientUncheckedCreateWithoutMatiereInput>
    connectOrCreate?: CoefficientCreateOrConnectWithoutMatiereInput
    connect?: CoefficientWhereUniqueInput
  }

  export type Enseignant_ClasseCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput> | Enseignant_ClasseCreateWithoutMatiereInput[] | Enseignant_ClasseUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutMatiereInput | Enseignant_ClasseCreateOrConnectWithoutMatiereInput[]
    createMany?: Enseignant_ClasseCreateManyMatiereInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type CommentaireCreateNestedManyWithoutMatiereInput = {
    create?: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput> | CommentaireCreateWithoutMatiereInput[] | CommentaireUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutMatiereInput | CommentaireCreateOrConnectWithoutMatiereInput[]
    createMany?: CommentaireCreateManyMatiereInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type PieceJointeCreateNestedManyWithoutMatiereInput = {
    create?: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput> | PieceJointeCreateWithoutMatiereInput[] | PieceJointeUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutMatiereInput | PieceJointeCreateOrConnectWithoutMatiereInput[]
    createMany?: PieceJointeCreateManyMatiereInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type Note_interUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput> | Note_interCreateWithoutMatiereInput[] | Note_interUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutMatiereInput | Note_interCreateOrConnectWithoutMatiereInput[]
    createMany?: Note_interCreateManyMatiereInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput> | Note_devoirCreateWithoutMatiereInput[] | Note_devoirUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutMatiereInput | Note_devoirCreateOrConnectWithoutMatiereInput[]
    createMany?: Note_devoirCreateManyMatiereInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput> | RangCreateWithoutMatiereInput[] | RangUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: RangCreateOrConnectWithoutMatiereInput | RangCreateOrConnectWithoutMatiereInput[]
    createMany?: RangCreateManyMatiereInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput> | Enseignant_ClasseCreateWithoutMatiereInput[] | Enseignant_ClasseUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutMatiereInput | Enseignant_ClasseCreateOrConnectWithoutMatiereInput[]
    createMany?: Enseignant_ClasseCreateManyMatiereInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type CommentaireUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput> | CommentaireCreateWithoutMatiereInput[] | CommentaireUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutMatiereInput | CommentaireCreateOrConnectWithoutMatiereInput[]
    createMany?: CommentaireCreateManyMatiereInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type PieceJointeUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput> | PieceJointeCreateWithoutMatiereInput[] | PieceJointeUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutMatiereInput | PieceJointeCreateOrConnectWithoutMatiereInput[]
    createMany?: PieceJointeCreateManyMatiereInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type Note_interUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput> | Note_interCreateWithoutMatiereInput[] | Note_interUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutMatiereInput | Note_interCreateOrConnectWithoutMatiereInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutMatiereInput | Note_interUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Note_interCreateManyMatiereInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutMatiereInput | Note_interUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutMatiereInput | Note_interUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput> | Note_devoirCreateWithoutMatiereInput[] | Note_devoirUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutMatiereInput | Note_devoirCreateOrConnectWithoutMatiereInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutMatiereInput | Note_devoirUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Note_devoirCreateManyMatiereInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutMatiereInput | Note_devoirUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutMatiereInput | Note_devoirUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput> | RangCreateWithoutMatiereInput[] | RangUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: RangCreateOrConnectWithoutMatiereInput | RangCreateOrConnectWithoutMatiereInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutMatiereInput | RangUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: RangCreateManyMatiereInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutMatiereInput | RangUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: RangUpdateManyWithWhereWithoutMatiereInput | RangUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type CoefficientUpdateOneRequiredWithoutMatiereNestedInput = {
    create?: XOR<CoefficientCreateWithoutMatiereInput, CoefficientUncheckedCreateWithoutMatiereInput>
    connectOrCreate?: CoefficientCreateOrConnectWithoutMatiereInput
    upsert?: CoefficientUpsertWithoutMatiereInput
    connect?: CoefficientWhereUniqueInput
    update?: XOR<XOR<CoefficientUpdateToOneWithWhereWithoutMatiereInput, CoefficientUpdateWithoutMatiereInput>, CoefficientUncheckedUpdateWithoutMatiereInput>
  }

  export type Enseignant_ClasseUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput> | Enseignant_ClasseCreateWithoutMatiereInput[] | Enseignant_ClasseUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutMatiereInput | Enseignant_ClasseCreateOrConnectWithoutMatiereInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutMatiereInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Enseignant_ClasseCreateManyMatiereInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutMatiereInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutMatiereInput | Enseignant_ClasseUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type CommentaireUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput> | CommentaireCreateWithoutMatiereInput[] | CommentaireUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutMatiereInput | CommentaireCreateOrConnectWithoutMatiereInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutMatiereInput | CommentaireUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: CommentaireCreateManyMatiereInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutMatiereInput | CommentaireUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutMatiereInput | CommentaireUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type PieceJointeUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput> | PieceJointeCreateWithoutMatiereInput[] | PieceJointeUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutMatiereInput | PieceJointeCreateOrConnectWithoutMatiereInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutMatiereInput | PieceJointeUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: PieceJointeCreateManyMatiereInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutMatiereInput | PieceJointeUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutMatiereInput | PieceJointeUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type Note_interUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput> | Note_interCreateWithoutMatiereInput[] | Note_interUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutMatiereInput | Note_interCreateOrConnectWithoutMatiereInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutMatiereInput | Note_interUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Note_interCreateManyMatiereInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutMatiereInput | Note_interUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutMatiereInput | Note_interUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput> | Note_devoirCreateWithoutMatiereInput[] | Note_devoirUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutMatiereInput | Note_devoirCreateOrConnectWithoutMatiereInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutMatiereInput | Note_devoirUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Note_devoirCreateManyMatiereInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutMatiereInput | Note_devoirUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutMatiereInput | Note_devoirUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput> | RangCreateWithoutMatiereInput[] | RangUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: RangCreateOrConnectWithoutMatiereInput | RangCreateOrConnectWithoutMatiereInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutMatiereInput | RangUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: RangCreateManyMatiereInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutMatiereInput | RangUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: RangUpdateManyWithWhereWithoutMatiereInput | RangUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput> | Enseignant_ClasseCreateWithoutMatiereInput[] | Enseignant_ClasseUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutMatiereInput | Enseignant_ClasseCreateOrConnectWithoutMatiereInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutMatiereInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: Enseignant_ClasseCreateManyMatiereInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutMatiereInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutMatiereInput | Enseignant_ClasseUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type CommentaireUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput> | CommentaireCreateWithoutMatiereInput[] | CommentaireUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutMatiereInput | CommentaireCreateOrConnectWithoutMatiereInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutMatiereInput | CommentaireUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: CommentaireCreateManyMatiereInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutMatiereInput | CommentaireUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutMatiereInput | CommentaireUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput> | PieceJointeCreateWithoutMatiereInput[] | PieceJointeUncheckedCreateWithoutMatiereInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutMatiereInput | PieceJointeCreateOrConnectWithoutMatiereInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutMatiereInput | PieceJointeUpsertWithWhereUniqueWithoutMatiereInput[]
    createMany?: PieceJointeCreateManyMatiereInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutMatiereInput | PieceJointeUpdateWithWhereUniqueWithoutMatiereInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutMatiereInput | PieceJointeUpdateManyWithWhereWithoutMatiereInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type MatiereCreateNestedOneWithoutRangInput = {
    create?: XOR<MatiereCreateWithoutRangInput, MatiereUncheckedCreateWithoutRangInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutRangInput
    connect?: MatiereWhereUniqueInput
  }

  export type EleveCreateNestedOneWithoutRangInput = {
    create?: XOR<EleveCreateWithoutRangInput, EleveUncheckedCreateWithoutRangInput>
    connectOrCreate?: EleveCreateOrConnectWithoutRangInput
    connect?: EleveWhereUniqueInput
  }

  export type TrimestreCreateNestedOneWithoutRangInput = {
    create?: XOR<TrimestreCreateWithoutRangInput, TrimestreUncheckedCreateWithoutRangInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutRangInput
    connect?: TrimestreWhereUniqueInput
  }

  export type MatiereUpdateOneRequiredWithoutRangNestedInput = {
    create?: XOR<MatiereCreateWithoutRangInput, MatiereUncheckedCreateWithoutRangInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutRangInput
    upsert?: MatiereUpsertWithoutRangInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutRangInput, MatiereUpdateWithoutRangInput>, MatiereUncheckedUpdateWithoutRangInput>
  }

  export type EleveUpdateOneRequiredWithoutRangNestedInput = {
    create?: XOR<EleveCreateWithoutRangInput, EleveUncheckedCreateWithoutRangInput>
    connectOrCreate?: EleveCreateOrConnectWithoutRangInput
    upsert?: EleveUpsertWithoutRangInput
    connect?: EleveWhereUniqueInput
    update?: XOR<XOR<EleveUpdateToOneWithWhereWithoutRangInput, EleveUpdateWithoutRangInput>, EleveUncheckedUpdateWithoutRangInput>
  }

  export type TrimestreUpdateOneRequiredWithoutRangNestedInput = {
    create?: XOR<TrimestreCreateWithoutRangInput, TrimestreUncheckedCreateWithoutRangInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutRangInput
    upsert?: TrimestreUpsertWithoutRangInput
    connect?: TrimestreWhereUniqueInput
    update?: XOR<XOR<TrimestreUpdateToOneWithWhereWithoutRangInput, TrimestreUpdateWithoutRangInput>, TrimestreUncheckedUpdateWithoutRangInput>
  }

  export type MatiereCreateNestedManyWithoutCoeffientInput = {
    create?: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput> | MatiereCreateWithoutCoeffientInput[] | MatiereUncheckedCreateWithoutCoeffientInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutCoeffientInput | MatiereCreateOrConnectWithoutCoeffientInput[]
    createMany?: MatiereCreateManyCoeffientInputEnvelope
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
  }

  export type MatiereUncheckedCreateNestedManyWithoutCoeffientInput = {
    create?: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput> | MatiereCreateWithoutCoeffientInput[] | MatiereUncheckedCreateWithoutCoeffientInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutCoeffientInput | MatiereCreateOrConnectWithoutCoeffientInput[]
    createMany?: MatiereCreateManyCoeffientInputEnvelope
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
  }

  export type MatiereUpdateManyWithoutCoeffientNestedInput = {
    create?: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput> | MatiereCreateWithoutCoeffientInput[] | MatiereUncheckedCreateWithoutCoeffientInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutCoeffientInput | MatiereCreateOrConnectWithoutCoeffientInput[]
    upsert?: MatiereUpsertWithWhereUniqueWithoutCoeffientInput | MatiereUpsertWithWhereUniqueWithoutCoeffientInput[]
    createMany?: MatiereCreateManyCoeffientInputEnvelope
    set?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    disconnect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    delete?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    update?: MatiereUpdateWithWhereUniqueWithoutCoeffientInput | MatiereUpdateWithWhereUniqueWithoutCoeffientInput[]
    updateMany?: MatiereUpdateManyWithWhereWithoutCoeffientInput | MatiereUpdateManyWithWhereWithoutCoeffientInput[]
    deleteMany?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
  }

  export type MatiereUncheckedUpdateManyWithoutCoeffientNestedInput = {
    create?: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput> | MatiereCreateWithoutCoeffientInput[] | MatiereUncheckedCreateWithoutCoeffientInput[]
    connectOrCreate?: MatiereCreateOrConnectWithoutCoeffientInput | MatiereCreateOrConnectWithoutCoeffientInput[]
    upsert?: MatiereUpsertWithWhereUniqueWithoutCoeffientInput | MatiereUpsertWithWhereUniqueWithoutCoeffientInput[]
    createMany?: MatiereCreateManyCoeffientInputEnvelope
    set?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    disconnect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    delete?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    connect?: MatiereWhereUniqueInput | MatiereWhereUniqueInput[]
    update?: MatiereUpdateWithWhereUniqueWithoutCoeffientInput | MatiereUpdateWithWhereUniqueWithoutCoeffientInput[]
    updateMany?: MatiereUpdateManyWithWhereWithoutCoeffientInput | MatiereUpdateManyWithWhereWithoutCoeffientInput[]
    deleteMany?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
  }

  export type EleveCreateNestedManyWithoutParentInput = {
    create?: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput> | EleveCreateWithoutParentInput[] | EleveUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutParentInput | EleveCreateOrConnectWithoutParentInput[]
    createMany?: EleveCreateManyParentInputEnvelope
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
  }

  export type EleveUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput> | EleveCreateWithoutParentInput[] | EleveUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutParentInput | EleveCreateOrConnectWithoutParentInput[]
    createMany?: EleveCreateManyParentInputEnvelope
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type EleveUpdateManyWithoutParentNestedInput = {
    create?: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput> | EleveCreateWithoutParentInput[] | EleveUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutParentInput | EleveCreateOrConnectWithoutParentInput[]
    upsert?: EleveUpsertWithWhereUniqueWithoutParentInput | EleveUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EleveCreateManyParentInputEnvelope
    set?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    disconnect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    delete?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    update?: EleveUpdateWithWhereUniqueWithoutParentInput | EleveUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EleveUpdateManyWithWhereWithoutParentInput | EleveUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EleveScalarWhereInput | EleveScalarWhereInput[]
  }

  export type EleveUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput> | EleveCreateWithoutParentInput[] | EleveUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EleveCreateOrConnectWithoutParentInput | EleveCreateOrConnectWithoutParentInput[]
    upsert?: EleveUpsertWithWhereUniqueWithoutParentInput | EleveUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EleveCreateManyParentInputEnvelope
    set?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    disconnect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    delete?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    connect?: EleveWhereUniqueInput | EleveWhereUniqueInput[]
    update?: EleveUpdateWithWhereUniqueWithoutParentInput | EleveUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EleveUpdateManyWithWhereWithoutParentInput | EleveUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EleveScalarWhereInput | EleveScalarWhereInput[]
  }

  export type Enseignant_ClasseCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput> | Enseignant_ClasseCreateWithoutEnseignantInput[] | Enseignant_ClasseUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutEnseignantInput | Enseignant_ClasseCreateOrConnectWithoutEnseignantInput[]
    createMany?: Enseignant_ClasseCreateManyEnseignantInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type Note_interCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput> | Note_interCreateWithoutEnseignantInput[] | Note_interUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEnseignantInput | Note_interCreateOrConnectWithoutEnseignantInput[]
    createMany?: Note_interCreateManyEnseignantInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput> | Note_devoirCreateWithoutEnseignantInput[] | Note_devoirUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEnseignantInput | Note_devoirCreateOrConnectWithoutEnseignantInput[]
    createMany?: Note_devoirCreateManyEnseignantInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type CommentaireCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput> | CommentaireCreateWithoutEnseignantInput[] | CommentaireUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEnseignantInput | CommentaireCreateOrConnectWithoutEnseignantInput[]
    createMany?: CommentaireCreateManyEnseignantInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type PieceJointeCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput> | PieceJointeCreateWithoutEnseignantInput[] | PieceJointeUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutEnseignantInput | PieceJointeCreateOrConnectWithoutEnseignantInput[]
    createMany?: PieceJointeCreateManyEnseignantInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput> | Enseignant_ClasseCreateWithoutEnseignantInput[] | Enseignant_ClasseUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutEnseignantInput | Enseignant_ClasseCreateOrConnectWithoutEnseignantInput[]
    createMany?: Enseignant_ClasseCreateManyEnseignantInputEnvelope
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
  }

  export type Note_interUncheckedCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput> | Note_interCreateWithoutEnseignantInput[] | Note_interUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEnseignantInput | Note_interCreateOrConnectWithoutEnseignantInput[]
    createMany?: Note_interCreateManyEnseignantInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput> | Note_devoirCreateWithoutEnseignantInput[] | Note_devoirUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEnseignantInput | Note_devoirCreateOrConnectWithoutEnseignantInput[]
    createMany?: Note_devoirCreateManyEnseignantInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type CommentaireUncheckedCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput> | CommentaireCreateWithoutEnseignantInput[] | CommentaireUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEnseignantInput | CommentaireCreateOrConnectWithoutEnseignantInput[]
    createMany?: CommentaireCreateManyEnseignantInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput = {
    create?: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput> | PieceJointeCreateWithoutEnseignantInput[] | PieceJointeUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutEnseignantInput | PieceJointeCreateOrConnectWithoutEnseignantInput[]
    createMany?: PieceJointeCreateManyEnseignantInputEnvelope
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
  }

  export type Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput> | Enseignant_ClasseCreateWithoutEnseignantInput[] | Enseignant_ClasseUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutEnseignantInput | Enseignant_ClasseCreateOrConnectWithoutEnseignantInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutEnseignantInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Enseignant_ClasseCreateManyEnseignantInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutEnseignantInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutEnseignantInput | Enseignant_ClasseUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type Note_interUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput> | Note_interCreateWithoutEnseignantInput[] | Note_interUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEnseignantInput | Note_interCreateOrConnectWithoutEnseignantInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutEnseignantInput | Note_interUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Note_interCreateManyEnseignantInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutEnseignantInput | Note_interUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutEnseignantInput | Note_interUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput> | Note_devoirCreateWithoutEnseignantInput[] | Note_devoirUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEnseignantInput | Note_devoirCreateOrConnectWithoutEnseignantInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutEnseignantInput | Note_devoirUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Note_devoirCreateManyEnseignantInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutEnseignantInput | Note_devoirUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutEnseignantInput | Note_devoirUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type CommentaireUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput> | CommentaireCreateWithoutEnseignantInput[] | CommentaireUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEnseignantInput | CommentaireCreateOrConnectWithoutEnseignantInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutEnseignantInput | CommentaireUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: CommentaireCreateManyEnseignantInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutEnseignantInput | CommentaireUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutEnseignantInput | CommentaireUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type PieceJointeUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput> | PieceJointeCreateWithoutEnseignantInput[] | PieceJointeUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutEnseignantInput | PieceJointeCreateOrConnectWithoutEnseignantInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutEnseignantInput | PieceJointeUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: PieceJointeCreateManyEnseignantInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutEnseignantInput | PieceJointeUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutEnseignantInput | PieceJointeUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput> | Enseignant_ClasseCreateWithoutEnseignantInput[] | Enseignant_ClasseUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Enseignant_ClasseCreateOrConnectWithoutEnseignantInput | Enseignant_ClasseCreateOrConnectWithoutEnseignantInput[]
    upsert?: Enseignant_ClasseUpsertWithWhereUniqueWithoutEnseignantInput | Enseignant_ClasseUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Enseignant_ClasseCreateManyEnseignantInputEnvelope
    set?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    disconnect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    delete?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    connect?: Enseignant_ClasseWhereUniqueInput | Enseignant_ClasseWhereUniqueInput[]
    update?: Enseignant_ClasseUpdateWithWhereUniqueWithoutEnseignantInput | Enseignant_ClasseUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Enseignant_ClasseUpdateManyWithWhereWithoutEnseignantInput | Enseignant_ClasseUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
  }

  export type Note_interUncheckedUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput> | Note_interCreateWithoutEnseignantInput[] | Note_interUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEnseignantInput | Note_interCreateOrConnectWithoutEnseignantInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutEnseignantInput | Note_interUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Note_interCreateManyEnseignantInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutEnseignantInput | Note_interUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutEnseignantInput | Note_interUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput> | Note_devoirCreateWithoutEnseignantInput[] | Note_devoirUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEnseignantInput | Note_devoirCreateOrConnectWithoutEnseignantInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutEnseignantInput | Note_devoirUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: Note_devoirCreateManyEnseignantInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutEnseignantInput | Note_devoirUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutEnseignantInput | Note_devoirUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput> | CommentaireCreateWithoutEnseignantInput[] | CommentaireUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEnseignantInput | CommentaireCreateOrConnectWithoutEnseignantInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutEnseignantInput | CommentaireUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: CommentaireCreateManyEnseignantInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutEnseignantInput | CommentaireUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutEnseignantInput | CommentaireUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput = {
    create?: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput> | PieceJointeCreateWithoutEnseignantInput[] | PieceJointeUncheckedCreateWithoutEnseignantInput[]
    connectOrCreate?: PieceJointeCreateOrConnectWithoutEnseignantInput | PieceJointeCreateOrConnectWithoutEnseignantInput[]
    upsert?: PieceJointeUpsertWithWhereUniqueWithoutEnseignantInput | PieceJointeUpsertWithWhereUniqueWithoutEnseignantInput[]
    createMany?: PieceJointeCreateManyEnseignantInputEnvelope
    set?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    disconnect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    delete?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    connect?: PieceJointeWhereUniqueInput | PieceJointeWhereUniqueInput[]
    update?: PieceJointeUpdateWithWhereUniqueWithoutEnseignantInput | PieceJointeUpdateWithWhereUniqueWithoutEnseignantInput[]
    updateMany?: PieceJointeUpdateManyWithWhereWithoutEnseignantInput | PieceJointeUpdateManyWithWhereWithoutEnseignantInput[]
    deleteMany?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
  }

  export type ClasseCreateNestedOneWithoutElevesInput = {
    create?: XOR<ClasseCreateWithoutElevesInput, ClasseUncheckedCreateWithoutElevesInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutElevesInput
    connect?: ClasseWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutEnfantsInput = {
    create?: XOR<ParentCreateWithoutEnfantsInput, ParentUncheckedCreateWithoutEnfantsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutEnfantsInput
    connect?: ParentWhereUniqueInput
  }

  export type Note_interCreateNestedManyWithoutEleveInput = {
    create?: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput> | Note_interCreateWithoutEleveInput[] | Note_interUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEleveInput | Note_interCreateOrConnectWithoutEleveInput[]
    createMany?: Note_interCreateManyEleveInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirCreateNestedManyWithoutEleveInput = {
    create?: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput> | Note_devoirCreateWithoutEleveInput[] | Note_devoirUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEleveInput | Note_devoirCreateOrConnectWithoutEleveInput[]
    createMany?: Note_devoirCreateManyEleveInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangCreateNestedManyWithoutEleveInput = {
    create?: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput> | RangCreateWithoutEleveInput[] | RangUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: RangCreateOrConnectWithoutEleveInput | RangCreateOrConnectWithoutEleveInput[]
    createMany?: RangCreateManyEleveInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type CommentaireCreateNestedManyWithoutEleveInput = {
    create?: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput> | CommentaireCreateWithoutEleveInput[] | CommentaireUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEleveInput | CommentaireCreateOrConnectWithoutEleveInput[]
    createMany?: CommentaireCreateManyEleveInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type Note_interUncheckedCreateNestedManyWithoutEleveInput = {
    create?: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput> | Note_interCreateWithoutEleveInput[] | Note_interUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEleveInput | Note_interCreateOrConnectWithoutEleveInput[]
    createMany?: Note_interCreateManyEleveInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirUncheckedCreateNestedManyWithoutEleveInput = {
    create?: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput> | Note_devoirCreateWithoutEleveInput[] | Note_devoirUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEleveInput | Note_devoirCreateOrConnectWithoutEleveInput[]
    createMany?: Note_devoirCreateManyEleveInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangUncheckedCreateNestedManyWithoutEleveInput = {
    create?: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput> | RangCreateWithoutEleveInput[] | RangUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: RangCreateOrConnectWithoutEleveInput | RangCreateOrConnectWithoutEleveInput[]
    createMany?: RangCreateManyEleveInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type CommentaireUncheckedCreateNestedManyWithoutEleveInput = {
    create?: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput> | CommentaireCreateWithoutEleveInput[] | CommentaireUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEleveInput | CommentaireCreateOrConnectWithoutEleveInput[]
    createMany?: CommentaireCreateManyEleveInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type ClasseUpdateOneRequiredWithoutElevesNestedInput = {
    create?: XOR<ClasseCreateWithoutElevesInput, ClasseUncheckedCreateWithoutElevesInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutElevesInput
    upsert?: ClasseUpsertWithoutElevesInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutElevesInput, ClasseUpdateWithoutElevesInput>, ClasseUncheckedUpdateWithoutElevesInput>
  }

  export type ParentUpdateOneRequiredWithoutEnfantsNestedInput = {
    create?: XOR<ParentCreateWithoutEnfantsInput, ParentUncheckedCreateWithoutEnfantsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutEnfantsInput
    upsert?: ParentUpsertWithoutEnfantsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutEnfantsInput, ParentUpdateWithoutEnfantsInput>, ParentUncheckedUpdateWithoutEnfantsInput>
  }

  export type Note_interUpdateManyWithoutEleveNestedInput = {
    create?: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput> | Note_interCreateWithoutEleveInput[] | Note_interUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEleveInput | Note_interCreateOrConnectWithoutEleveInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutEleveInput | Note_interUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: Note_interCreateManyEleveInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutEleveInput | Note_interUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutEleveInput | Note_interUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUpdateManyWithoutEleveNestedInput = {
    create?: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput> | Note_devoirCreateWithoutEleveInput[] | Note_devoirUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEleveInput | Note_devoirCreateOrConnectWithoutEleveInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutEleveInput | Note_devoirUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: Note_devoirCreateManyEleveInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutEleveInput | Note_devoirUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutEleveInput | Note_devoirUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUpdateManyWithoutEleveNestedInput = {
    create?: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput> | RangCreateWithoutEleveInput[] | RangUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: RangCreateOrConnectWithoutEleveInput | RangCreateOrConnectWithoutEleveInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutEleveInput | RangUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: RangCreateManyEleveInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutEleveInput | RangUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: RangUpdateManyWithWhereWithoutEleveInput | RangUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type CommentaireUpdateManyWithoutEleveNestedInput = {
    create?: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput> | CommentaireCreateWithoutEleveInput[] | CommentaireUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEleveInput | CommentaireCreateOrConnectWithoutEleveInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutEleveInput | CommentaireUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: CommentaireCreateManyEleveInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutEleveInput | CommentaireUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutEleveInput | CommentaireUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type Note_interUncheckedUpdateManyWithoutEleveNestedInput = {
    create?: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput> | Note_interCreateWithoutEleveInput[] | Note_interUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutEleveInput | Note_interCreateOrConnectWithoutEleveInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutEleveInput | Note_interUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: Note_interCreateManyEleveInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutEleveInput | Note_interUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutEleveInput | Note_interUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUncheckedUpdateManyWithoutEleveNestedInput = {
    create?: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput> | Note_devoirCreateWithoutEleveInput[] | Note_devoirUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutEleveInput | Note_devoirCreateOrConnectWithoutEleveInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutEleveInput | Note_devoirUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: Note_devoirCreateManyEleveInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutEleveInput | Note_devoirUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutEleveInput | Note_devoirUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUncheckedUpdateManyWithoutEleveNestedInput = {
    create?: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput> | RangCreateWithoutEleveInput[] | RangUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: RangCreateOrConnectWithoutEleveInput | RangCreateOrConnectWithoutEleveInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutEleveInput | RangUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: RangCreateManyEleveInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutEleveInput | RangUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: RangUpdateManyWithWhereWithoutEleveInput | RangUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type CommentaireUncheckedUpdateManyWithoutEleveNestedInput = {
    create?: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput> | CommentaireCreateWithoutEleveInput[] | CommentaireUncheckedCreateWithoutEleveInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutEleveInput | CommentaireCreateOrConnectWithoutEleveInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutEleveInput | CommentaireUpsertWithWhereUniqueWithoutEleveInput[]
    createMany?: CommentaireCreateManyEleveInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutEleveInput | CommentaireUpdateWithWhereUniqueWithoutEleveInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutEleveInput | CommentaireUpdateManyWithWhereWithoutEleveInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type EleveCreateNestedOneWithoutCommentaireInput = {
    create?: XOR<EleveCreateWithoutCommentaireInput, EleveUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: EleveCreateOrConnectWithoutCommentaireInput
    connect?: EleveWhereUniqueInput
  }

  export type EnseignantCreateNestedOneWithoutCommentaireInput = {
    create?: XOR<EnseignantCreateWithoutCommentaireInput, EnseignantUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutCommentaireInput
    connect?: EnseignantWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutCommentaireInput = {
    create?: XOR<MatiereCreateWithoutCommentaireInput, MatiereUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutCommentaireInput
    connect?: MatiereWhereUniqueInput
  }

  export type TrimestreCreateNestedOneWithoutCommenstaireInput = {
    create?: XOR<TrimestreCreateWithoutCommenstaireInput, TrimestreUncheckedCreateWithoutCommenstaireInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutCommenstaireInput
    connect?: TrimestreWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EleveUpdateOneRequiredWithoutCommentaireNestedInput = {
    create?: XOR<EleveCreateWithoutCommentaireInput, EleveUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: EleveCreateOrConnectWithoutCommentaireInput
    upsert?: EleveUpsertWithoutCommentaireInput
    connect?: EleveWhereUniqueInput
    update?: XOR<XOR<EleveUpdateToOneWithWhereWithoutCommentaireInput, EleveUpdateWithoutCommentaireInput>, EleveUncheckedUpdateWithoutCommentaireInput>
  }

  export type EnseignantUpdateOneRequiredWithoutCommentaireNestedInput = {
    create?: XOR<EnseignantCreateWithoutCommentaireInput, EnseignantUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutCommentaireInput
    upsert?: EnseignantUpsertWithoutCommentaireInput
    connect?: EnseignantWhereUniqueInput
    update?: XOR<XOR<EnseignantUpdateToOneWithWhereWithoutCommentaireInput, EnseignantUpdateWithoutCommentaireInput>, EnseignantUncheckedUpdateWithoutCommentaireInput>
  }

  export type MatiereUpdateOneRequiredWithoutCommentaireNestedInput = {
    create?: XOR<MatiereCreateWithoutCommentaireInput, MatiereUncheckedCreateWithoutCommentaireInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutCommentaireInput
    upsert?: MatiereUpsertWithoutCommentaireInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutCommentaireInput, MatiereUpdateWithoutCommentaireInput>, MatiereUncheckedUpdateWithoutCommentaireInput>
  }

  export type TrimestreUpdateOneRequiredWithoutCommenstaireNestedInput = {
    create?: XOR<TrimestreCreateWithoutCommenstaireInput, TrimestreUncheckedCreateWithoutCommenstaireInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutCommenstaireInput
    upsert?: TrimestreUpsertWithoutCommenstaireInput
    connect?: TrimestreWhereUniqueInput
    update?: XOR<XOR<TrimestreUpdateToOneWithWhereWithoutCommenstaireInput, TrimestreUpdateWithoutCommenstaireInput>, TrimestreUncheckedUpdateWithoutCommenstaireInput>
  }

  export type ClasseCreateNestedOneWithoutPiecejointeInput = {
    create?: XOR<ClasseCreateWithoutPiecejointeInput, ClasseUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutPiecejointeInput
    connect?: ClasseWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutPiecejointeInput = {
    create?: XOR<MatiereCreateWithoutPiecejointeInput, MatiereUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutPiecejointeInput
    connect?: MatiereWhereUniqueInput
  }

  export type EnseignantCreateNestedOneWithoutPiecejointeInput = {
    create?: XOR<EnseignantCreateWithoutPiecejointeInput, EnseignantUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutPiecejointeInput
    connect?: EnseignantWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type ClasseUpdateOneRequiredWithoutPiecejointeNestedInput = {
    create?: XOR<ClasseCreateWithoutPiecejointeInput, ClasseUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutPiecejointeInput
    upsert?: ClasseUpsertWithoutPiecejointeInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutPiecejointeInput, ClasseUpdateWithoutPiecejointeInput>, ClasseUncheckedUpdateWithoutPiecejointeInput>
  }

  export type MatiereUpdateOneRequiredWithoutPiecejointeNestedInput = {
    create?: XOR<MatiereCreateWithoutPiecejointeInput, MatiereUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutPiecejointeInput
    upsert?: MatiereUpsertWithoutPiecejointeInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutPiecejointeInput, MatiereUpdateWithoutPiecejointeInput>, MatiereUncheckedUpdateWithoutPiecejointeInput>
  }

  export type EnseignantUpdateOneRequiredWithoutPiecejointeNestedInput = {
    create?: XOR<EnseignantCreateWithoutPiecejointeInput, EnseignantUncheckedCreateWithoutPiecejointeInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutPiecejointeInput
    upsert?: EnseignantUpsertWithoutPiecejointeInput
    connect?: EnseignantWhereUniqueInput
    update?: XOR<XOR<EnseignantUpdateToOneWithWhereWithoutPiecejointeInput, EnseignantUpdateWithoutPiecejointeInput>, EnseignantUncheckedUpdateWithoutPiecejointeInput>
  }

  export type EnseignantCreateNestedOneWithoutEnseignant_classeInput = {
    create?: XOR<EnseignantCreateWithoutEnseignant_classeInput, EnseignantUncheckedCreateWithoutEnseignant_classeInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutEnseignant_classeInput
    connect?: EnseignantWhereUniqueInput
  }

  export type ClasseCreateNestedOneWithoutEnseignant_classeInput = {
    create?: XOR<ClasseCreateWithoutEnseignant_classeInput, ClasseUncheckedCreateWithoutEnseignant_classeInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutEnseignant_classeInput
    connect?: ClasseWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutEnseignant_matiereInput = {
    create?: XOR<MatiereCreateWithoutEnseignant_matiereInput, MatiereUncheckedCreateWithoutEnseignant_matiereInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutEnseignant_matiereInput
    connect?: MatiereWhereUniqueInput
  }

  export type EnseignantUpdateOneRequiredWithoutEnseignant_classeNestedInput = {
    create?: XOR<EnseignantCreateWithoutEnseignant_classeInput, EnseignantUncheckedCreateWithoutEnseignant_classeInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutEnseignant_classeInput
    upsert?: EnseignantUpsertWithoutEnseignant_classeInput
    connect?: EnseignantWhereUniqueInput
    update?: XOR<XOR<EnseignantUpdateToOneWithWhereWithoutEnseignant_classeInput, EnseignantUpdateWithoutEnseignant_classeInput>, EnseignantUncheckedUpdateWithoutEnseignant_classeInput>
  }

  export type ClasseUpdateOneRequiredWithoutEnseignant_classeNestedInput = {
    create?: XOR<ClasseCreateWithoutEnseignant_classeInput, ClasseUncheckedCreateWithoutEnseignant_classeInput>
    connectOrCreate?: ClasseCreateOrConnectWithoutEnseignant_classeInput
    upsert?: ClasseUpsertWithoutEnseignant_classeInput
    connect?: ClasseWhereUniqueInput
    update?: XOR<XOR<ClasseUpdateToOneWithWhereWithoutEnseignant_classeInput, ClasseUpdateWithoutEnseignant_classeInput>, ClasseUncheckedUpdateWithoutEnseignant_classeInput>
  }

  export type MatiereUpdateOneRequiredWithoutEnseignant_matiereNestedInput = {
    create?: XOR<MatiereCreateWithoutEnseignant_matiereInput, MatiereUncheckedCreateWithoutEnseignant_matiereInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutEnseignant_matiereInput
    upsert?: MatiereUpsertWithoutEnseignant_matiereInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutEnseignant_matiereInput, MatiereUpdateWithoutEnseignant_matiereInput>, MatiereUncheckedUpdateWithoutEnseignant_matiereInput>
  }

  export type Note_interCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput> | Note_interCreateWithoutTrimestreInput[] | Note_interUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutTrimestreInput | Note_interCreateOrConnectWithoutTrimestreInput[]
    createMany?: Note_interCreateManyTrimestreInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput> | Note_devoirCreateWithoutTrimestreInput[] | Note_devoirUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutTrimestreInput | Note_devoirCreateOrConnectWithoutTrimestreInput[]
    createMany?: Note_devoirCreateManyTrimestreInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput> | RangCreateWithoutTrimestreInput[] | RangUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: RangCreateOrConnectWithoutTrimestreInput | RangCreateOrConnectWithoutTrimestreInput[]
    createMany?: RangCreateManyTrimestreInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type CommentaireCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput> | CommentaireCreateWithoutTrimestreInput[] | CommentaireUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutTrimestreInput | CommentaireCreateOrConnectWithoutTrimestreInput[]
    createMany?: CommentaireCreateManyTrimestreInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type Note_interUncheckedCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput> | Note_interCreateWithoutTrimestreInput[] | Note_interUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutTrimestreInput | Note_interCreateOrConnectWithoutTrimestreInput[]
    createMany?: Note_interCreateManyTrimestreInputEnvelope
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
  }

  export type Note_devoirUncheckedCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput> | Note_devoirCreateWithoutTrimestreInput[] | Note_devoirUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutTrimestreInput | Note_devoirCreateOrConnectWithoutTrimestreInput[]
    createMany?: Note_devoirCreateManyTrimestreInputEnvelope
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
  }

  export type RangUncheckedCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput> | RangCreateWithoutTrimestreInput[] | RangUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: RangCreateOrConnectWithoutTrimestreInput | RangCreateOrConnectWithoutTrimestreInput[]
    createMany?: RangCreateManyTrimestreInputEnvelope
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
  }

  export type CommentaireUncheckedCreateNestedManyWithoutTrimestreInput = {
    create?: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput> | CommentaireCreateWithoutTrimestreInput[] | CommentaireUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutTrimestreInput | CommentaireCreateOrConnectWithoutTrimestreInput[]
    createMany?: CommentaireCreateManyTrimestreInputEnvelope
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
  }

  export type Note_interUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput> | Note_interCreateWithoutTrimestreInput[] | Note_interUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutTrimestreInput | Note_interCreateOrConnectWithoutTrimestreInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutTrimestreInput | Note_interUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: Note_interCreateManyTrimestreInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutTrimestreInput | Note_interUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutTrimestreInput | Note_interUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput> | Note_devoirCreateWithoutTrimestreInput[] | Note_devoirUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutTrimestreInput | Note_devoirCreateOrConnectWithoutTrimestreInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutTrimestreInput | Note_devoirUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: Note_devoirCreateManyTrimestreInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutTrimestreInput | Note_devoirUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutTrimestreInput | Note_devoirUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput> | RangCreateWithoutTrimestreInput[] | RangUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: RangCreateOrConnectWithoutTrimestreInput | RangCreateOrConnectWithoutTrimestreInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutTrimestreInput | RangUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: RangCreateManyTrimestreInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutTrimestreInput | RangUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: RangUpdateManyWithWhereWithoutTrimestreInput | RangUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type CommentaireUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput> | CommentaireCreateWithoutTrimestreInput[] | CommentaireUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutTrimestreInput | CommentaireCreateOrConnectWithoutTrimestreInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutTrimestreInput | CommentaireUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: CommentaireCreateManyTrimestreInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutTrimestreInput | CommentaireUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutTrimestreInput | CommentaireUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type Note_interUncheckedUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput> | Note_interCreateWithoutTrimestreInput[] | Note_interUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_interCreateOrConnectWithoutTrimestreInput | Note_interCreateOrConnectWithoutTrimestreInput[]
    upsert?: Note_interUpsertWithWhereUniqueWithoutTrimestreInput | Note_interUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: Note_interCreateManyTrimestreInputEnvelope
    set?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    disconnect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    delete?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    connect?: Note_interWhereUniqueInput | Note_interWhereUniqueInput[]
    update?: Note_interUpdateWithWhereUniqueWithoutTrimestreInput | Note_interUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: Note_interUpdateManyWithWhereWithoutTrimestreInput | Note_interUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
  }

  export type Note_devoirUncheckedUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput> | Note_devoirCreateWithoutTrimestreInput[] | Note_devoirUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: Note_devoirCreateOrConnectWithoutTrimestreInput | Note_devoirCreateOrConnectWithoutTrimestreInput[]
    upsert?: Note_devoirUpsertWithWhereUniqueWithoutTrimestreInput | Note_devoirUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: Note_devoirCreateManyTrimestreInputEnvelope
    set?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    disconnect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    delete?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    connect?: Note_devoirWhereUniqueInput | Note_devoirWhereUniqueInput[]
    update?: Note_devoirUpdateWithWhereUniqueWithoutTrimestreInput | Note_devoirUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: Note_devoirUpdateManyWithWhereWithoutTrimestreInput | Note_devoirUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
  }

  export type RangUncheckedUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput> | RangCreateWithoutTrimestreInput[] | RangUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: RangCreateOrConnectWithoutTrimestreInput | RangCreateOrConnectWithoutTrimestreInput[]
    upsert?: RangUpsertWithWhereUniqueWithoutTrimestreInput | RangUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: RangCreateManyTrimestreInputEnvelope
    set?: RangWhereUniqueInput | RangWhereUniqueInput[]
    disconnect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    delete?: RangWhereUniqueInput | RangWhereUniqueInput[]
    connect?: RangWhereUniqueInput | RangWhereUniqueInput[]
    update?: RangUpdateWithWhereUniqueWithoutTrimestreInput | RangUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: RangUpdateManyWithWhereWithoutTrimestreInput | RangUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: RangScalarWhereInput | RangScalarWhereInput[]
  }

  export type CommentaireUncheckedUpdateManyWithoutTrimestreNestedInput = {
    create?: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput> | CommentaireCreateWithoutTrimestreInput[] | CommentaireUncheckedCreateWithoutTrimestreInput[]
    connectOrCreate?: CommentaireCreateOrConnectWithoutTrimestreInput | CommentaireCreateOrConnectWithoutTrimestreInput[]
    upsert?: CommentaireUpsertWithWhereUniqueWithoutTrimestreInput | CommentaireUpsertWithWhereUniqueWithoutTrimestreInput[]
    createMany?: CommentaireCreateManyTrimestreInputEnvelope
    set?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    disconnect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    delete?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    connect?: CommentaireWhereUniqueInput | CommentaireWhereUniqueInput[]
    update?: CommentaireUpdateWithWhereUniqueWithoutTrimestreInput | CommentaireUpdateWithWhereUniqueWithoutTrimestreInput[]
    updateMany?: CommentaireUpdateManyWithWhereWithoutTrimestreInput | CommentaireUpdateManyWithWhereWithoutTrimestreInput[]
    deleteMany?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
  }

  export type EleveCreateNestedOneWithoutNote_interInput = {
    create?: XOR<EleveCreateWithoutNote_interInput, EleveUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: EleveCreateOrConnectWithoutNote_interInput
    connect?: EleveWhereUniqueInput
  }

  export type EnseignantCreateNestedOneWithoutNote_interInput = {
    create?: XOR<EnseignantCreateWithoutNote_interInput, EnseignantUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutNote_interInput
    connect?: EnseignantWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutNote_interInput = {
    create?: XOR<MatiereCreateWithoutNote_interInput, MatiereUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutNote_interInput
    connect?: MatiereWhereUniqueInput
  }

  export type TrimestreCreateNestedOneWithoutNote_interInput = {
    create?: XOR<TrimestreCreateWithoutNote_interInput, TrimestreUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutNote_interInput
    connect?: TrimestreWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EleveUpdateOneRequiredWithoutNote_interNestedInput = {
    create?: XOR<EleveCreateWithoutNote_interInput, EleveUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: EleveCreateOrConnectWithoutNote_interInput
    upsert?: EleveUpsertWithoutNote_interInput
    connect?: EleveWhereUniqueInput
    update?: XOR<XOR<EleveUpdateToOneWithWhereWithoutNote_interInput, EleveUpdateWithoutNote_interInput>, EleveUncheckedUpdateWithoutNote_interInput>
  }

  export type EnseignantUpdateOneRequiredWithoutNote_interNestedInput = {
    create?: XOR<EnseignantCreateWithoutNote_interInput, EnseignantUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutNote_interInput
    upsert?: EnseignantUpsertWithoutNote_interInput
    connect?: EnseignantWhereUniqueInput
    update?: XOR<XOR<EnseignantUpdateToOneWithWhereWithoutNote_interInput, EnseignantUpdateWithoutNote_interInput>, EnseignantUncheckedUpdateWithoutNote_interInput>
  }

  export type MatiereUpdateOneRequiredWithoutNote_interNestedInput = {
    create?: XOR<MatiereCreateWithoutNote_interInput, MatiereUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutNote_interInput
    upsert?: MatiereUpsertWithoutNote_interInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutNote_interInput, MatiereUpdateWithoutNote_interInput>, MatiereUncheckedUpdateWithoutNote_interInput>
  }

  export type TrimestreUpdateOneRequiredWithoutNote_interNestedInput = {
    create?: XOR<TrimestreCreateWithoutNote_interInput, TrimestreUncheckedCreateWithoutNote_interInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutNote_interInput
    upsert?: TrimestreUpsertWithoutNote_interInput
    connect?: TrimestreWhereUniqueInput
    update?: XOR<XOR<TrimestreUpdateToOneWithWhereWithoutNote_interInput, TrimestreUpdateWithoutNote_interInput>, TrimestreUncheckedUpdateWithoutNote_interInput>
  }

  export type EleveCreateNestedOneWithoutNote_devoirInput = {
    create?: XOR<EleveCreateWithoutNote_devoirInput, EleveUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: EleveCreateOrConnectWithoutNote_devoirInput
    connect?: EleveWhereUniqueInput
  }

  export type EnseignantCreateNestedOneWithoutNote_devoirInput = {
    create?: XOR<EnseignantCreateWithoutNote_devoirInput, EnseignantUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutNote_devoirInput
    connect?: EnseignantWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutNote_devoirInput = {
    create?: XOR<MatiereCreateWithoutNote_devoirInput, MatiereUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutNote_devoirInput
    connect?: MatiereWhereUniqueInput
  }

  export type TrimestreCreateNestedOneWithoutNote_devoirInput = {
    create?: XOR<TrimestreCreateWithoutNote_devoirInput, TrimestreUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutNote_devoirInput
    connect?: TrimestreWhereUniqueInput
  }

  export type EleveUpdateOneRequiredWithoutNote_devoirNestedInput = {
    create?: XOR<EleveCreateWithoutNote_devoirInput, EleveUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: EleveCreateOrConnectWithoutNote_devoirInput
    upsert?: EleveUpsertWithoutNote_devoirInput
    connect?: EleveWhereUniqueInput
    update?: XOR<XOR<EleveUpdateToOneWithWhereWithoutNote_devoirInput, EleveUpdateWithoutNote_devoirInput>, EleveUncheckedUpdateWithoutNote_devoirInput>
  }

  export type EnseignantUpdateOneRequiredWithoutNote_devoirNestedInput = {
    create?: XOR<EnseignantCreateWithoutNote_devoirInput, EnseignantUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: EnseignantCreateOrConnectWithoutNote_devoirInput
    upsert?: EnseignantUpsertWithoutNote_devoirInput
    connect?: EnseignantWhereUniqueInput
    update?: XOR<XOR<EnseignantUpdateToOneWithWhereWithoutNote_devoirInput, EnseignantUpdateWithoutNote_devoirInput>, EnseignantUncheckedUpdateWithoutNote_devoirInput>
  }

  export type MatiereUpdateOneRequiredWithoutNote_devoirNestedInput = {
    create?: XOR<MatiereCreateWithoutNote_devoirInput, MatiereUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutNote_devoirInput
    upsert?: MatiereUpsertWithoutNote_devoirInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<XOR<MatiereUpdateToOneWithWhereWithoutNote_devoirInput, MatiereUpdateWithoutNote_devoirInput>, MatiereUncheckedUpdateWithoutNote_devoirInput>
  }

  export type TrimestreUpdateOneRequiredWithoutNote_devoirNestedInput = {
    create?: XOR<TrimestreCreateWithoutNote_devoirInput, TrimestreUncheckedCreateWithoutNote_devoirInput>
    connectOrCreate?: TrimestreCreateOrConnectWithoutNote_devoirInput
    upsert?: TrimestreUpsertWithoutNote_devoirInput
    connect?: TrimestreWhereUniqueInput
    update?: XOR<XOR<TrimestreUpdateToOneWithWhereWithoutNote_devoirInput, TrimestreUpdateWithoutNote_devoirInput>, TrimestreUncheckedUpdateWithoutNote_devoirInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EleveCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_parent: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutClasseInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput>
  }

  export type EleveCreateManyClasseInputEnvelope = {
    data: EleveCreateManyClasseInput | EleveCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type Enseignant_ClasseCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    enseignant: EnseignantCreateNestedOneWithoutEnseignant_classeInput
    matiere: MatiereCreateNestedOneWithoutEnseignant_matiereInput
  }

  export type Enseignant_ClasseUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_matiere: number
  }

  export type Enseignant_ClasseCreateOrConnectWithoutClasseInput = {
    where: Enseignant_ClasseWhereUniqueInput
    create: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput>
  }

  export type Enseignant_ClasseCreateManyClasseInputEnvelope = {
    data: Enseignant_ClasseCreateManyClasseInput | Enseignant_ClasseCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type PieceJointeCreateWithoutClasseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    matiere: MatiereCreateNestedOneWithoutPiecejointeInput
    enseignant: EnseignantCreateNestedOneWithoutPiecejointeInput
  }

  export type PieceJointeUncheckedCreateWithoutClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_matiere: number
    id_enseignant: number
  }

  export type PieceJointeCreateOrConnectWithoutClasseInput = {
    where: PieceJointeWhereUniqueInput
    create: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput>
  }

  export type PieceJointeCreateManyClasseInputEnvelope = {
    data: PieceJointeCreateManyClasseInput | PieceJointeCreateManyClasseInput[]
    skipDuplicates?: boolean
  }

  export type EleveUpsertWithWhereUniqueWithoutClasseInput = {
    where: EleveWhereUniqueInput
    update: XOR<EleveUpdateWithoutClasseInput, EleveUncheckedUpdateWithoutClasseInput>
    create: XOR<EleveCreateWithoutClasseInput, EleveUncheckedCreateWithoutClasseInput>
  }

  export type EleveUpdateWithWhereUniqueWithoutClasseInput = {
    where: EleveWhereUniqueInput
    data: XOR<EleveUpdateWithoutClasseInput, EleveUncheckedUpdateWithoutClasseInput>
  }

  export type EleveUpdateManyWithWhereWithoutClasseInput = {
    where: EleveScalarWhereInput
    data: XOR<EleveUpdateManyMutationInput, EleveUncheckedUpdateManyWithoutClasseInput>
  }

  export type EleveScalarWhereInput = {
    AND?: EleveScalarWhereInput | EleveScalarWhereInput[]
    OR?: EleveScalarWhereInput[]
    NOT?: EleveScalarWhereInput | EleveScalarWhereInput[]
    id?: IntFilter<"Eleve"> | number
    createdAt?: DateTimeFilter<"Eleve"> | Date | string
    updatedAt?: DateTimeFilter<"Eleve"> | Date | string
    nom?: StringFilter<"Eleve"> | string
    prenom?: StringFilter<"Eleve"> | string
    email?: StringNullableFilter<"Eleve"> | string | null
    photo?: BytesNullableFilter<"Eleve"> | Buffer | null
    sexe?: StringFilter<"Eleve"> | string
    id_classe?: IntFilter<"Eleve"> | number
    id_parent?: IntFilter<"Eleve"> | number
    username?: StringFilter<"Eleve"> | string
    password?: StringFilter<"Eleve"> | string
    role?: StringFilter<"Eleve"> | string
  }

  export type Enseignant_ClasseUpsertWithWhereUniqueWithoutClasseInput = {
    where: Enseignant_ClasseWhereUniqueInput
    update: XOR<Enseignant_ClasseUpdateWithoutClasseInput, Enseignant_ClasseUncheckedUpdateWithoutClasseInput>
    create: XOR<Enseignant_ClasseCreateWithoutClasseInput, Enseignant_ClasseUncheckedCreateWithoutClasseInput>
  }

  export type Enseignant_ClasseUpdateWithWhereUniqueWithoutClasseInput = {
    where: Enseignant_ClasseWhereUniqueInput
    data: XOR<Enseignant_ClasseUpdateWithoutClasseInput, Enseignant_ClasseUncheckedUpdateWithoutClasseInput>
  }

  export type Enseignant_ClasseUpdateManyWithWhereWithoutClasseInput = {
    where: Enseignant_ClasseScalarWhereInput
    data: XOR<Enseignant_ClasseUpdateManyMutationInput, Enseignant_ClasseUncheckedUpdateManyWithoutClasseInput>
  }

  export type Enseignant_ClasseScalarWhereInput = {
    AND?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
    OR?: Enseignant_ClasseScalarWhereInput[]
    NOT?: Enseignant_ClasseScalarWhereInput | Enseignant_ClasseScalarWhereInput[]
    id?: IntFilter<"Enseignant_Classe"> | number
    createdAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    updatedAt?: DateTimeFilter<"Enseignant_Classe"> | Date | string
    id_enseignant?: IntFilter<"Enseignant_Classe"> | number
    id_classe?: IntFilter<"Enseignant_Classe"> | number
    id_matiere?: IntFilter<"Enseignant_Classe"> | number
  }

  export type PieceJointeUpsertWithWhereUniqueWithoutClasseInput = {
    where: PieceJointeWhereUniqueInput
    update: XOR<PieceJointeUpdateWithoutClasseInput, PieceJointeUncheckedUpdateWithoutClasseInput>
    create: XOR<PieceJointeCreateWithoutClasseInput, PieceJointeUncheckedCreateWithoutClasseInput>
  }

  export type PieceJointeUpdateWithWhereUniqueWithoutClasseInput = {
    where: PieceJointeWhereUniqueInput
    data: XOR<PieceJointeUpdateWithoutClasseInput, PieceJointeUncheckedUpdateWithoutClasseInput>
  }

  export type PieceJointeUpdateManyWithWhereWithoutClasseInput = {
    where: PieceJointeScalarWhereInput
    data: XOR<PieceJointeUpdateManyMutationInput, PieceJointeUncheckedUpdateManyWithoutClasseInput>
  }

  export type PieceJointeScalarWhereInput = {
    AND?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
    OR?: PieceJointeScalarWhereInput[]
    NOT?: PieceJointeScalarWhereInput | PieceJointeScalarWhereInput[]
    id?: IntFilter<"PieceJointe"> | number
    createdAt?: DateTimeFilter<"PieceJointe"> | Date | string
    updatedAt?: DateTimeFilter<"PieceJointe"> | Date | string
    titre?: StringFilter<"PieceJointe"> | string
    piece?: BytesFilter<"PieceJointe"> | Buffer
    id_classe?: IntFilter<"PieceJointe"> | number
    id_matiere?: IntFilter<"PieceJointe"> | number
    id_enseignant?: IntFilter<"PieceJointe"> | number
  }

  export type Note_interCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_interInput
    enseignant: EnseignantCreateNestedOneWithoutNote_interInput
    trimestre: TrimestreCreateNestedOneWithoutNote_interInput
  }

  export type Note_interUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interCreateOrConnectWithoutMatiereInput = {
    where: Note_interWhereUniqueInput
    create: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput>
  }

  export type Note_interCreateManyMatiereInputEnvelope = {
    data: Note_interCreateManyMatiereInput | Note_interCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type Note_devoirCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_devoirInput
    enseignant: EnseignantCreateNestedOneWithoutNote_devoirInput
    trimestre: TrimestreCreateNestedOneWithoutNote_devoirInput
  }

  export type Note_devoirUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateOrConnectWithoutMatiereInput = {
    where: Note_devoirWhereUniqueInput
    create: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput>
  }

  export type Note_devoirCreateManyMatiereInputEnvelope = {
    data: Note_devoirCreateManyMatiereInput | Note_devoirCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type RangCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    eleve: EleveCreateNestedOneWithoutRangInput
    trimestre: TrimestreCreateNestedOneWithoutRangInput
  }

  export type RangUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_eleve: number
    id_trimestre: number
  }

  export type RangCreateOrConnectWithoutMatiereInput = {
    where: RangWhereUniqueInput
    create: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput>
  }

  export type RangCreateManyMatiereInputEnvelope = {
    data: RangCreateManyMatiereInput | RangCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type CoefficientCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    coefficient: number
  }

  export type CoefficientUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coefficient: number
  }

  export type CoefficientCreateOrConnectWithoutMatiereInput = {
    where: CoefficientWhereUniqueInput
    create: XOR<CoefficientCreateWithoutMatiereInput, CoefficientUncheckedCreateWithoutMatiereInput>
  }

  export type Enseignant_ClasseCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    enseignant: EnseignantCreateNestedOneWithoutEnseignant_classeInput
    classe: ClasseCreateNestedOneWithoutEnseignant_classeInput
  }

  export type Enseignant_ClasseUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_classe: number
  }

  export type Enseignant_ClasseCreateOrConnectWithoutMatiereInput = {
    where: Enseignant_ClasseWhereUniqueInput
    create: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput>
  }

  export type Enseignant_ClasseCreateManyMatiereInputEnvelope = {
    data: Enseignant_ClasseCreateManyMatiereInput | Enseignant_ClasseCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type CommentaireCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutCommentaireInput
    enseignant: EnseignantCreateNestedOneWithoutCommentaireInput
    trimestre: TrimestreCreateNestedOneWithoutCommenstaireInput
  }

  export type CommentaireUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireCreateOrConnectWithoutMatiereInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput>
  }

  export type CommentaireCreateManyMatiereInputEnvelope = {
    data: CommentaireCreateManyMatiereInput | CommentaireCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type PieceJointeCreateWithoutMatiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    classe: ClasseCreateNestedOneWithoutPiecejointeInput
    enseignant: EnseignantCreateNestedOneWithoutPiecejointeInput
  }

  export type PieceJointeUncheckedCreateWithoutMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_enseignant: number
  }

  export type PieceJointeCreateOrConnectWithoutMatiereInput = {
    where: PieceJointeWhereUniqueInput
    create: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput>
  }

  export type PieceJointeCreateManyMatiereInputEnvelope = {
    data: PieceJointeCreateManyMatiereInput | PieceJointeCreateManyMatiereInput[]
    skipDuplicates?: boolean
  }

  export type Note_interUpsertWithWhereUniqueWithoutMatiereInput = {
    where: Note_interWhereUniqueInput
    update: XOR<Note_interUpdateWithoutMatiereInput, Note_interUncheckedUpdateWithoutMatiereInput>
    create: XOR<Note_interCreateWithoutMatiereInput, Note_interUncheckedCreateWithoutMatiereInput>
  }

  export type Note_interUpdateWithWhereUniqueWithoutMatiereInput = {
    where: Note_interWhereUniqueInput
    data: XOR<Note_interUpdateWithoutMatiereInput, Note_interUncheckedUpdateWithoutMatiereInput>
  }

  export type Note_interUpdateManyWithWhereWithoutMatiereInput = {
    where: Note_interScalarWhereInput
    data: XOR<Note_interUpdateManyMutationInput, Note_interUncheckedUpdateManyWithoutMatiereInput>
  }

  export type Note_interScalarWhereInput = {
    AND?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
    OR?: Note_interScalarWhereInput[]
    NOT?: Note_interScalarWhereInput | Note_interScalarWhereInput[]
    id?: IntFilter<"Note_inter"> | number
    createdAt?: DateTimeFilter<"Note_inter"> | Date | string
    updatedAt?: DateTimeFilter<"Note_inter"> | Date | string
    inter?: FloatFilter<"Note_inter"> | number
    id_eleve?: IntFilter<"Note_inter"> | number
    id_enseignant?: IntFilter<"Note_inter"> | number
    id_matiere?: IntFilter<"Note_inter"> | number
    id_trimestre?: IntFilter<"Note_inter"> | number
    vu?: BoolFilter<"Note_inter"> | boolean
  }

  export type Note_devoirUpsertWithWhereUniqueWithoutMatiereInput = {
    where: Note_devoirWhereUniqueInput
    update: XOR<Note_devoirUpdateWithoutMatiereInput, Note_devoirUncheckedUpdateWithoutMatiereInput>
    create: XOR<Note_devoirCreateWithoutMatiereInput, Note_devoirUncheckedCreateWithoutMatiereInput>
  }

  export type Note_devoirUpdateWithWhereUniqueWithoutMatiereInput = {
    where: Note_devoirWhereUniqueInput
    data: XOR<Note_devoirUpdateWithoutMatiereInput, Note_devoirUncheckedUpdateWithoutMatiereInput>
  }

  export type Note_devoirUpdateManyWithWhereWithoutMatiereInput = {
    where: Note_devoirScalarWhereInput
    data: XOR<Note_devoirUpdateManyMutationInput, Note_devoirUncheckedUpdateManyWithoutMatiereInput>
  }

  export type Note_devoirScalarWhereInput = {
    AND?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
    OR?: Note_devoirScalarWhereInput[]
    NOT?: Note_devoirScalarWhereInput | Note_devoirScalarWhereInput[]
    id?: IntFilter<"Note_devoir"> | number
    createdAt?: DateTimeFilter<"Note_devoir"> | Date | string
    updatedAt?: DateTimeFilter<"Note_devoir"> | Date | string
    devoir?: FloatFilter<"Note_devoir"> | number
    id_eleve?: IntFilter<"Note_devoir"> | number
    id_enseignant?: IntFilter<"Note_devoir"> | number
    id_matiere?: IntFilter<"Note_devoir"> | number
    id_trimestre?: IntFilter<"Note_devoir"> | number
    vu?: BoolFilter<"Note_devoir"> | boolean
  }

  export type RangUpsertWithWhereUniqueWithoutMatiereInput = {
    where: RangWhereUniqueInput
    update: XOR<RangUpdateWithoutMatiereInput, RangUncheckedUpdateWithoutMatiereInput>
    create: XOR<RangCreateWithoutMatiereInput, RangUncheckedCreateWithoutMatiereInput>
  }

  export type RangUpdateWithWhereUniqueWithoutMatiereInput = {
    where: RangWhereUniqueInput
    data: XOR<RangUpdateWithoutMatiereInput, RangUncheckedUpdateWithoutMatiereInput>
  }

  export type RangUpdateManyWithWhereWithoutMatiereInput = {
    where: RangScalarWhereInput
    data: XOR<RangUpdateManyMutationInput, RangUncheckedUpdateManyWithoutMatiereInput>
  }

  export type RangScalarWhereInput = {
    AND?: RangScalarWhereInput | RangScalarWhereInput[]
    OR?: RangScalarWhereInput[]
    NOT?: RangScalarWhereInput | RangScalarWhereInput[]
    id?: IntFilter<"Rang"> | number
    createdAt?: DateTimeFilter<"Rang"> | Date | string
    updatedAt?: DateTimeFilter<"Rang"> | Date | string
    rang?: IntFilter<"Rang"> | number
    id_matiere?: IntFilter<"Rang"> | number
    id_eleve?: IntFilter<"Rang"> | number
    id_trimestre?: IntFilter<"Rang"> | number
  }

  export type CoefficientUpsertWithoutMatiereInput = {
    update: XOR<CoefficientUpdateWithoutMatiereInput, CoefficientUncheckedUpdateWithoutMatiereInput>
    create: XOR<CoefficientCreateWithoutMatiereInput, CoefficientUncheckedCreateWithoutMatiereInput>
    where?: CoefficientWhereInput
  }

  export type CoefficientUpdateToOneWithWhereWithoutMatiereInput = {
    where?: CoefficientWhereInput
    data: XOR<CoefficientUpdateWithoutMatiereInput, CoefficientUncheckedUpdateWithoutMatiereInput>
  }

  export type CoefficientUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
  }

  export type CoefficientUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coefficient?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseUpsertWithWhereUniqueWithoutMatiereInput = {
    where: Enseignant_ClasseWhereUniqueInput
    update: XOR<Enseignant_ClasseUpdateWithoutMatiereInput, Enseignant_ClasseUncheckedUpdateWithoutMatiereInput>
    create: XOR<Enseignant_ClasseCreateWithoutMatiereInput, Enseignant_ClasseUncheckedCreateWithoutMatiereInput>
  }

  export type Enseignant_ClasseUpdateWithWhereUniqueWithoutMatiereInput = {
    where: Enseignant_ClasseWhereUniqueInput
    data: XOR<Enseignant_ClasseUpdateWithoutMatiereInput, Enseignant_ClasseUncheckedUpdateWithoutMatiereInput>
  }

  export type Enseignant_ClasseUpdateManyWithWhereWithoutMatiereInput = {
    where: Enseignant_ClasseScalarWhereInput
    data: XOR<Enseignant_ClasseUpdateManyMutationInput, Enseignant_ClasseUncheckedUpdateManyWithoutMatiereInput>
  }

  export type CommentaireUpsertWithWhereUniqueWithoutMatiereInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutMatiereInput, CommentaireUncheckedUpdateWithoutMatiereInput>
    create: XOR<CommentaireCreateWithoutMatiereInput, CommentaireUncheckedCreateWithoutMatiereInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutMatiereInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutMatiereInput, CommentaireUncheckedUpdateWithoutMatiereInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutMatiereInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutMatiereInput>
  }

  export type CommentaireScalarWhereInput = {
    AND?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
    OR?: CommentaireScalarWhereInput[]
    NOT?: CommentaireScalarWhereInput | CommentaireScalarWhereInput[]
    id?: IntFilter<"Commentaire"> | number
    createdAt?: DateTimeFilter<"Commentaire"> | Date | string
    updatedAt?: DateTimeFilter<"Commentaire"> | Date | string
    contenu?: StringFilter<"Commentaire"> | string
    id_eleve?: IntFilter<"Commentaire"> | number
    id_enseignant?: IntFilter<"Commentaire"> | number
    id_matiere?: IntFilter<"Commentaire"> | number
    id_trimestre?: IntFilter<"Commentaire"> | number
    vu?: BoolFilter<"Commentaire"> | boolean
  }

  export type PieceJointeUpsertWithWhereUniqueWithoutMatiereInput = {
    where: PieceJointeWhereUniqueInput
    update: XOR<PieceJointeUpdateWithoutMatiereInput, PieceJointeUncheckedUpdateWithoutMatiereInput>
    create: XOR<PieceJointeCreateWithoutMatiereInput, PieceJointeUncheckedCreateWithoutMatiereInput>
  }

  export type PieceJointeUpdateWithWhereUniqueWithoutMatiereInput = {
    where: PieceJointeWhereUniqueInput
    data: XOR<PieceJointeUpdateWithoutMatiereInput, PieceJointeUncheckedUpdateWithoutMatiereInput>
  }

  export type PieceJointeUpdateManyWithWhereWithoutMatiereInput = {
    where: PieceJointeScalarWhereInput
    data: XOR<PieceJointeUpdateManyMutationInput, PieceJointeUncheckedUpdateManyWithoutMatiereInput>
  }

  export type MatiereCreateWithoutRangInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutRangInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutRangInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutRangInput, MatiereUncheckedCreateWithoutRangInput>
  }

  export type EleveCreateWithoutRangInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutRangInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutRangInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutRangInput, EleveUncheckedCreateWithoutRangInput>
  }

  export type TrimestreCreateWithoutRangInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUncheckedCreateWithoutRangInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireUncheckedCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreCreateOrConnectWithoutRangInput = {
    where: TrimestreWhereUniqueInput
    create: XOR<TrimestreCreateWithoutRangInput, TrimestreUncheckedCreateWithoutRangInput>
  }

  export type MatiereUpsertWithoutRangInput = {
    update: XOR<MatiereUpdateWithoutRangInput, MatiereUncheckedUpdateWithoutRangInput>
    create: XOR<MatiereCreateWithoutRangInput, MatiereUncheckedCreateWithoutRangInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutRangInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutRangInput, MatiereUncheckedUpdateWithoutRangInput>
  }

  export type MatiereUpdateWithoutRangInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutRangInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type EleveUpsertWithoutRangInput = {
    update: XOR<EleveUpdateWithoutRangInput, EleveUncheckedUpdateWithoutRangInput>
    create: XOR<EleveCreateWithoutRangInput, EleveUncheckedCreateWithoutRangInput>
    where?: EleveWhereInput
  }

  export type EleveUpdateToOneWithWhereWithoutRangInput = {
    where?: EleveWhereInput
    data: XOR<EleveUpdateWithoutRangInput, EleveUncheckedUpdateWithoutRangInput>
  }

  export type EleveUpdateWithoutRangInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutRangInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type TrimestreUpsertWithoutRangInput = {
    update: XOR<TrimestreUpdateWithoutRangInput, TrimestreUncheckedUpdateWithoutRangInput>
    create: XOR<TrimestreCreateWithoutRangInput, TrimestreUncheckedCreateWithoutRangInput>
    where?: TrimestreWhereInput
  }

  export type TrimestreUpdateToOneWithWhereWithoutRangInput = {
    where?: TrimestreWhereInput
    data: XOR<TrimestreUpdateWithoutRangInput, TrimestreUncheckedUpdateWithoutRangInput>
  }

  export type TrimestreUpdateWithoutRangInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreUncheckedUpdateWithoutRangInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUncheckedUpdateManyWithoutTrimestreNestedInput
  }

  export type MatiereCreateWithoutCoeffientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutCoeffientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutCoeffientInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput>
  }

  export type MatiereCreateManyCoeffientInputEnvelope = {
    data: MatiereCreateManyCoeffientInput | MatiereCreateManyCoeffientInput[]
    skipDuplicates?: boolean
  }

  export type MatiereUpsertWithWhereUniqueWithoutCoeffientInput = {
    where: MatiereWhereUniqueInput
    update: XOR<MatiereUpdateWithoutCoeffientInput, MatiereUncheckedUpdateWithoutCoeffientInput>
    create: XOR<MatiereCreateWithoutCoeffientInput, MatiereUncheckedCreateWithoutCoeffientInput>
  }

  export type MatiereUpdateWithWhereUniqueWithoutCoeffientInput = {
    where: MatiereWhereUniqueInput
    data: XOR<MatiereUpdateWithoutCoeffientInput, MatiereUncheckedUpdateWithoutCoeffientInput>
  }

  export type MatiereUpdateManyWithWhereWithoutCoeffientInput = {
    where: MatiereScalarWhereInput
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyWithoutCoeffientInput>
  }

  export type MatiereScalarWhereInput = {
    AND?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
    OR?: MatiereScalarWhereInput[]
    NOT?: MatiereScalarWhereInput | MatiereScalarWhereInput[]
    id?: IntFilter<"Matiere"> | number
    createdAt?: DateTimeFilter<"Matiere"> | Date | string
    updatedAt?: DateTimeFilter<"Matiere"> | Date | string
    matiere?: StringFilter<"Matiere"> | string
    id_coefficient?: IntFilter<"Matiere"> | number
  }

  export type EleveCreateWithoutParentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutParentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutParentInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput>
  }

  export type EleveCreateManyParentInputEnvelope = {
    data: EleveCreateManyParentInput | EleveCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type EleveUpsertWithWhereUniqueWithoutParentInput = {
    where: EleveWhereUniqueInput
    update: XOR<EleveUpdateWithoutParentInput, EleveUncheckedUpdateWithoutParentInput>
    create: XOR<EleveCreateWithoutParentInput, EleveUncheckedCreateWithoutParentInput>
  }

  export type EleveUpdateWithWhereUniqueWithoutParentInput = {
    where: EleveWhereUniqueInput
    data: XOR<EleveUpdateWithoutParentInput, EleveUncheckedUpdateWithoutParentInput>
  }

  export type EleveUpdateManyWithWhereWithoutParentInput = {
    where: EleveScalarWhereInput
    data: XOR<EleveUpdateManyMutationInput, EleveUncheckedUpdateManyWithoutParentInput>
  }

  export type Enseignant_ClasseCreateWithoutEnseignantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    classe: ClasseCreateNestedOneWithoutEnseignant_classeInput
    matiere: MatiereCreateNestedOneWithoutEnseignant_matiereInput
  }

  export type Enseignant_ClasseUncheckedCreateWithoutEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_classe: number
    id_matiere: number
  }

  export type Enseignant_ClasseCreateOrConnectWithoutEnseignantInput = {
    where: Enseignant_ClasseWhereUniqueInput
    create: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput>
  }

  export type Enseignant_ClasseCreateManyEnseignantInputEnvelope = {
    data: Enseignant_ClasseCreateManyEnseignantInput | Enseignant_ClasseCreateManyEnseignantInput[]
    skipDuplicates?: boolean
  }

  export type Note_interCreateWithoutEnseignantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_interInput
    matiere: MatiereCreateNestedOneWithoutNote_interInput
    trimestre: TrimestreCreateNestedOneWithoutNote_interInput
  }

  export type Note_interUncheckedCreateWithoutEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interCreateOrConnectWithoutEnseignantInput = {
    where: Note_interWhereUniqueInput
    create: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput>
  }

  export type Note_interCreateManyEnseignantInputEnvelope = {
    data: Note_interCreateManyEnseignantInput | Note_interCreateManyEnseignantInput[]
    skipDuplicates?: boolean
  }

  export type Note_devoirCreateWithoutEnseignantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_devoirInput
    matiere: MatiereCreateNestedOneWithoutNote_devoirInput
    trimestre: TrimestreCreateNestedOneWithoutNote_devoirInput
  }

  export type Note_devoirUncheckedCreateWithoutEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateOrConnectWithoutEnseignantInput = {
    where: Note_devoirWhereUniqueInput
    create: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput>
  }

  export type Note_devoirCreateManyEnseignantInputEnvelope = {
    data: Note_devoirCreateManyEnseignantInput | Note_devoirCreateManyEnseignantInput[]
    skipDuplicates?: boolean
  }

  export type CommentaireCreateWithoutEnseignantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutCommentaireInput
    matiere: MatiereCreateNestedOneWithoutCommentaireInput
    trimestre: TrimestreCreateNestedOneWithoutCommenstaireInput
  }

  export type CommentaireUncheckedCreateWithoutEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireCreateOrConnectWithoutEnseignantInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput>
  }

  export type CommentaireCreateManyEnseignantInputEnvelope = {
    data: CommentaireCreateManyEnseignantInput | CommentaireCreateManyEnseignantInput[]
    skipDuplicates?: boolean
  }

  export type PieceJointeCreateWithoutEnseignantInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    classe: ClasseCreateNestedOneWithoutPiecejointeInput
    matiere: MatiereCreateNestedOneWithoutPiecejointeInput
  }

  export type PieceJointeUncheckedCreateWithoutEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_matiere: number
  }

  export type PieceJointeCreateOrConnectWithoutEnseignantInput = {
    where: PieceJointeWhereUniqueInput
    create: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput>
  }

  export type PieceJointeCreateManyEnseignantInputEnvelope = {
    data: PieceJointeCreateManyEnseignantInput | PieceJointeCreateManyEnseignantInput[]
    skipDuplicates?: boolean
  }

  export type Enseignant_ClasseUpsertWithWhereUniqueWithoutEnseignantInput = {
    where: Enseignant_ClasseWhereUniqueInput
    update: XOR<Enseignant_ClasseUpdateWithoutEnseignantInput, Enseignant_ClasseUncheckedUpdateWithoutEnseignantInput>
    create: XOR<Enseignant_ClasseCreateWithoutEnseignantInput, Enseignant_ClasseUncheckedCreateWithoutEnseignantInput>
  }

  export type Enseignant_ClasseUpdateWithWhereUniqueWithoutEnseignantInput = {
    where: Enseignant_ClasseWhereUniqueInput
    data: XOR<Enseignant_ClasseUpdateWithoutEnseignantInput, Enseignant_ClasseUncheckedUpdateWithoutEnseignantInput>
  }

  export type Enseignant_ClasseUpdateManyWithWhereWithoutEnseignantInput = {
    where: Enseignant_ClasseScalarWhereInput
    data: XOR<Enseignant_ClasseUpdateManyMutationInput, Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantInput>
  }

  export type Note_interUpsertWithWhereUniqueWithoutEnseignantInput = {
    where: Note_interWhereUniqueInput
    update: XOR<Note_interUpdateWithoutEnseignantInput, Note_interUncheckedUpdateWithoutEnseignantInput>
    create: XOR<Note_interCreateWithoutEnseignantInput, Note_interUncheckedCreateWithoutEnseignantInput>
  }

  export type Note_interUpdateWithWhereUniqueWithoutEnseignantInput = {
    where: Note_interWhereUniqueInput
    data: XOR<Note_interUpdateWithoutEnseignantInput, Note_interUncheckedUpdateWithoutEnseignantInput>
  }

  export type Note_interUpdateManyWithWhereWithoutEnseignantInput = {
    where: Note_interScalarWhereInput
    data: XOR<Note_interUpdateManyMutationInput, Note_interUncheckedUpdateManyWithoutEnseignantInput>
  }

  export type Note_devoirUpsertWithWhereUniqueWithoutEnseignantInput = {
    where: Note_devoirWhereUniqueInput
    update: XOR<Note_devoirUpdateWithoutEnseignantInput, Note_devoirUncheckedUpdateWithoutEnseignantInput>
    create: XOR<Note_devoirCreateWithoutEnseignantInput, Note_devoirUncheckedCreateWithoutEnseignantInput>
  }

  export type Note_devoirUpdateWithWhereUniqueWithoutEnseignantInput = {
    where: Note_devoirWhereUniqueInput
    data: XOR<Note_devoirUpdateWithoutEnseignantInput, Note_devoirUncheckedUpdateWithoutEnseignantInput>
  }

  export type Note_devoirUpdateManyWithWhereWithoutEnseignantInput = {
    where: Note_devoirScalarWhereInput
    data: XOR<Note_devoirUpdateManyMutationInput, Note_devoirUncheckedUpdateManyWithoutEnseignantInput>
  }

  export type CommentaireUpsertWithWhereUniqueWithoutEnseignantInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutEnseignantInput, CommentaireUncheckedUpdateWithoutEnseignantInput>
    create: XOR<CommentaireCreateWithoutEnseignantInput, CommentaireUncheckedCreateWithoutEnseignantInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutEnseignantInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutEnseignantInput, CommentaireUncheckedUpdateWithoutEnseignantInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutEnseignantInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutEnseignantInput>
  }

  export type PieceJointeUpsertWithWhereUniqueWithoutEnseignantInput = {
    where: PieceJointeWhereUniqueInput
    update: XOR<PieceJointeUpdateWithoutEnseignantInput, PieceJointeUncheckedUpdateWithoutEnseignantInput>
    create: XOR<PieceJointeCreateWithoutEnseignantInput, PieceJointeUncheckedCreateWithoutEnseignantInput>
  }

  export type PieceJointeUpdateWithWhereUniqueWithoutEnseignantInput = {
    where: PieceJointeWhereUniqueInput
    data: XOR<PieceJointeUpdateWithoutEnseignantInput, PieceJointeUncheckedUpdateWithoutEnseignantInput>
  }

  export type PieceJointeUpdateManyWithWhereWithoutEnseignantInput = {
    where: PieceJointeScalarWhereInput
    data: XOR<PieceJointeUpdateManyMutationInput, PieceJointeUncheckedUpdateManyWithoutEnseignantInput>
  }

  export type ClasseCreateWithoutElevesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateWithoutElevesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutElevesInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutElevesInput, ClasseUncheckedCreateWithoutElevesInput>
  }

  export type ParentCreateWithoutEnfantsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type ParentUncheckedCreateWithoutEnfantsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
  }

  export type ParentCreateOrConnectWithoutEnfantsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutEnfantsInput, ParentUncheckedCreateWithoutEnfantsInput>
  }

  export type Note_interCreateWithoutEleveInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    vu?: boolean
    enseignant: EnseignantCreateNestedOneWithoutNote_interInput
    matiere: MatiereCreateNestedOneWithoutNote_interInput
    trimestre: TrimestreCreateNestedOneWithoutNote_interInput
  }

  export type Note_interUncheckedCreateWithoutEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interCreateOrConnectWithoutEleveInput = {
    where: Note_interWhereUniqueInput
    create: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput>
  }

  export type Note_interCreateManyEleveInputEnvelope = {
    data: Note_interCreateManyEleveInput | Note_interCreateManyEleveInput[]
    skipDuplicates?: boolean
  }

  export type Note_devoirCreateWithoutEleveInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    vu?: boolean
    enseignant: EnseignantCreateNestedOneWithoutNote_devoirInput
    matiere: MatiereCreateNestedOneWithoutNote_devoirInput
    trimestre: TrimestreCreateNestedOneWithoutNote_devoirInput
  }

  export type Note_devoirUncheckedCreateWithoutEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateOrConnectWithoutEleveInput = {
    where: Note_devoirWhereUniqueInput
    create: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput>
  }

  export type Note_devoirCreateManyEleveInputEnvelope = {
    data: Note_devoirCreateManyEleveInput | Note_devoirCreateManyEleveInput[]
    skipDuplicates?: boolean
  }

  export type RangCreateWithoutEleveInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    matiere: MatiereCreateNestedOneWithoutRangInput
    trimestre: TrimestreCreateNestedOneWithoutRangInput
  }

  export type RangUncheckedCreateWithoutEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_trimestre: number
  }

  export type RangCreateOrConnectWithoutEleveInput = {
    where: RangWhereUniqueInput
    create: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput>
  }

  export type RangCreateManyEleveInputEnvelope = {
    data: RangCreateManyEleveInput | RangCreateManyEleveInput[]
    skipDuplicates?: boolean
  }

  export type CommentaireCreateWithoutEleveInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    vu?: boolean
    enseignant: EnseignantCreateNestedOneWithoutCommentaireInput
    matiere: MatiereCreateNestedOneWithoutCommentaireInput
    trimestre: TrimestreCreateNestedOneWithoutCommenstaireInput
  }

  export type CommentaireUncheckedCreateWithoutEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireCreateOrConnectWithoutEleveInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput>
  }

  export type CommentaireCreateManyEleveInputEnvelope = {
    data: CommentaireCreateManyEleveInput | CommentaireCreateManyEleveInput[]
    skipDuplicates?: boolean
  }

  export type ClasseUpsertWithoutElevesInput = {
    update: XOR<ClasseUpdateWithoutElevesInput, ClasseUncheckedUpdateWithoutElevesInput>
    create: XOR<ClasseCreateWithoutElevesInput, ClasseUncheckedCreateWithoutElevesInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutElevesInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutElevesInput, ClasseUncheckedUpdateWithoutElevesInput>
  }

  export type ClasseUpdateWithoutElevesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateWithoutElevesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type ParentUpsertWithoutEnfantsInput = {
    update: XOR<ParentUpdateWithoutEnfantsInput, ParentUncheckedUpdateWithoutEnfantsInput>
    create: XOR<ParentCreateWithoutEnfantsInput, ParentUncheckedCreateWithoutEnfantsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutEnfantsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutEnfantsInput, ParentUncheckedUpdateWithoutEnfantsInput>
  }

  export type ParentUpdateWithoutEnfantsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ParentUncheckedUpdateWithoutEnfantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type Note_interUpsertWithWhereUniqueWithoutEleveInput = {
    where: Note_interWhereUniqueInput
    update: XOR<Note_interUpdateWithoutEleveInput, Note_interUncheckedUpdateWithoutEleveInput>
    create: XOR<Note_interCreateWithoutEleveInput, Note_interUncheckedCreateWithoutEleveInput>
  }

  export type Note_interUpdateWithWhereUniqueWithoutEleveInput = {
    where: Note_interWhereUniqueInput
    data: XOR<Note_interUpdateWithoutEleveInput, Note_interUncheckedUpdateWithoutEleveInput>
  }

  export type Note_interUpdateManyWithWhereWithoutEleveInput = {
    where: Note_interScalarWhereInput
    data: XOR<Note_interUpdateManyMutationInput, Note_interUncheckedUpdateManyWithoutEleveInput>
  }

  export type Note_devoirUpsertWithWhereUniqueWithoutEleveInput = {
    where: Note_devoirWhereUniqueInput
    update: XOR<Note_devoirUpdateWithoutEleveInput, Note_devoirUncheckedUpdateWithoutEleveInput>
    create: XOR<Note_devoirCreateWithoutEleveInput, Note_devoirUncheckedCreateWithoutEleveInput>
  }

  export type Note_devoirUpdateWithWhereUniqueWithoutEleveInput = {
    where: Note_devoirWhereUniqueInput
    data: XOR<Note_devoirUpdateWithoutEleveInput, Note_devoirUncheckedUpdateWithoutEleveInput>
  }

  export type Note_devoirUpdateManyWithWhereWithoutEleveInput = {
    where: Note_devoirScalarWhereInput
    data: XOR<Note_devoirUpdateManyMutationInput, Note_devoirUncheckedUpdateManyWithoutEleveInput>
  }

  export type RangUpsertWithWhereUniqueWithoutEleveInput = {
    where: RangWhereUniqueInput
    update: XOR<RangUpdateWithoutEleveInput, RangUncheckedUpdateWithoutEleveInput>
    create: XOR<RangCreateWithoutEleveInput, RangUncheckedCreateWithoutEleveInput>
  }

  export type RangUpdateWithWhereUniqueWithoutEleveInput = {
    where: RangWhereUniqueInput
    data: XOR<RangUpdateWithoutEleveInput, RangUncheckedUpdateWithoutEleveInput>
  }

  export type RangUpdateManyWithWhereWithoutEleveInput = {
    where: RangScalarWhereInput
    data: XOR<RangUpdateManyMutationInput, RangUncheckedUpdateManyWithoutEleveInput>
  }

  export type CommentaireUpsertWithWhereUniqueWithoutEleveInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutEleveInput, CommentaireUncheckedUpdateWithoutEleveInput>
    create: XOR<CommentaireCreateWithoutEleveInput, CommentaireUncheckedCreateWithoutEleveInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutEleveInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutEleveInput, CommentaireUncheckedUpdateWithoutEleveInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutEleveInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutEleveInput>
  }

  export type EleveCreateWithoutCommentaireInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutCommentaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutCommentaireInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutCommentaireInput, EleveUncheckedCreateWithoutCommentaireInput>
  }

  export type EnseignantCreateWithoutCommentaireInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateWithoutCommentaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantCreateOrConnectWithoutCommentaireInput = {
    where: EnseignantWhereUniqueInput
    create: XOR<EnseignantCreateWithoutCommentaireInput, EnseignantUncheckedCreateWithoutCommentaireInput>
  }

  export type MatiereCreateWithoutCommentaireInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutCommentaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutCommentaireInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutCommentaireInput, MatiereUncheckedCreateWithoutCommentaireInput>
  }

  export type TrimestreCreateWithoutCommenstaireInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirCreateNestedManyWithoutTrimestreInput
    rang?: RangCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUncheckedCreateWithoutCommenstaireInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutTrimestreInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutTrimestreInput
    rang?: RangUncheckedCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreCreateOrConnectWithoutCommenstaireInput = {
    where: TrimestreWhereUniqueInput
    create: XOR<TrimestreCreateWithoutCommenstaireInput, TrimestreUncheckedCreateWithoutCommenstaireInput>
  }

  export type EleveUpsertWithoutCommentaireInput = {
    update: XOR<EleveUpdateWithoutCommentaireInput, EleveUncheckedUpdateWithoutCommentaireInput>
    create: XOR<EleveCreateWithoutCommentaireInput, EleveUncheckedCreateWithoutCommentaireInput>
    where?: EleveWhereInput
  }

  export type EleveUpdateToOneWithWhereWithoutCommentaireInput = {
    where?: EleveWhereInput
    data: XOR<EleveUpdateWithoutCommentaireInput, EleveUncheckedUpdateWithoutCommentaireInput>
  }

  export type EleveUpdateWithoutCommentaireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutCommentaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EnseignantUpsertWithoutCommentaireInput = {
    update: XOR<EnseignantUpdateWithoutCommentaireInput, EnseignantUncheckedUpdateWithoutCommentaireInput>
    create: XOR<EnseignantCreateWithoutCommentaireInput, EnseignantUncheckedCreateWithoutCommentaireInput>
    where?: EnseignantWhereInput
  }

  export type EnseignantUpdateToOneWithWhereWithoutCommentaireInput = {
    where?: EnseignantWhereInput
    data: XOR<EnseignantUpdateWithoutCommentaireInput, EnseignantUncheckedUpdateWithoutCommentaireInput>
  }

  export type EnseignantUpdateWithoutCommentaireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateWithoutCommentaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUncheckedUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type MatiereUpsertWithoutCommentaireInput = {
    update: XOR<MatiereUpdateWithoutCommentaireInput, MatiereUncheckedUpdateWithoutCommentaireInput>
    create: XOR<MatiereCreateWithoutCommentaireInput, MatiereUncheckedCreateWithoutCommentaireInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutCommentaireInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutCommentaireInput, MatiereUncheckedUpdateWithoutCommentaireInput>
  }

  export type MatiereUpdateWithoutCommentaireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutCommentaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type TrimestreUpsertWithoutCommenstaireInput = {
    update: XOR<TrimestreUpdateWithoutCommenstaireInput, TrimestreUncheckedUpdateWithoutCommenstaireInput>
    create: XOR<TrimestreCreateWithoutCommenstaireInput, TrimestreUncheckedCreateWithoutCommenstaireInput>
    where?: TrimestreWhereInput
  }

  export type TrimestreUpdateToOneWithWhereWithoutCommenstaireInput = {
    where?: TrimestreWhereInput
    data: XOR<TrimestreUpdateWithoutCommenstaireInput, TrimestreUncheckedUpdateWithoutCommenstaireInput>
  }

  export type TrimestreUpdateWithoutCommenstaireInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutTrimestreNestedInput
    rang?: RangUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreUncheckedUpdateWithoutCommenstaireInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutTrimestreNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutTrimestreNestedInput
    rang?: RangUncheckedUpdateManyWithoutTrimestreNestedInput
  }

  export type ClasseCreateWithoutPiecejointeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveCreateNestedManyWithoutClasseInput
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateWithoutPiecejointeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveUncheckedCreateNestedManyWithoutClasseInput
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutPiecejointeInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutPiecejointeInput, ClasseUncheckedCreateWithoutPiecejointeInput>
  }

  export type MatiereCreateWithoutPiecejointeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutPiecejointeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutPiecejointeInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutPiecejointeInput, MatiereUncheckedCreateWithoutPiecejointeInput>
  }

  export type EnseignantCreateWithoutPiecejointeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateWithoutPiecejointeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantCreateOrConnectWithoutPiecejointeInput = {
    where: EnseignantWhereUniqueInput
    create: XOR<EnseignantCreateWithoutPiecejointeInput, EnseignantUncheckedCreateWithoutPiecejointeInput>
  }

  export type ClasseUpsertWithoutPiecejointeInput = {
    update: XOR<ClasseUpdateWithoutPiecejointeInput, ClasseUncheckedUpdateWithoutPiecejointeInput>
    create: XOR<ClasseCreateWithoutPiecejointeInput, ClasseUncheckedCreateWithoutPiecejointeInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutPiecejointeInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutPiecejointeInput, ClasseUncheckedUpdateWithoutPiecejointeInput>
  }

  export type ClasseUpdateWithoutPiecejointeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUpdateManyWithoutClasseNestedInput
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateWithoutPiecejointeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUncheckedUpdateManyWithoutClasseNestedInput
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type MatiereUpsertWithoutPiecejointeInput = {
    update: XOR<MatiereUpdateWithoutPiecejointeInput, MatiereUncheckedUpdateWithoutPiecejointeInput>
    create: XOR<MatiereCreateWithoutPiecejointeInput, MatiereUncheckedCreateWithoutPiecejointeInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutPiecejointeInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutPiecejointeInput, MatiereUncheckedUpdateWithoutPiecejointeInput>
  }

  export type MatiereUpdateWithoutPiecejointeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutPiecejointeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type EnseignantUpsertWithoutPiecejointeInput = {
    update: XOR<EnseignantUpdateWithoutPiecejointeInput, EnseignantUncheckedUpdateWithoutPiecejointeInput>
    create: XOR<EnseignantCreateWithoutPiecejointeInput, EnseignantUncheckedCreateWithoutPiecejointeInput>
    where?: EnseignantWhereInput
  }

  export type EnseignantUpdateToOneWithWhereWithoutPiecejointeInput = {
    where?: EnseignantWhereInput
    data: XOR<EnseignantUpdateWithoutPiecejointeInput, EnseignantUncheckedUpdateWithoutPiecejointeInput>
  }

  export type EnseignantUpdateWithoutPiecejointeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateWithoutPiecejointeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUncheckedUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantCreateWithoutEnseignant_classeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    note_inter?: Note_interCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateWithoutEnseignant_classeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantCreateOrConnectWithoutEnseignant_classeInput = {
    where: EnseignantWhereUniqueInput
    create: XOR<EnseignantCreateWithoutEnseignant_classeInput, EnseignantUncheckedCreateWithoutEnseignant_classeInput>
  }

  export type ClasseCreateWithoutEnseignant_classeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeCreateNestedManyWithoutClasseInput
  }

  export type ClasseUncheckedCreateWithoutEnseignant_classeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    eleves?: EleveUncheckedCreateNestedManyWithoutClasseInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutClasseInput
  }

  export type ClasseCreateOrConnectWithoutEnseignant_classeInput = {
    where: ClasseWhereUniqueInput
    create: XOR<ClasseCreateWithoutEnseignant_classeInput, ClasseUncheckedCreateWithoutEnseignant_classeInput>
  }

  export type MatiereCreateWithoutEnseignant_matiereInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutEnseignant_matiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutEnseignant_matiereInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutEnseignant_matiereInput, MatiereUncheckedCreateWithoutEnseignant_matiereInput>
  }

  export type EnseignantUpsertWithoutEnseignant_classeInput = {
    update: XOR<EnseignantUpdateWithoutEnseignant_classeInput, EnseignantUncheckedUpdateWithoutEnseignant_classeInput>
    create: XOR<EnseignantCreateWithoutEnseignant_classeInput, EnseignantUncheckedCreateWithoutEnseignant_classeInput>
    where?: EnseignantWhereInput
  }

  export type EnseignantUpdateToOneWithWhereWithoutEnseignant_classeInput = {
    where?: EnseignantWhereInput
    data: XOR<EnseignantUpdateWithoutEnseignant_classeInput, EnseignantUncheckedUpdateWithoutEnseignant_classeInput>
  }

  export type EnseignantUpdateWithoutEnseignant_classeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateWithoutEnseignant_classeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type ClasseUpsertWithoutEnseignant_classeInput = {
    update: XOR<ClasseUpdateWithoutEnseignant_classeInput, ClasseUncheckedUpdateWithoutEnseignant_classeInput>
    create: XOR<ClasseCreateWithoutEnseignant_classeInput, ClasseUncheckedCreateWithoutEnseignant_classeInput>
    where?: ClasseWhereInput
  }

  export type ClasseUpdateToOneWithWhereWithoutEnseignant_classeInput = {
    where?: ClasseWhereInput
    data: XOR<ClasseUpdateWithoutEnseignant_classeInput, ClasseUncheckedUpdateWithoutEnseignant_classeInput>
  }

  export type ClasseUpdateWithoutEnseignant_classeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutClasseNestedInput
  }

  export type ClasseUncheckedUpdateWithoutEnseignant_classeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    eleves?: EleveUncheckedUpdateManyWithoutClasseNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutClasseNestedInput
  }

  export type MatiereUpsertWithoutEnseignant_matiereInput = {
    update: XOR<MatiereUpdateWithoutEnseignant_matiereInput, MatiereUncheckedUpdateWithoutEnseignant_matiereInput>
    create: XOR<MatiereCreateWithoutEnseignant_matiereInput, MatiereUncheckedCreateWithoutEnseignant_matiereInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutEnseignant_matiereInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutEnseignant_matiereInput, MatiereUncheckedUpdateWithoutEnseignant_matiereInput>
  }

  export type MatiereUpdateWithoutEnseignant_matiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutEnseignant_matiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type Note_interCreateWithoutTrimestreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_interInput
    enseignant: EnseignantCreateNestedOneWithoutNote_interInput
    matiere: MatiereCreateNestedOneWithoutNote_interInput
  }

  export type Note_interUncheckedCreateWithoutTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type Note_interCreateOrConnectWithoutTrimestreInput = {
    where: Note_interWhereUniqueInput
    create: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput>
  }

  export type Note_interCreateManyTrimestreInputEnvelope = {
    data: Note_interCreateManyTrimestreInput | Note_interCreateManyTrimestreInput[]
    skipDuplicates?: boolean
  }

  export type Note_devoirCreateWithoutTrimestreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutNote_devoirInput
    enseignant: EnseignantCreateNestedOneWithoutNote_devoirInput
    matiere: MatiereCreateNestedOneWithoutNote_devoirInput
  }

  export type Note_devoirUncheckedCreateWithoutTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type Note_devoirCreateOrConnectWithoutTrimestreInput = {
    where: Note_devoirWhereUniqueInput
    create: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput>
  }

  export type Note_devoirCreateManyTrimestreInputEnvelope = {
    data: Note_devoirCreateManyTrimestreInput | Note_devoirCreateManyTrimestreInput[]
    skipDuplicates?: boolean
  }

  export type RangCreateWithoutTrimestreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    matiere: MatiereCreateNestedOneWithoutRangInput
    eleve: EleveCreateNestedOneWithoutRangInput
  }

  export type RangUncheckedCreateWithoutTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_eleve: number
  }

  export type RangCreateOrConnectWithoutTrimestreInput = {
    where: RangWhereUniqueInput
    create: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput>
  }

  export type RangCreateManyTrimestreInputEnvelope = {
    data: RangCreateManyTrimestreInput | RangCreateManyTrimestreInput[]
    skipDuplicates?: boolean
  }

  export type CommentaireCreateWithoutTrimestreInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    vu?: boolean
    eleve: EleveCreateNestedOneWithoutCommentaireInput
    enseignant: EnseignantCreateNestedOneWithoutCommentaireInput
    matiere: MatiereCreateNestedOneWithoutCommentaireInput
  }

  export type CommentaireUncheckedCreateWithoutTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type CommentaireCreateOrConnectWithoutTrimestreInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput>
  }

  export type CommentaireCreateManyTrimestreInputEnvelope = {
    data: CommentaireCreateManyTrimestreInput | CommentaireCreateManyTrimestreInput[]
    skipDuplicates?: boolean
  }

  export type Note_interUpsertWithWhereUniqueWithoutTrimestreInput = {
    where: Note_interWhereUniqueInput
    update: XOR<Note_interUpdateWithoutTrimestreInput, Note_interUncheckedUpdateWithoutTrimestreInput>
    create: XOR<Note_interCreateWithoutTrimestreInput, Note_interUncheckedCreateWithoutTrimestreInput>
  }

  export type Note_interUpdateWithWhereUniqueWithoutTrimestreInput = {
    where: Note_interWhereUniqueInput
    data: XOR<Note_interUpdateWithoutTrimestreInput, Note_interUncheckedUpdateWithoutTrimestreInput>
  }

  export type Note_interUpdateManyWithWhereWithoutTrimestreInput = {
    where: Note_interScalarWhereInput
    data: XOR<Note_interUpdateManyMutationInput, Note_interUncheckedUpdateManyWithoutTrimestreInput>
  }

  export type Note_devoirUpsertWithWhereUniqueWithoutTrimestreInput = {
    where: Note_devoirWhereUniqueInput
    update: XOR<Note_devoirUpdateWithoutTrimestreInput, Note_devoirUncheckedUpdateWithoutTrimestreInput>
    create: XOR<Note_devoirCreateWithoutTrimestreInput, Note_devoirUncheckedCreateWithoutTrimestreInput>
  }

  export type Note_devoirUpdateWithWhereUniqueWithoutTrimestreInput = {
    where: Note_devoirWhereUniqueInput
    data: XOR<Note_devoirUpdateWithoutTrimestreInput, Note_devoirUncheckedUpdateWithoutTrimestreInput>
  }

  export type Note_devoirUpdateManyWithWhereWithoutTrimestreInput = {
    where: Note_devoirScalarWhereInput
    data: XOR<Note_devoirUpdateManyMutationInput, Note_devoirUncheckedUpdateManyWithoutTrimestreInput>
  }

  export type RangUpsertWithWhereUniqueWithoutTrimestreInput = {
    where: RangWhereUniqueInput
    update: XOR<RangUpdateWithoutTrimestreInput, RangUncheckedUpdateWithoutTrimestreInput>
    create: XOR<RangCreateWithoutTrimestreInput, RangUncheckedCreateWithoutTrimestreInput>
  }

  export type RangUpdateWithWhereUniqueWithoutTrimestreInput = {
    where: RangWhereUniqueInput
    data: XOR<RangUpdateWithoutTrimestreInput, RangUncheckedUpdateWithoutTrimestreInput>
  }

  export type RangUpdateManyWithWhereWithoutTrimestreInput = {
    where: RangScalarWhereInput
    data: XOR<RangUpdateManyMutationInput, RangUncheckedUpdateManyWithoutTrimestreInput>
  }

  export type CommentaireUpsertWithWhereUniqueWithoutTrimestreInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutTrimestreInput, CommentaireUncheckedUpdateWithoutTrimestreInput>
    create: XOR<CommentaireCreateWithoutTrimestreInput, CommentaireUncheckedCreateWithoutTrimestreInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutTrimestreInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutTrimestreInput, CommentaireUncheckedUpdateWithoutTrimestreInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutTrimestreInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutTrimestreInput>
  }

  export type EleveCreateWithoutNote_interInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutNote_interInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutNote_interInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutNote_interInput, EleveUncheckedCreateWithoutNote_interInput>
  }

  export type EnseignantCreateWithoutNote_interInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateWithoutNote_interInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantCreateOrConnectWithoutNote_interInput = {
    where: EnseignantWhereUniqueInput
    create: XOR<EnseignantCreateWithoutNote_interInput, EnseignantUncheckedCreateWithoutNote_interInput>
  }

  export type MatiereCreateWithoutNote_interInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_devoir?: Note_devoirCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutNote_interInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutNote_interInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutNote_interInput, MatiereUncheckedCreateWithoutNote_interInput>
  }

  export type TrimestreCreateWithoutNote_interInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_devoir?: Note_devoirCreateNestedManyWithoutTrimestreInput
    rang?: RangCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUncheckedCreateWithoutNote_interInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_devoir?: Note_devoirUncheckedCreateNestedManyWithoutTrimestreInput
    rang?: RangUncheckedCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireUncheckedCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreCreateOrConnectWithoutNote_interInput = {
    where: TrimestreWhereUniqueInput
    create: XOR<TrimestreCreateWithoutNote_interInput, TrimestreUncheckedCreateWithoutNote_interInput>
  }

  export type EleveUpsertWithoutNote_interInput = {
    update: XOR<EleveUpdateWithoutNote_interInput, EleveUncheckedUpdateWithoutNote_interInput>
    create: XOR<EleveCreateWithoutNote_interInput, EleveUncheckedCreateWithoutNote_interInput>
    where?: EleveWhereInput
  }

  export type EleveUpdateToOneWithWhereWithoutNote_interInput = {
    where?: EleveWhereInput
    data: XOR<EleveUpdateWithoutNote_interInput, EleveUncheckedUpdateWithoutNote_interInput>
  }

  export type EleveUpdateWithoutNote_interInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutNote_interInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EnseignantUpsertWithoutNote_interInput = {
    update: XOR<EnseignantUpdateWithoutNote_interInput, EnseignantUncheckedUpdateWithoutNote_interInput>
    create: XOR<EnseignantCreateWithoutNote_interInput, EnseignantUncheckedCreateWithoutNote_interInput>
    where?: EnseignantWhereInput
  }

  export type EnseignantUpdateToOneWithWhereWithoutNote_interInput = {
    where?: EnseignantWhereInput
    data: XOR<EnseignantUpdateWithoutNote_interInput, EnseignantUncheckedUpdateWithoutNote_interInput>
  }

  export type EnseignantUpdateWithoutNote_interInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateWithoutNote_interInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type MatiereUpsertWithoutNote_interInput = {
    update: XOR<MatiereUpdateWithoutNote_interInput, MatiereUncheckedUpdateWithoutNote_interInput>
    create: XOR<MatiereCreateWithoutNote_interInput, MatiereUncheckedCreateWithoutNote_interInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutNote_interInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutNote_interInput, MatiereUncheckedUpdateWithoutNote_interInput>
  }

  export type MatiereUpdateWithoutNote_interInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutNote_interInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type TrimestreUpsertWithoutNote_interInput = {
    update: XOR<TrimestreUpdateWithoutNote_interInput, TrimestreUncheckedUpdateWithoutNote_interInput>
    create: XOR<TrimestreCreateWithoutNote_interInput, TrimestreUncheckedCreateWithoutNote_interInput>
    where?: TrimestreWhereInput
  }

  export type TrimestreUpdateToOneWithWhereWithoutNote_interInput = {
    where?: TrimestreWhereInput
    data: XOR<TrimestreUpdateWithoutNote_interInput, TrimestreUncheckedUpdateWithoutNote_interInput>
  }

  export type TrimestreUpdateWithoutNote_interInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_devoir?: Note_devoirUpdateManyWithoutTrimestreNestedInput
    rang?: RangUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreUncheckedUpdateWithoutNote_interInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutTrimestreNestedInput
    rang?: RangUncheckedUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUncheckedUpdateManyWithoutTrimestreNestedInput
  }

  export type EleveCreateWithoutNote_devoirInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    username: string
    password: string
    role?: string
    classe: ClasseCreateNestedOneWithoutElevesInput
    parent: ParentCreateNestedOneWithoutEnfantsInput
    note_inter?: Note_interCreateNestedManyWithoutEleveInput
    rang?: RangCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireCreateNestedManyWithoutEleveInput
  }

  export type EleveUncheckedCreateWithoutNote_devoirInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    id_parent: number
    username: string
    password: string
    role?: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEleveInput
    rang?: RangUncheckedCreateNestedManyWithoutEleveInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEleveInput
  }

  export type EleveCreateOrConnectWithoutNote_devoirInput = {
    where: EleveWhereUniqueInput
    create: XOR<EleveCreateWithoutNote_devoirInput, EleveUncheckedCreateWithoutNote_devoirInput>
  }

  export type EnseignantCreateWithoutNote_devoirInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantUncheckedCreateWithoutNote_devoirInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    contact: string
    sexe: string
    email?: string | null
    photo?: Buffer | null
    username: string
    password: string
    role?: string
    enseignant_classe?: Enseignant_ClasseUncheckedCreateNestedManyWithoutEnseignantInput
    note_inter?: Note_interUncheckedCreateNestedManyWithoutEnseignantInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutEnseignantInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutEnseignantInput
  }

  export type EnseignantCreateOrConnectWithoutNote_devoirInput = {
    where: EnseignantWhereUniqueInput
    create: XOR<EnseignantCreateWithoutNote_devoirInput, EnseignantUncheckedCreateWithoutNote_devoirInput>
  }

  export type MatiereCreateWithoutNote_devoirInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    note_inter?: Note_interCreateNestedManyWithoutMatiereInput
    rang?: RangCreateNestedManyWithoutMatiereInput
    coeffient: CoefficientCreateNestedOneWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutNote_devoirInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
    id_coefficient: number
    note_inter?: Note_interUncheckedCreateNestedManyWithoutMatiereInput
    rang?: RangUncheckedCreateNestedManyWithoutMatiereInput
    enseignant_matiere?: Enseignant_ClasseUncheckedCreateNestedManyWithoutMatiereInput
    commentaire?: CommentaireUncheckedCreateNestedManyWithoutMatiereInput
    piecejointe?: PieceJointeUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutNote_devoirInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutNote_devoirInput, MatiereUncheckedCreateWithoutNote_devoirInput>
  }

  export type TrimestreCreateWithoutNote_devoirInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interCreateNestedManyWithoutTrimestreInput
    rang?: RangCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreUncheckedCreateWithoutNote_devoirInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    note_inter?: Note_interUncheckedCreateNestedManyWithoutTrimestreInput
    rang?: RangUncheckedCreateNestedManyWithoutTrimestreInput
    commenstaire?: CommentaireUncheckedCreateNestedManyWithoutTrimestreInput
  }

  export type TrimestreCreateOrConnectWithoutNote_devoirInput = {
    where: TrimestreWhereUniqueInput
    create: XOR<TrimestreCreateWithoutNote_devoirInput, TrimestreUncheckedCreateWithoutNote_devoirInput>
  }

  export type EleveUpsertWithoutNote_devoirInput = {
    update: XOR<EleveUpdateWithoutNote_devoirInput, EleveUncheckedUpdateWithoutNote_devoirInput>
    create: XOR<EleveCreateWithoutNote_devoirInput, EleveUncheckedCreateWithoutNote_devoirInput>
    where?: EleveWhereInput
  }

  export type EleveUpdateToOneWithWhereWithoutNote_devoirInput = {
    where?: EleveWhereInput
    data: XOR<EleveUpdateWithoutNote_devoirInput, EleveUncheckedUpdateWithoutNote_devoirInput>
  }

  export type EleveUpdateWithoutNote_devoirInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutNote_devoirInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EnseignantUpsertWithoutNote_devoirInput = {
    update: XOR<EnseignantUpdateWithoutNote_devoirInput, EnseignantUncheckedUpdateWithoutNote_devoirInput>
    create: XOR<EnseignantCreateWithoutNote_devoirInput, EnseignantUncheckedCreateWithoutNote_devoirInput>
    where?: EnseignantWhereInput
  }

  export type EnseignantUpdateToOneWithWhereWithoutNote_devoirInput = {
    where?: EnseignantWhereInput
    data: XOR<EnseignantUpdateWithoutNote_devoirInput, EnseignantUncheckedUpdateWithoutNote_devoirInput>
  }

  export type EnseignantUpdateWithoutNote_devoirInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutEnseignantNestedInput
  }

  export type EnseignantUncheckedUpdateWithoutNote_devoirInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    sexe?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    enseignant_classe?: Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantNestedInput
    note_inter?: Note_interUncheckedUpdateManyWithoutEnseignantNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEnseignantNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutEnseignantNestedInput
  }

  export type MatiereUpsertWithoutNote_devoirInput = {
    update: XOR<MatiereUpdateWithoutNote_devoirInput, MatiereUncheckedUpdateWithoutNote_devoirInput>
    create: XOR<MatiereCreateWithoutNote_devoirInput, MatiereUncheckedCreateWithoutNote_devoirInput>
    where?: MatiereWhereInput
  }

  export type MatiereUpdateToOneWithWhereWithoutNote_devoirInput = {
    where?: MatiereWhereInput
    data: XOR<MatiereUpdateWithoutNote_devoirInput, MatiereUncheckedUpdateWithoutNote_devoirInput>
  }

  export type MatiereUpdateWithoutNote_devoirInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    coeffient?: CoefficientUpdateOneRequiredWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutNote_devoirInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    id_coefficient?: IntFieldUpdateOperationsInput | number
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type TrimestreUpsertWithoutNote_devoirInput = {
    update: XOR<TrimestreUpdateWithoutNote_devoirInput, TrimestreUncheckedUpdateWithoutNote_devoirInput>
    create: XOR<TrimestreCreateWithoutNote_devoirInput, TrimestreUncheckedCreateWithoutNote_devoirInput>
    where?: TrimestreWhereInput
  }

  export type TrimestreUpdateToOneWithWhereWithoutNote_devoirInput = {
    where?: TrimestreWhereInput
    data: XOR<TrimestreUpdateWithoutNote_devoirInput, TrimestreUncheckedUpdateWithoutNote_devoirInput>
  }

  export type TrimestreUpdateWithoutNote_devoirInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutTrimestreNestedInput
    rang?: RangUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUpdateManyWithoutTrimestreNestedInput
  }

  export type TrimestreUncheckedUpdateWithoutNote_devoirInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutTrimestreNestedInput
    rang?: RangUncheckedUpdateManyWithoutTrimestreNestedInput
    commenstaire?: CommentaireUncheckedUpdateManyWithoutTrimestreNestedInput
  }

  export type EleveCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_parent: number
    username: string
    password: string
    role?: string
  }

  export type Enseignant_ClasseCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_matiere: number
  }

  export type PieceJointeCreateManyClasseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_matiere: number
    id_enseignant: number
  }

  export type EleveUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parent?: ParentUpdateOneRequiredWithoutEnfantsNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_parent?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type Enseignant_ClasseUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enseignant?: EnseignantUpdateOneRequiredWithoutEnseignant_classeNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutEnseignant_matiereNestedInput
  }

  export type Enseignant_ClasseUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type PieceJointeUpdateWithoutClasseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    matiere?: MatiereUpdateOneRequiredWithoutPiecejointeNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutPiecejointeNestedInput
  }

  export type PieceJointeUncheckedUpdateWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type PieceJointeUncheckedUpdateManyWithoutClasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type Note_interCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type RangCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_eleve: number
    id_trimestre: number
  }

  export type Enseignant_ClasseCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_enseignant: number
    id_classe: number
  }

  export type CommentaireCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_trimestre: number
    vu?: boolean
  }

  export type PieceJointeCreateManyMatiereInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_enseignant: number
  }

  export type Note_interUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_interNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_interNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_interNestedInput
  }

  export type Note_interUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_devoirNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_devoirNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_devoirNestedInput
  }

  export type Note_devoirUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RangUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    eleve?: EleveUpdateOneRequiredWithoutRangNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutRangNestedInput
  }

  export type RangUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type RangUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enseignant?: EnseignantUpdateOneRequiredWithoutEnseignant_classeNestedInput
    classe?: ClasseUpdateOneRequiredWithoutEnseignant_classeNestedInput
  }

  export type Enseignant_ClasseUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_classe?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_classe?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutCommentaireNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutCommentaireNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutCommenstaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PieceJointeUpdateWithoutMatiereInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    classe?: ClasseUpdateOneRequiredWithoutPiecejointeNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutPiecejointeNestedInput
  }

  export type PieceJointeUncheckedUpdateWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type PieceJointeUncheckedUpdateManyWithoutMatiereInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
  }

  export type MatiereCreateManyCoeffientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere: string
  }

  export type MatiereUpdateWithoutCoeffientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutMatiereNestedInput
    rang?: RangUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutCoeffientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutMatiereNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutMatiereNestedInput
    rang?: RangUncheckedUpdateManyWithoutMatiereNestedInput
    enseignant_matiere?: Enseignant_ClasseUncheckedUpdateManyWithoutMatiereNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutMatiereNestedInput
    piecejointe?: PieceJointeUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateManyWithoutCoeffientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: StringFieldUpdateOperationsInput | string
  }

  export type EleveCreateManyParentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nom: string
    prenom: string
    email?: string | null
    photo?: Buffer | null
    sexe: string
    id_classe: number
    username: string
    password: string
    role?: string
  }

  export type EleveUpdateWithoutParentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    classe?: ClasseUpdateOneRequiredWithoutElevesNestedInput
    note_inter?: Note_interUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUpdateManyWithoutEleveNestedInput
    rang?: RangUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    note_inter?: Note_interUncheckedUpdateManyWithoutEleveNestedInput
    note_devoir?: Note_devoirUncheckedUpdateManyWithoutEleveNestedInput
    rang?: RangUncheckedUpdateManyWithoutEleveNestedInput
    commentaire?: CommentaireUncheckedUpdateManyWithoutEleveNestedInput
  }

  export type EleveUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    sexe?: StringFieldUpdateOperationsInput | string
    id_classe?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type Enseignant_ClasseCreateManyEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id_classe: number
    id_matiere: number
  }

  export type Note_interCreateManyEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateManyEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type CommentaireCreateManyEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type PieceJointeCreateManyEnseignantInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    titre: string
    piece: Buffer
    id_classe: number
    id_matiere: number
  }

  export type Enseignant_ClasseUpdateWithoutEnseignantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classe?: ClasseUpdateOneRequiredWithoutEnseignant_classeNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutEnseignant_matiereNestedInput
  }

  export type Enseignant_ClasseUncheckedUpdateWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type Enseignant_ClasseUncheckedUpdateManyWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type Note_interUpdateWithoutEnseignantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_interNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_interNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_interNestedInput
  }

  export type Note_interUncheckedUpdateWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interUncheckedUpdateManyWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUpdateWithoutEnseignantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_devoirNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_devoirNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_devoirNestedInput
  }

  export type Note_devoirUncheckedUpdateWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUncheckedUpdateManyWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUpdateWithoutEnseignantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutCommentaireNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutCommentaireNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutCommenstaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PieceJointeUpdateWithoutEnseignantInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    classe?: ClasseUpdateOneRequiredWithoutPiecejointeNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutPiecejointeNestedInput
  }

  export type PieceJointeUncheckedUpdateWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type PieceJointeUncheckedUpdateManyWithoutEnseignantInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titre?: StringFieldUpdateOperationsInput | string
    piece?: BytesFieldUpdateOperationsInput | Buffer
    id_classe?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
  }

  export type Note_interCreateManyEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_devoirCreateManyEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type RangCreateManyEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_trimestre: number
  }

  export type CommentaireCreateManyEleveInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_enseignant: number
    id_matiere: number
    id_trimestre: number
    vu?: boolean
  }

  export type Note_interUpdateWithoutEleveInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_interNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_interNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_interNestedInput
  }

  export type Note_interUncheckedUpdateWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interUncheckedUpdateManyWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUpdateWithoutEleveInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_devoirNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_devoirNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutNote_devoirNestedInput
  }

  export type Note_devoirUncheckedUpdateWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUncheckedUpdateManyWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RangUpdateWithoutEleveInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    matiere?: MatiereUpdateOneRequiredWithoutRangNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutRangNestedInput
  }

  export type RangUncheckedUpdateWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type RangUncheckedUpdateManyWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireUpdateWithoutEleveInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
    enseignant?: EnseignantUpdateOneRequiredWithoutCommentaireNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutCommentaireNestedInput
    trimestre?: TrimestreUpdateOneRequiredWithoutCommenstaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyWithoutEleveInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_trimestre?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interCreateManyTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inter: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type Note_devoirCreateManyTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devoir: number
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type RangCreateManyTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rang: number
    id_matiere: number
    id_eleve: number
  }

  export type CommentaireCreateManyTrimestreInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contenu: string
    id_eleve: number
    id_enseignant: number
    id_matiere: number
    vu?: boolean
  }

  export type Note_interUpdateWithoutTrimestreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_interNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_interNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_interNestedInput
  }

  export type Note_interUncheckedUpdateWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_interUncheckedUpdateManyWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inter?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUpdateWithoutTrimestreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutNote_devoirNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutNote_devoirNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutNote_devoirNestedInput
  }

  export type Note_devoirUncheckedUpdateWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Note_devoirUncheckedUpdateManyWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devoir?: FloatFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RangUpdateWithoutTrimestreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    matiere?: MatiereUpdateOneRequiredWithoutRangNestedInput
    eleve?: EleveUpdateOneRequiredWithoutRangNestedInput
  }

  export type RangUncheckedUpdateWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
  }

  export type RangUncheckedUpdateManyWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rang?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    id_eleve?: IntFieldUpdateOperationsInput | number
  }

  export type CommentaireUpdateWithoutTrimestreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    vu?: BoolFieldUpdateOperationsInput | boolean
    eleve?: EleveUpdateOneRequiredWithoutCommentaireNestedInput
    enseignant?: EnseignantUpdateOneRequiredWithoutCommentaireNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutCommentaireNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentaireUncheckedUpdateManyWithoutTrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contenu?: StringFieldUpdateOperationsInput | string
    id_eleve?: IntFieldUpdateOperationsInput | number
    id_enseignant?: IntFieldUpdateOperationsInput | number
    id_matiere?: IntFieldUpdateOperationsInput | number
    vu?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClasseCountOutputTypeDefaultArgs instead
     */
    export type ClasseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClasseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatiereCountOutputTypeDefaultArgs instead
     */
    export type MatiereCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatiereCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoefficientCountOutputTypeDefaultArgs instead
     */
    export type CoefficientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoefficientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentCountOutputTypeDefaultArgs instead
     */
    export type ParentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnseignantCountOutputTypeDefaultArgs instead
     */
    export type EnseignantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnseignantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EleveCountOutputTypeDefaultArgs instead
     */
    export type EleveCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EleveCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrimestreCountOutputTypeDefaultArgs instead
     */
    export type TrimestreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrimestreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClasseDefaultArgs instead
     */
    export type ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClasseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatiereDefaultArgs instead
     */
    export type MatiereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatiereDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RangDefaultArgs instead
     */
    export type RangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoefficientDefaultArgs instead
     */
    export type CoefficientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoefficientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentDefaultArgs instead
     */
    export type ParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnseignantDefaultArgs instead
     */
    export type EnseignantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnseignantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EleveDefaultArgs instead
     */
    export type EleveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EleveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentaireDefaultArgs instead
     */
    export type CommentaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PieceJointeDefaultArgs instead
     */
    export type PieceJointeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PieceJointeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Enseignant_ClasseDefaultArgs instead
     */
    export type Enseignant_ClasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Enseignant_ClasseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrimestreDefaultArgs instead
     */
    export type TrimestreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrimestreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Note_interDefaultArgs instead
     */
    export type Note_interArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Note_interDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Note_devoirDefaultArgs instead
     */
    export type Note_devoirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Note_devoirDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DirecteurDefaultArgs instead
     */
    export type DirecteurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DirecteurDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}